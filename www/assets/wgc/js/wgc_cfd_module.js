!function(modules) {
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: !1,
            exports: {}
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
        module.l = !0, module.exports;
    }
    var installedModules = {};
    __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function(exports, name, getter) {
        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
            configurable: !1,
            enumerable: !0,
            get: getter
        });
    }, __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function() {
            return module.default;
        } : function() {
            return module;
        };
        return __webpack_require__.d(getter, "a", getter), getter;
    }, __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 12);
}([ function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(gxDc) {
            void 0 == String.prototype.formatString && (String.prototype.formatString = function(arg) {
                var rep_fn = void 0;
                if ("object" == typeof arg) rep_fn = function(m, k) {
                    return arg[k];
                }; else {
                    var args = arguments;
                    rep_fn = function(m, k) {
                        return args[parseInt(k)];
                    };
                }
                return this.replace(/\{(\w+)\}/g, rep_fn);
            }), void 0 == String.prototype.compress && (String.prototype.compress = function(asArray) {
                asArray = !0 === asArray;
                var i, c, wc, dictionary = {}, uncompressed = this, w = "", result = [], ASCII = "", dictSize = 256;
                for (i = 0; i < 256; i += 1) dictionary[String.fromCharCode(i)] = i;
                for (i = 0; i < uncompressed.length; i += 1) c = uncompressed.charAt(i), wc = w + c, 
                dictionary.hasOwnProperty(wc) ? w = wc : (result.push(dictionary[w]), ASCII += String.fromCharCode(dictionary[w]), 
                dictionary[wc] = dictSize++, w = String(c));
                return "" !== w && (result.push(dictionary[w]), ASCII += String.fromCharCode(dictionary[w])), 
                asArray ? result : ASCII;
            }), void 0 == String.prototype.decompress && (String.prototype.decompress = function() {
                var i, w, result, k, tmp = [], dictionary = [], compressed = this, entry = "", dictSize = 256;
                for (i = 0; i < 256; i += 1) dictionary[i] = String.fromCharCode(i);
                if (compressed && "string" == typeof compressed) {
                    for (i = 0; i < compressed.length; i += 1) tmp.push(compressed[i].charCodeAt(0));
                    compressed = tmp, tmp = null;
                }
                for (w = String.fromCharCode(compressed[0]), result = w, i = 1; i < compressed.length; i += 1) {
                    if (k = compressed[i], dictionary[k]) entry = dictionary[k]; else {
                        if (k !== dictSize) return null;
                        entry = w + w.charAt(0);
                    }
                    result += entry, dictionary[dictSize++] = w + entry.charAt(0), w = entry;
                }
                return result;
            });
            var _ChartUtils = {};
            return _ChartUtils.debug = {}, _ChartUtils.debug.staticCount = 0, _ChartUtils.debug.modeOn = !0, 
            _ChartUtils.debug.logDebug = function(str) {
                _ChartUtils.debug.logger ? _ChartUtils.debug.logger.debug(str) : console.debug("[WGC][LOG:D] " + str);
            }, _ChartUtils.debug.logTrace = function(str) {
                console.debug("[WGC][LOG:T] " + str);
            }, _ChartUtils.debug.logInfo = function(str) {
                console.debug("[WGC][LOG:I] " + str);
            }, _ChartUtils.debug.logWarn = function(str) {
                console.debug("[WGC][LOG:W] " + str);
            }, _ChartUtils.debug.logError = function(str) {
                console.debug("[WGC][LOG:E] " + str);
            }, _ChartUtils.debug.log = function(str, level) {
                "trace" === level ? _ChartUtils.debug.logTrace(str) : "info" === level ? _ChartUtils.debug.logInfo(str) : "warn" === level ? _ChartUtils.debug.logWarn(str) : "error" === level ? _ChartUtils.debug.logError(str) : _ChartUtils.debug.logDebug(str);
            }, _ChartUtils.debug.formattedLog = function(level, strFormat) {
                var argLen = arguments.length, strLog = strFormat;
                if (argLen > 1 && void 0 !== strFormat.formatString) {
                    for (var arrData = [], ii = 2; ii < argLen; ii++) arrData.push(arguments[ii]);
                    strLog = strFormat.formatString(arrData);
                }
                _ChartUtils.debug.log(strLog, level);
            }, _ChartUtils.debug.logForCompareValue = function(prefix, argOld, argNew, level) {
                var str = prefix + " => Old(" + argOld + "), New(" + argNew + ")";
                _ChartUtils.debug.log(str, level);
            }, _ChartUtils.debug.getTimeZoneInfo = function(argSymbolCode) {
                if (void 0 !== $.ngcModule && !0 === $.ngcModule.hasOwnProperty("testUnitsChart")) return $.ngcModule.testUnitsChart.getTimeZoneInfo(argSymbolCode);
            }, _ChartUtils.debug.getSymbolCodes = function() {
                if (void 0 !== $.ngcModule && !0 === $.ngcModule.hasOwnProperty("testUnitsChart")) return $.ngcModule.testUnitsChart.getSymbolCodes();
            }, _ChartUtils.debug.didGetDataSimulator = function() {
                if (void 0 !== $.ngcModule && !0 === $.ngcModule.hasOwnProperty("testUnitsChart")) return $.ngcModule.testUnitsChart.getDataSimulator();
            }, _ChartUtils.debug.didGetOrderPositSimulator = function() {
                if (void 0 !== $.ngcModule && !0 === $.ngcModule.hasOwnProperty("testUnitsChart")) return $.ngcModule.testUnitsChart.getOrderPositSimulator();
            }, _ChartUtils.color = {}, _ChartUtils.color.tables = {
                keywords: {},
                lists: [ "#D61004", "#86D2B5", "#CDCB00", "#E96126", "#FCC507", "#44B3C2", "#F1A94E", "#E45641", "#5D4C46", "#7B8D8E", "#F2EDD8" ]
            }, _ChartUtils.color.invertColor = function(hexTripletColor) {
                try {
                    var color = hexTripletColor;
                    return color = color.substring(1), color = parseInt(color, 16), color ^= 16777215, 
                    color = color.toString(16), color = ("000000" + color).slice(-6), color = "#" + color;
                } catch (e) {
                    console.debug(e);
                }
                return hexTripletColor;
            }, _ChartUtils.shapes = {}, _ChartUtils.shapes.RECT = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }, _ChartUtils.shapes.SIZE = {
                cx: 0,
                cy: 0
            }, _ChartUtils.shapes.POINT = {
                x: 0,
                y: 0
            }, _ChartUtils.shapes.didGetDefaultRect = function() {
                return _ChartUtils.didClone(_ChartUtils.shapes.RECT);
            }, _ChartUtils.shapes.didGetDefaultSize = function() {
                return _ChartUtils.didClone(_ChartUtils.shapes.SIZE);
            }, _ChartUtils.shapes.didGetDefaultPoint = function() {
                return _ChartUtils.didClone(_ChartUtils.shapes.POINT);
            }, _ChartUtils.shapes.SetRect = function(rect, x, y, width, height) {
                "object" == typeof rect && (rect.x = x, rect.y = y, rect.width = width, rect.height = height);
            }, _ChartUtils.shapes.InflateRect = function(rect, x, y) {
                "object" == typeof rect && (rect.x -= x, rect.y -= y, rect.width += 2 * x, rect.height += 2 * y);
            }, _ChartUtils.shapes.Rect = {}, _ChartUtils.shapes.Rect.Contains = function(pos, rect, useBorder) {
                if (void 0 === pos || null == pos || void 0 === rect || null == rect) return !1;
                if (!0 === useBorder) {
                    if (pos.x >= rect.x && pos.x <= rect.x + rect.width && pos.y >= rect.y && pos.y <= rect.y + rect.height) return !0;
                } else if (pos.x > rect.x && pos.x < rect.x + rect.width && pos.y > rect.y && pos.y < rect.y + rect.height) return !0;
                return !1;
            }, _ChartUtils.shapes.posInRect = function(pos, rect, useBorder) {
                if (void 0 === pos || null == pos || void 0 === rect || null == rect) return !1;
                if (!0 === useBorder) {
                    if (pos.x >= rect.x && pos.x <= rect.x + rect.width && pos.y >= rect.y && pos.y <= rect.y + rect.height) return !0;
                } else if (pos.x > rect.x && pos.x < rect.x + rect.width && pos.y > rect.y && pos.y < rect.y + rect.height) return !0;
                return !1;
            }, _ChartUtils.shapes.posvalInRect = function(posval, rect, useBorder) {
                if (void 0 === posval || null == posval || void 0 === rect || null == rect) return !1;
                if (!0 === useBorder) {
                    if (posval.XPos >= rect.x && posval.XPos <= rect.x + rect.width && posval.YPos >= rect.y && posval.YPos <= rect.y + rect.height) return !0;
                } else if (posval.XPos > rect.x && posval.XPos < rect.x + rect.width && posval.YPos > rect.y && posval.YPos < rect.y + rect.height) return !0;
                return !1;
            }, _ChartUtils.mobileGesture = {}, _ChartUtils.mobileGesture.swipeConfig = {
                durationThreshold: 500,
                horizontalDistanceThreshold: 30,
                verticalDistanceThreshold: 30
            }, _ChartUtils.mobileGesture.swipeStart = function(posval) {
                var timeStamp = new Date().getTime();
                return {
                    swipestart: {
                        coords: [ posval.XPos, posval.YPos ],
                        time: timeStamp
                    },
                    swipestop: {
                        coords: [ posval.XPos, posval.YPos ],
                        time: timeStamp
                    },
                    isTrigger: !1,
                    type: void 0,
                    changed: {
                        coords: [ 0, 0 ],
                        time: 0
                    }
                };
            }, _ChartUtils.mobileGesture.swipeMove = function(swipeEvent, posval) {
                if (void 0 !== swipeEvent && null != swipeEvent) {
                    var timeStamp = new Date().getTime();
                    return swipeEvent.swipestop.coords[0] = swipeEvent.swipestart.coords[0], swipeEvent.swipestop.coords[1] = swipeEvent.swipestart.coords[1], 
                    swipeEvent.swipestop.time = swipeEvent.swipestart.time, swipeEvent.swipestart.coords[0] = posval.XPos, 
                    swipeEvent.swipestart.coords[1] = posval.YPos, swipeEvent.swipestart.time = timeStamp, 
                    swipeEvent.isTrigger = !1, swipeEvent;
                }
            }, _ChartUtils.mobileGesture.swipeEnd = function(swipeEvent, posval) {
                if (void 0 !== swipeEvent && null != swipeEvent) {
                    var timeStamp = new Date().getTime();
                    swipeEvent.swipestop.coords[0] = posval.XPos, swipeEvent.swipestop.coords[1] = posval.YPos, 
                    swipeEvent.swipestop.time = timeStamp;
                    var horizontalDistanceThreshold = _ChartUtils.mobileGesture.swipeConfig.horizontalDistanceThreshold, durationThreshold = _ChartUtils.mobileGesture.swipeConfig.durationThreshold, distanceCheck = swipeEvent.swipestop.coords[0] - swipeEvent.swipestart.coords[0], durationCheck = swipeEvent.swipestop.time - swipeEvent.swipestart.time;
                    return swipeEvent.changed.coords[0] = distanceCheck, swipeEvent.changed.time = durationCheck, 
                    Math.abs(distanceCheck) >= horizontalDistanceThreshold && durationCheck <= durationThreshold ? (swipeEvent.isTrigger = !0, 
                    swipeEvent.type = distanceCheck < 0 ? "swipeleft" : "swiperight", swipeEvent) : void 0;
                }
            }, _ChartUtils.smoothScroll = {}, _ChartUtils.smoothScroll.config = {
                minimumMiliseconds: 10,
                spline: null,
                velocityMax: 4,
                velocityRange: .25,
                secondsFactor: 1e3,
                frame: 15,
                duration: 3,
                timerFactor: 10,
                overflowFactor: 5,
                overflowDefaultCount: 20,
                distanceFactor: 1,
                maxDistanceFactor: 5
            }, _ChartUtils.smoothScroll.didGetBezierCurveInfo = function(initialFactor, distanceFactor, duration, frame, timerFactor, overflowFactor, overflowDefaultCount) {
                var result = {
                    timerMs: 10,
                    overLimit: 100,
                    direction: -1,
                    datas: []
                }, velocityMax = _ChartUtils.smoothScroll.config.velocityMax, velocityRange = _ChartUtils.smoothScroll.config.velocityRange, secondsFactor = _ChartUtils.smoothScroll.config.secondsFactor;
                frame = void 0 === frame || null == frame ? _ChartUtils.smoothScroll.config.frame : frame, 
                duration = void 0 === duration || null == duration ? _ChartUtils.smoothScroll.config.duration : duration, 
                timerFactor = void 0 === timerFactor || null == timerFactor ? _ChartUtils.smoothScroll.config.timerFactor : timerFactor, 
                overflowFactor = void 0 === overflowFactor || null == overflowFactor ? _ChartUtils.smoothScroll.config.overflowFactor : overflowFactor, 
                overflowDefaultCount = void 0 === overflowDefaultCount || null == overflowDefaultCount ? _ChartUtils.smoothScroll.config.overflowDefaultCount : overflowDefaultCount, 
                distanceFactor = void 0 === distanceFactor || null == distanceFactor || 0 === distanceFactor ? _ChartUtils.smoothScroll.config.distanceFactor : distanceFactor, 
                distanceFactor > 1 && (distanceFactor = Math.sqrt(distanceFactor)), distanceFactor = Math.min(_ChartUtils.smoothScroll.config.maxDistanceFactor, distanceFactor);
                var velocityFactor = 1 / distanceFactor, newDistanceFactor = _ChartUtils.smoothScroll.config.distanceFactor, spline = _ChartUtils.smoothScroll.config.spline;
                void 0 !== spline && null != spline || (spline = _ChartUtils.smoothScroll.config.spline = new KeySpline(.25, .9, .1, 1));
                var initialRatio = 0, timeRangeRatio = 1, overflowCount = 0, direction = 1;
                void 0 !== initialFactor && null != initialFactor && (initialFactor >= 0 ? direction = 1 : (direction = -1, 
                initialFactor *= -1), newDistanceFactor = Math.max(1, velocityFactor + initialFactor), 
                initialFactor = Math.max(Math.min(velocityMax, initialFactor), .01), initialRatio = (1 - initialFactor / velocityMax) * velocityRange, 
                timeRangeRatio = (1 - spline.get(initialFactor / velocityMax)) * timerFactor, overflowCount = (1 - spline.get(initialFactor / velocityMax)) * overflowFactor), 
                result.direction = direction;
                var timeRange = duration * secondsFactor * timeRangeRatio * velocityFactor, loop = frame * duration * newDistanceFactor;
                result.timerMs = Math.max(_ChartUtils.smoothScroll.config.minimumMiliseconds, parseInt(timeRange / loop)), 
                result.overLimit = overflowCount + overflowDefaultCount;
                for (var startIndex = 1 + Math.round(initialRatio * loop), milliSecondsForFrame = secondsFactor / frame, ii = startIndex; ii < loop; ii++) {
                    var splineX = ii / loop, splineY = 1 - spline.get(splineX), velocity = splineY * velocityFactor * direction, distance = velocity * milliSecondsForFrame;
                    result.datas.push({
                        splineX: splineX,
                        splineY: splineY,
                        velocity: velocity,
                        distance: distance,
                        no: ii
                    });
                }
                return result.debug = {
                    frame: frame,
                    duration: duration,
                    timerFactor: timerFactor,
                    overflowFactor: overflowFactor,
                    overflowDefaultCount: overflowDefaultCount,
                    initialRatio: initialRatio,
                    timeRangeRatio: timeRangeRatio,
                    overflowCount: overflowCount,
                    initialFactor: initialFactor,
                    timeRange: timeRange,
                    distanceFactor: distanceFactor,
                    velocityFactor: velocityFactor,
                    newDistanceFactor: velocityFactor * initialFactor
                }, result;
            }, _ChartUtils.dataConverter = {}, _ChartUtils.dataConverter.requestInfo = {
                nDIdx: 0,
                nEType: 0,
                nMType: 0,
                nPType: 0,
                nBCnt: 0,
                nTType: 0,
                nTGap: 1,
                nPValCrt: 0,
                nPValOep: 0,
                nGaps: [ 1, 1, 1, 1, 1, 1, 1 ],
                strName: "",
                strCode: "",
                strTime: "",
                nSTime: 0,
                nETime: 0,
                nCType: 0,
                bRemains: !1,
                bN_MPrice: !1,
                nDType: 0,
                nTickCount: 0,
                bChanged: !1,
                bRequest: !1,
                bComplete: !1,
                nCallPage: 0,
                nCallCount: 0,
                nEDate4Call: 0,
                bUseMultiVal: !1,
                strDispExtra: "",
                strDispTab: "",
                bLoadFlag: !1,
                nServerDate: 0,
                nSWorkTime: 0,
                nEWorkTime: 0,
                requestCode: "",
                receiveInfo: {},
                dummy: 0
            }, _ChartUtils.dataConverter.didGetDefaultRequestInfo = function() {
                return _ChartUtils.didClone(_ChartUtils.dataConverter.requestInfo);
            }, _ChartUtils.dataConverter.didCalcAverageCandle = function(argData, isFull) {
                if (void 0 !== argData && null != argData) {
                    try {
                        var __nCount = argData.length;
                        if (__nCount < 2) return !1;
                        var __nStart = 1;
                        !0 !== isFull && (__nStart = __nCount - 1);
                        for (var __ii = __nStart; __ii < __nCount; __ii++) {
                            var __stPricePre = argData[__ii - 1], __stPriceRef = argData[__ii];
                            if (__stPriceRef && __stPricePre) {
                                var __avgOpen = Math.round(.5 * (__stPricePre.open + __stPricePre.close)), __avgClose = Math.round(.25 * (__stPriceRef.open + __stPriceRef.high + __stPriceRef.low + __stPriceRef.close));
                                __stPriceRef.avgOpen = __avgOpen, __stPriceRef.avgClose = __avgClose;
                            }
                        }
                        return !0;
                    } catch (e) {
                        console.error(e);
                    }
                    return !1;
                }
            }, _ChartUtils.dataConverter.didCalcCompareData = function(argData, pointValue, isFull) {
                if (void 0 !== argData && null != argData) {
                    try {
                        var __nCount = argData.length;
                        if (__nCount < 1) return !1;
                        pointValue = pointValue || 0, pointValue = Math.max(0, pointValue);
                        var __pow = Math.pow(10, pointValue), __stPriceBase = argData[0], __nStart = 0;
                        !0 !== isFull && (__nStart = __nCount - 1);
                        for (var __ii = __nStart; __ii < __nCount; __ii++) {
                            var __stPriceRef = argData[__ii];
                            if (__stPriceRef) if (__stPriceBase) {
                                var __compareData = Math.round(__pow * (100 * (__stPriceRef.close - __stPriceBase.close) / __stPriceBase.close));
                                __compareData = __compareData || 0, __stPriceRef.compareData = __compareData;
                            } else __stPriceRef.compareData = 0;
                        }
                        return !0;
                    } catch (e) {
                        console.error(e);
                    }
                    return !1;
                }
            }, _ChartUtils.dataConverter.didMergePriceDataWithRealData = function(argxPrice, receiveData) {
                var stPrice;
                stPrice = void 0 === argxPrice || null == argxPrice ? _ChartUtils.didClone(receiveData) : _ChartUtils.didClone(argxPrice);
                var close = receiveData.close;
                return stPrice.close <= 0 ? stPrice.open = stPrice.high = stPrice.low = stPrice.close = close : (stPrice.close = close, 
                stPrice.high < close && (stPrice.high = close), stPrice.low > close && (stPrice.low = close)), 
                stPrice.volume += receiveData.volume, stPrice.amount += receiveData.amount, stPrice;
            }, _ChartUtils.dataConverter.didConvertRawTimeToChartTime = function(rawTime) {
                if ("string" == typeof rawTime) {
                    var timeDatas = rawTime.split(":");
                    return 1e4 * parseInt(timeDatas[0]) + 100 * parseInt(timeDatas[1]) + 0;
                }
            }, _ChartUtils.dataConverter.didValidateData = function(stPrice, bModify) {
                return !0 !== _ChartUtils.validator.isValidPrice(stPrice) && (!0 === bModify && (stPrice.open = stPrice.high = stPrice.low = stPrice.close = 0), 
                stPrice.flag = !1), stPrice;
            }, _ChartUtils.dataConverter.didConvertSerialData = function(receiveRawData, bModify) {
                if (void 0 !== receiveRawData && null != receiveRawData) {
                    var stPrice = {
                        ymd: receiveRawData[0],
                        hms: receiveRawData[1],
                        open: receiveRawData[2],
                        high: receiveRawData[3],
                        low: receiveRawData[4],
                        close: receiveRawData[5],
                        volume: receiveRawData[6],
                        amount: receiveRawData[7],
                        oi: receiveRawData[8],
                        tno: 0,
                        seqNo: 0,
                        flag: !0
                    };
                    return receiveRawData.length > 9 && (stPrice.seqNo = receiveRawData[9], void 0 !== stPrice.seqNo && null != stPrice.seqNo || (stPrice.seqNo = 0)), 
                    _ChartUtils.dataConverter.didValidateData(stPrice, bModify), stPrice;
                }
            }, _ChartUtils.dataConverter.didConvertTickData = function(receiveRawData, bModify) {
                if (void 0 !== receiveRawData && null != receiveRawData) {
                    var close = receiveRawData.Price, volume = receiveRawData.Qty, seqNo = receiveRawData.SequenceNum, stPrice = {
                        ymd: 0,
                        hms: _ChartUtils.dataConverter.didConvertRawTimeToChartTime(receiveRawData.Time),
                        open: close,
                        high: close,
                        low: close,
                        close: close,
                        volume: volume,
                        amount: 0,
                        oi: 0,
                        tno: 0,
                        seqNo: seqNo,
                        flag: !0
                    };
                    return _ChartUtils.dataConverter.didValidateData(stPrice, bModify), stPrice;
                }
            }, _ChartUtils.dataConverter.didConvertCandleStickData = function(receiveRawData, bModify) {
                if (void 0 !== receiveRawData && null != receiveRawData) {
                    return {
                        ymd: receiveRawData.ChartDate,
                        hms: _ChartUtils.dataConverter.didConvertRawTimeToChartTime(receiveRawData.PriceTime),
                        open: receiveRawData.OpenPrice,
                        high: receiveRawData.HighPrice,
                        low: receiveRawData.LowPrice,
                        close: receiveRawData.ClosePrice,
                        volume: receiveRawData.Volume,
                        amount: 0,
                        oi: 0,
                        tno: 0,
                        flag: !0
                    };
                }
            }, _ChartUtils.dataConverter.didMakeEmptyPriceData = function(dateTimeUnit, closePrice) {
                var stDatetime = _ChartUtils.timeZone.convertTimeunitToDatetime(dateTimeUnit), stPrice = {
                    ymd: stDatetime.date,
                    hms: stDatetime.time,
                    open: closePrice,
                    high: closePrice,
                    low: closePrice,
                    close: closePrice,
                    volume: 0,
                    amount: 0,
                    oi: 0,
                    tno: 0,
                    flag: !0
                };
                return stPrice.fixed = !0, stPrice;
            }, _ChartUtils.dataConverter.isMinusCandleForPriceData = function(stPrice, isAverage) {
                return void 0 === stPrice || null == stPrice || (!0 === isAverage ? !0 !== stPrice.hasOwnProperty("avgOpen") || !0 !== stPrice.hasOwnProperty("avgClose") || !(parseInt(stPrice.avgOpen) <= parseInt(stPrice.avgClose)) : !0 !== stPrice.hasOwnProperty("open") || !0 !== stPrice.hasOwnProperty("close") || !(parseInt(stPrice.open) <= parseInt(stPrice.close)));
            }, _ChartUtils.math = {}, _ChartUtils.math.didCalcBasselCorrection = function(argValue, argPeriod) {
                return argValue;
            }, _ChartUtils.math.didCalcDiv = function(dDiv, dDive) {
                var isValid = !0, dData = _ChartUtils.constants.default.DEFAULT_WRONG_VALUE;
                return 0 === dDiv ? 0 === dDive ? (dData = 0, isValid = !0) : (dData = _ChartUtils.constants.default.DEFAULT_WRONG_VALUE, 
                isValid = !1) : (isValid = !0, dData = dDive / dDiv), {
                    valid: isValid,
                    value: dData
                };
            }, _ChartUtils.math.constants = {
                methods: {
                    simple: 0,
                    exponential: 1,
                    weight: 2,
                    wilder: 3
                }
            }, _ChartUtils.math.log10 = function(argData) {
                return Math.log10 ? Math.log10(argData) : Math.round(Math.log(argData) / Math.LN10 * 1e6) / 1e6;
            }, _ChartUtils.math.didCalcSum = function(argData) {
                var dSumRet = 0;
                if (void 0 === argData || null == argData) return dSumRet;
                var nCount = arrData.length;
                if (nCount < 1) return dSumRet;
                for (var ii = 0; ii < nCount; ii++) dSumRet += arrData[ii];
                return dSumRet;
            }, _ChartUtils.math.CalcSumWithRange = function(argData, argRange) {
                var dSumRet = 0;
                if (void 0 === argData || null == argData || void 0 === argRange || null == argRange || void 0 === argRange.length || null == argRange.length || argRange.length < 1) return dSumRet;
                var nCount = arrData.length;
                if (nCount < 1) return dSumRet;
                var nStart = 0, nLoopEnd = 0;
                void 0 !== argRange.location && null != argRange.location && (nStart = argRange.location), 
                nLoopEnd = nStart + argRange.length, nStart < 0 && (nLoopEnd += nStart, nStart = 0), 
                nLoopEnd = Math.min(nCount, nLoopEnd);
                for (var ii = nStart; ii < nLoopEnd; ii++) dSumRet += arrData[ii];
                return dSumRet;
            }, _ChartUtils.math.CalcSum = function(argData, dSum, bFirst) {
                var dSumRet = 0, ii = 0;
                if (bFirst) {
                    var nCnt = argData.length, dRes = 0;
                    for (ii = 0; ii < nCnt; ii++) 0 == ii && (dRes = argData[ii]), dSum += argData[ii];
                    dSumRet = dSum, dSum -= dRes;
                } else {
                    var dPre = argData;
                    dSumRet = dSum, dSum -= dPre;
                }
                return {
                    ret: dSumRet,
                    sum: dSum
                };
            }, _ChartUtils.math.CalcMA = function(argData, nPeriod, argMethod) {
                if (nPeriod <= 0) return 0;
                var dMA, ii = 0, dSum = 0, nCnt = argData.length, nMethod = argMethod;
                if ("string" == typeof argMethod && (nMethod = !0 === _ChartUtils.math.constants.methods.hasOwnProperty(argMethod) ? _ChartUtils.math.constants.methods[argMethod] : _ChartUtils.math.constants.methods.simple), 
                nMethod === _ChartUtils.math.constants.methods.exponential) {
                    var dMAP = argData[0], dVal = argData[1], dFac = 2 / (nPeriod + 1);
                    dMA = dVal * dFac + dMAP * (1 - dFac);
                } else if (nMethod === _ChartUtils.math.constants.methods.weight) {
                    nCnt = argData.length;
                    var nSPrd = 0;
                    for (ii = 0; ii < nCnt; ii++) dSum += argData[ii] * (ii + 1), nSPrd += ii + 1;
                    dMA = dSum / nSPrd;
                } else if (nMethod === _ChartUtils.math.constants.methods.wilder) {
                    var dMAP = argData[0], dVal = argData[1];
                    dMA = (dVal + (nPeriod - 1) * dMAP) / nPeriod;
                } else {
                    for (nCnt = argData.length, ii = 0; ii < nCnt; ii++) dSum += argData[ii];
                    dMA = dSum / nPeriod;
                }
                return dMA;
            }, _ChartUtils.math.didCalcSumLikeGMO = function(argNewData, argPreSum, argPeriod) {
                var dAvg = 0;
                if (!(void 0 === argPeriod || null == argPeriod || argPeriod <= 0)) {
                    dAvg = argPreSum / argPeriod;
                    return argPreSum - dAvg + argNewData;
                }
            }, _ChartUtils.math.didCalcTrueRange = function(dHigh, dLow, dCloseP) {
                var dTemp1 = Math.abs(dCloseP - dLow), dTemp2 = Math.abs(dHigh - dLow), dTemp3 = Math.abs(dHigh - dCloseP);
                return Math.max(dTemp1, dTemp2, dTemp3);
            }, _ChartUtils.math.didCalcAvgLikeGMO = function(argNewData, argPreAvg, argPeriod) {
                if (!(void 0 === argPeriod || null == argPeriod || argPeriod <= 0)) {
                    return ((argPeriod - 1) * argPreAvg + argNewData) / argPeriod;
                }
            }, _ChartUtils.math.CalcMAEx = function(argData, dSum, nPeriod, argMethod, bFirst, bFast) {
                var dMA = 0, ii = 0, nMethod = argMethod;
                if ("string" == typeof argMethod && (nMethod = !0 === _ChartUtils.math.constants.methods.hasOwnProperty(argMethod) ? _ChartUtils.math.constants.methods[argMethod] : _ChartUtils.math.constants.methods.simple), 
                bFast && nMethod === _ChartUtils.math.constants.methods.simple) {
                    if (bFirst) {
                        var nCnt = argData.length, dRes = 0;
                        for (ii = 0; ii < nCnt; ii++) 0 == ii && (dRes = argData[ii]), dSum += argData[ii];
                        dMA = dSum / nPeriod, dSum -= dRes;
                    } else {
                        var dPre = argData;
                        dMA = dSum / nPeriod, dSum -= dPre;
                    }
                    return {
                        ma: dMA,
                        sum: dSum
                    };
                }
                return dMA = _ChartUtils.math.CalcMA(argData, nPeriod, nType), {
                    ma: dMA,
                    sum: 0
                };
            }, _ChartUtils.math.didCalcMovingAverageWithSingleDatas = function(datas) {
                var result = _ChartUtils.constants.default.DEFAULT_WRONG_VALUE;
                if (void 0 === datas || null == datas) return result;
                var dataLength = datas.length;
                if (void 0 == dataLength || dataLength < 1) return result;
                for (var sum = 0, ii = 0; ii < dataLength; ii++) {
                    sum += datas[ii];
                }
                return result = sum / dataLength;
            }, _ChartUtils.math.didCalcStandardDeviationWithSingleDatas = function(datas) {
                var result = _ChartUtils.constants.default.DEFAULT_WRONG_VALUE;
                if (void 0 === datas || null == datas) return result;
                var dataLength = datas.length;
                if (void 0 == dataLength || dataLength < 1) return result;
                for (var sum = 0, sum2 = 0, ii = 0; ii < dataLength; ii++) {
                    var data = datas[ii];
                    sum += data, sum2 += data * data;
                }
                var dVar = (sum2 - sum * sum / dataLength) / dataLength;
                return dVar < 0 && (dVar = 0), Math.sqrt(dVar);
            }, _ChartUtils.math.didCalcMovingAverage2 = function(datas, target) {
                var singleDatas = (_ChartUtils.constants.default.DEFAULT_WRONG_VALUE, _ChartUtils.didGetSingleDatasFromPriceDatas(datas, target));
                return _ChartUtils.math.didCalcMovingAverageWithSingleDatas(singleDatas);
            }, _ChartUtils.math.didCalcStandardDeviation2 = function(datas, target) {
                var singleDatas = (_ChartUtils.constants.default.DEFAULT_WRONG_VALUE, _ChartUtils.didGetSingleDatasFromPriceDatas(datas, target));
                return _ChartUtils.math.didCalcStandardDeviationWithSingleDatas(singleDatas);
            }, _ChartUtils.math.didCalcMovingAverage = function(datas, target) {
                var result = _ChartUtils.constants.default.DEFAULT_WRONG_VALUE;
                if (void 0 === datas || null == datas) return result;
                var dataLength = datas.length;
                if (void 0 == dataLength || dataLength < 1) return result;
                for (var sum = 0, ii = 0; ii < dataLength; ii++) {
                    sum += datas[ii][target];
                }
                return result = sum / dataLength;
            }, _ChartUtils.math.didCalcStandardDeviation = function(datas, target) {
                var result = _ChartUtils.constants.default.DEFAULT_WRONG_VALUE;
                if (void 0 === datas || null == datas) return result;
                var dataLength = datas.length;
                if (void 0 == dataLength || dataLength < 1) return result;
                for (var sum = 0, sum2 = 0, ii = 0; ii < dataLength; ii++) {
                    var data = datas[ii][target];
                    sum += data, sum2 += data * data;
                }
                var dVar = (sum2 - sum * sum / dataLength) / dataLength;
                return dVar < 0 && (dVar = 0), Math.sqrt(dVar);
            }, _ChartUtils.math.didCalcHighestValue = function(argDatas) {
                if (!(void 0 === argDatas || null == argDatas || void 0 === argDatas.length || null == argDatas.length || argDatas.length < 1)) {
                    for (var nCount = argDatas.length, dData = argDatas[0], ii = 1; ii < nCount; ii++) dData = Math.max(dData, argDatas[ii]);
                    return dData;
                }
            }, _ChartUtils.math.didCalcLowestValue = function(argDatas) {
                if (!(void 0 === argDatas || null == argDatas || void 0 === argDatas.length || null == argDatas.length || argDatas.length < 1)) {
                    for (var nCount = argDatas.length, dData = argDatas[0], ii = 1; ii < nCount; ii++) dData = Math.min(dData, argDatas[ii]);
                    return dData;
                }
            }, _ChartUtils.trendLine = {}, _ChartUtils.trendLine.didDeleteTargetToolObject = function(argDoLs) {
                return void 0 !== argDoLs && null != argDoLs && void 0 !== argDoLs.m_doParent && null != argDoLs.m_doParent && void 0 !== argDoLs.m_doParent.didRemoveTargetLineTool && argDoLs.m_doParent.didRemoveTargetLineTool(argDoLs);
            }, _ChartUtils.trendLine.isNewOrderLine = function(argLineCode) {
                return void 0 !== argLineCode && null != argLineCode && argLineCode === _ChartUtils.constants.trendLineCodes.orderLine;
            }, _ChartUtils.trendLine.isDrawableTrendline = function(argLineCode) {
                return void 0 !== argLineCode && null != argLineCode && argLineCode !== _ChartUtils.constants.trendLineCodes.pointer && argLineCode !== _ChartUtils.constants.trendLineCodes.deleteOne && argLineCode !== _ChartUtils.constants.trendLineCodes.deleteAll;
            }, _ChartUtils.trendLine.isObjectMovableMode = function(argLineCode) {
                return argLineCode === _ChartUtils.constants.trendLineCodes.pointer;
            }, _ChartUtils.trendLine.isCrossHairMode = function(argLineCode) {
                return argLineCode === _ChartUtils.constants.trendLineCodes.crossHair;
            }, _ChartUtils.trendLine.isScrollableMode = function(argLineCode) {
                return argLineCode === _ChartUtils.constants.trendLineCodes.pointer || argLineCode === _ChartUtils.constants.trendLineCodes.crossHair;
            }, _ChartUtils.trendLine.isDeleteOneRepeat = function(argLineCode) {
                return argLineCode === _ChartUtils.constants.trendLineCodes.deleteOneRepeat;
            }, _ChartUtils.trendLine.didGetDefaultTrendlineInfoAt = function(argLineCode, isRef) {
                if (void 0 !== argLineCode && null != argLineCode) {
                    var objects, count, trendLineInfo;
                    objects = _ChartUtils.constants.trendLines, count = objects.length;
                    try {
                        for (var ii = 0; ii < count; ii++) if ((trendLineInfo = objects[ii]) && trendLineInfo.code && trendLineInfo.code === argLineCode) return !0 === isRef ? trendLineInfo : _ChartUtils.didClone(trendLineInfo);
                    } catch (e) {
                        console.error(e), trendLineInfo = void 0;
                    }
                    return trendLineInfo;
                }
            }, _ChartUtils.trendLine.didGetDefaultTrendlineInfos = function() {
                var objects, count, xResult = {};
                objects = _ChartUtils.constants.trendLines, count = objects.length;
                for (var ii = 0; ii < count; ii++) {
                    var trendLineInfo = objects[ii];
                    if ((void 0 !== trendLineInfo || null != trendLineInfo) && !0 !== trendLineInfo.tool) {
                        xResult[trendLineInfo.code] = _ChartUtils.didClone(trendLineInfo);
                    }
                }
                return xResult;
            }, _ChartUtils.didGetShifLeftCount = function(argMoveShift) {
                return argMoveShift < 0 ? Math.abs(argMoveShift) : 0;
            }, _ChartUtils.didGetShifRightCount = function(argMoveShift) {
                return argMoveShift > 0 ? Math.abs(argMoveShift) : 0;
            }, _ChartUtils.didCalculateShiftInfo = function(argInfo, isSt) {
                if (void 0 !== argInfo && null != argInfo) {
                    if (void 0 !== argInfo.extraDiff && null != argInfo.extraDiff) {
                        var isParamOrLeft = !1;
                        !0 === isSt && (isParamOrLeft = !0);
                        var nShift = _ChartUtils.didCalculateShiftValue(argInfo.extraDiff, isParamOrLeft);
                        return nShift;
                    }
                    if (void 0 !== argInfo.left && null != argInfo.left && void 0 !== argInfo.right && null != argInfo.right) {
                        var extraDiff = argInfo.right, isParamOrLeft = !1;
                        !0 === isSt && (extraDiff = argInfo.left, isParamOrLeft = !0);
                        var nShift = _ChartUtils.didCalculateShiftValue(extraDiff, isParamOrLeft);
                        return nShift;
                    }
                }
                return 0;
            }, _ChartUtils.didCalculateShiftValueWithExtraDiff = function(argValue, isSt) {
                var isParamOrLeft = !1;
                return !0 === isSt && (isParamOrLeft = !0), _ChartUtils.didCalculateShiftValue(argValue, isParamOrLeft);
            }, _ChartUtils.didCalculateShiftValue = function(argValue, isParamOrLeft) {
                var nShift = 0;
                return nShift = "string" == typeof argValue ? parseInt(argValue) : "number" == typeof argValue ? argValue : 0, 
                !0 === isParamOrLeft && (nShift *= -1), nShift;
            }, _ChartUtils.didConvertShiftedIndex = function(argIndex, argShift, toDataIndex) {
                return !0 === toDataIndex ? argIndex + argShift : argIndex - argShift;
            }, _ChartUtils.EC_GetDataZScr = function(nSorDIdx, nMOff, nDiff, bD2S) {
                return !0 === bD2S ? nSorDIdx - (nMOff - nDiff) : nSorDIdx + (nMOff - nDiff);
            }, _ChartUtils.didCheckNavigator = function() {
                var agent = navigator.userAgent.toLowerCase();
                return -1 != agent.indexOf("chrome") ? "Chrome" : -1 != agent.indexOf("opera") ? "Opera" : -1 != agent.indexOf("firefox") ? "Firefox" : -1 != agent.indexOf("safari") ? "Safari" : -1 != agent.indexOf("msie") ? "IE" : void 0;
            }, _ChartUtils.isNontimeChartType = function(strChartType) {
                return strChartType === _ChartUtils.constants.chartTypeCode.threeLineBreak || strChartType === _ChartUtils.constants.chartTypeCode.pointAndFigure || strChartType === _ChartUtils.constants.chartTypeCode.reverseCycleLine || strChartType === _ChartUtils.constants.chartTypeCode.kagi || strChartType === _ChartUtils.constants.chartTypeCode.renko;
            }, _ChartUtils.didGetXAxisHeight = function(xEnv) {
                return xEnv && !0 === xEnv.System.UseForMiniChart ? 0 : _ChartUtils.constants.default.XAXIS_HEIGHT;
            }, _ChartUtils.didGetExtraPanelVisibility = function(xEnv) {
                return xEnv && !0 === xEnv.System.UseForMiniChart ? "hidden" : "visible";
            }, _ChartUtils.didGetAxisPanelVisibility = function(xEnv) {
                return xEnv && !0 === xEnv.System.UseForMiniChart ? "hidden" : "visible";
            }, _ChartUtils.isComparePriceBar = function(xEnv) {
                return !!xEnv && "compare" === xEnv.System.DefaultPriceBar;
            }, _ChartUtils.isCFDPriceBar = function(xEnv) {
                return !!xEnv && "cfd" === xEnv.System.DefaultPriceBar;
            }, _ChartUtils.isAvailableSmoothScroll = function(xEnv) {
                return !!xEnv && (!0 === xEnv.System.AllowSmoothScroll && xEnv.UseSmoothScroll);
            }, _ChartUtils.isAvailableToSelectObject = function(xEnv) {
                return !!xEnv && (1 != xEnv.System.UseForMiniChart && 1 == xEnv.AvailableToSelectObject);
            }, _ChartUtils.isAvailableToScrollScreen = function(xEnv) {
                return !!xEnv && (1 != xEnv.System.UseForMiniChart && 1 == xEnv.AvailableToScrollScreen);
            }, _ChartUtils.didStateChangeOnTrendline = function(xEnv, trendLine) {
                if (!xEnv) return !1;
                var bUpdate = !1;
                1 == _ChartUtils.trendLine.isObjectMovableMode(trendLine) ? xEnv.AvailableToSelectObject = !0 : xEnv.AvailableToSelectObject = !1, 
                1 == _ChartUtils.trendLine.isScrollableMode(trendLine) ? xEnv.AvailableToScrollScreen = !0 : xEnv.AvailableToScrollScreen = !1;
                try {
                    1 == _ChartUtils.trendLine.isCrossHairMode(trendLine) ? xEnv.CrossLine.hide = !1 : xEnv.CrossLine.hide = !0, 
                    bUpdate = !0;
                } catch (e) {
                    console.error(e);
                }
                return bUpdate;
            }, _ChartUtils.isAvailableMouseScrollActionOnCFD = function(xEnv, trendLine) {
                return !!xEnv && _ChartUtils.isAvailableToScrollScreen(xEnv);
            }, _ChartUtils.isAvailableChartTypeForCallingPreviousNext = function(xEnv) {
                if (!xEnv) return !1;
                if (!0 !== xEnv.System.UseRequestPreviousNext) return !1;
                var strChartType = xEnv.ChartType;
                return !0 !== _ChartUtils.isNontimeChartType(strChartType) && (!0 !== _ChartUtils.isComparePriceBar(xEnv) || _ChartUtils.constants.chartTypeCode.compareChart !== strChartType);
            }, _ChartUtils.isAvailableToUseChartType = function(xEnv, strChartType) {
                return !!xEnv && (void 0 !== strChartType && null != strChartType && (!(_ChartUtils.getChartTypeNumCodeFromCode(strChartType) <= _ChartUtils.constants.ngc.enum.ELS_INVALID) && (strChartType !== xEnv.ChartType && (!0 === _ChartUtils.isComparePriceBar(xEnv) || strChartType !== _ChartUtils.constants.chartTypeCode.compareChart))));
            }, _ChartUtils.isCompareChartMode = function(xEnv) {
                return !!xEnv && (!0 === _ChartUtils.isComparePriceBar(xEnv) && _ChartUtils.constants.chartTypeCode.compareChart === xEnv.ChartType);
            }, _ChartUtils.getChartTypeNumCodeFromCode = function(strChartType) {
                for (var nCount = _ChartUtils.constants.chartType.length, ii = 0; ii < nCount; ii++) {
                    var xChartType = _ChartUtils.constants.chartType[ii];
                    if (void 0 !== xChartType && null != xChartType && xChartType.code === strChartType) return xChartType.numCode;
                }
                return _ChartUtils.constants.ngc.enum.ELS_INVALID;
            }, _ChartUtils.didAppendDatas = function(target, source) {
                if ("object" == typeof target) {
                    Array.prototype.push.apply(target, source);
                }
            }, _ChartUtils.didAppendEmptyDatas = function(targetDatas, targetTimes, targetTickNos, source) {
                if (source && source.length && !(source.length < 1) && "object" == typeof targetDatas && "object" == typeof targetTimes && "object" == typeof targetTickNos) for (var nCount = source.length, ii = 0; ii < nCount; ii++) {
                    var __stPrice = source[ii];
                    targetDatas.push(_ChartUtils.didClone(__stPrice));
                    var __strTimeVal = _ChartUtils.dateTime.convertNumberDatetimeToTimelineData(__stPrice.ymd, __stPrice.hms);
                    targetTimes.push(__strTimeVal), targetTickNos.push(0);
                }
            }, _ChartUtils.createGuid = function() {
                var s4 = function() {
                    return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
                };
                return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
            }, _ChartUtils.didClone = function(arg) {
                if (void 0 !== $ && void 0 !== jQuery) return $.extend(!0, {}, arg);
            }, _ChartUtils.didStopPropagation = function(event) {
                event && (event.stopPropagation ? event.stopPropagation() : event.cancelBubble = !0);
            }, _ChartUtils.didAdjustCanvasResolution = function(canvas, width, height, apply) {
                var context = canvas ? canvas.getContext("2d") : null, devicePixelRatio = window.devicePixelRatio || 1, backingStoreRatio = 1;
                context && (backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1);
                var ratio = devicePixelRatio / backingStoreRatio;
                if (!0 === apply) {
                    var width = canvas.width, height = canvas.height;
                    canvas.width = ratio * width, canvas.height = ratio * height;
                }
                return ratio;
            }, _ChartUtils.didCalcRatioOfContext2D = function(context) {
                var devicePixelRatio = window.devicePixelRatio || 1, backingStoreRatio = 1;
                return context && (backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1), 
                devicePixelRatio / backingStoreRatio;
            }, _ChartUtils.didConvertTimeTypeKeyToNumber = function(strType) {
                try {
                    if (!0 === _ChartUtils.constants.timeType.hasOwnProperty(strType)) return _ChartUtils.constants.timeType[strType];
                } catch (e) {}
            }, _ChartUtils.MCR_ISZERO = function(arg) {
                return 0 === arg;
            }, _ChartUtils.didGetCrossPoint = function(ptHS, ptHF, ptLS, ptLF) {
                var dA = 0, dB = 0, dC = 0, dD = 0;
                dA = (ptHF.y - ptHS.y) / (ptHF.x - ptHS.x), dB = ptHF.y - dA * ptHF.x, dC = (ptLF.y - ptLS.y) / (ptLF.x - ptLS.x), 
                dD = ptLF.y - dC * ptLF.x;
                var ptRet = {};
                return ptRet.x = parseInt((dD - dB) / (dA - dC)), ptRet.y = parseInt(dA * ptRet.x + dB), 
                ptRet;
            }, _ChartUtils.didCalcCenterPos = function(arg1, arg2) {
                return Math.round((arg2 - arg1) / 2);
            }, _ChartUtils.didGetDataFromPriceData = function(stPrice, target) {
                if (void 0 !== stPrice && null != stPrice) return stPrice[target];
            }, _ChartUtils.didGetSingleDatasFromPriceDatas = function(datas, target) {
                if (void 0 !== datas && null != datas) {
                    var dataLength = datas.length;
                    if (!(void 0 == dataLength || dataLength < 1)) {
                        for (var singleDatas = [], ii = 0; ii < dataLength; ii++) singleDatas.push(datas[ii][target]);
                        return singleDatas;
                    }
                }
            }, _ChartUtils.didConvertToPrice = function(argPrice) {
                return _ChartUtils.didRoundPrice(argPrice, !0);
            }, _ChartUtils.didConvertToVolume = function(argVolume) {
                return parseInt(argVolume);
            }, _ChartUtils.didCalcPriceSize = function(argMax, argMin, isOpt) {
                return !0 !== isOpt ? argMax + 1 - argMin : argMax - argMin;
            }, _ChartUtils.didRoundPrice = function(argPrice, isFloor) {
                return !0 === isFloor ? parseInt(argPrice) : Math.round(argPrice);
            }, _ChartUtils.isValidValue = function(argValue) {
                return void 0 !== argValue && argValue !== _ChartUtils.constants.default.DEFAULT_WRONG_VALUE;
            }, _ChartUtils.didGetPriceValue = function(stPrice, target, dFactor) {
                var dResult = 0;
                if (void 0 === stPrice || null == stPrice) return dResult;
                var checkStr = target.toLowerCase();
                if (!0 !== _ChartUtils.constants.keywords.price.hasOwnProperty(checkStr)) return dResult;
                if ((checkStr = _ChartUtils.constants.keywords.price[checkStr]) === _ChartUtils.constants.keywords.price.typical) dResult = (stPrice.high + stPrice.low + stPrice.close) / 3; else if (checkStr === _ChartUtils.constants.keywords.price.weight) dResult = (stPrice.open + stPrice.high + stPrice.low + stPrice.close) / 3; else {
                    if (!0 !== stPrice.hasOwnProperty(checkStr)) return dResult;
                    checkStr !== _ChartUtils.constants.keywords.price.volume && checkStr !== _ChartUtils.constants.keywords.price.amount || (dFactor = void 0), 
                    dResult = stPrice[checkStr];
                }
                return void 0 !== dFactor && (dResult *= dFactor), dResult;
            }, _ChartUtils.didGetPriceDisplay = function(target, stPrice, verpos, noPrefix) {
                var prefix = _ChartUtils.constants.text.dataView[target], strDisp = _ChartUtils.number.didGetPointedValue(stPrice[target], verpos);
                return !0 === noPrefix ? String(strDisp) : String(prefix + strDisp);
            }, _ChartUtils.didGetDataViewItemTitle = function(target) {
                return !0 === _ChartUtils.constants.text.dataView.hasOwnProperty(target) ? _ChartUtils.constants.text.dataView[target] : "";
            }, _ChartUtils.indicator = {}, _ChartUtils.indicator.plotState = {
                stateUp: 1,
                stateDn: -1,
                stateNone: 0
            }, _ChartUtils.indicator.plotType = {
                ESDG_PLOTLINE: 0,
                ESDG_SIMPLEBAR: 1,
                ESDG_CANDLEBAR: 2,
                ESDG_NEWS: 3,
                ESDG_ORDER: 4,
                ESDG_KAGI: 5,
                ESDG_RENKO: 6,
                ESDG_PNF: 7,
                ESDG_TLB: 8,
                ESDG_REVC: 9,
                ESDG_SIDEBAR: 10,
                ESDG_PLOTBASELINE: 11,
                ESDG_ORDERUNIT: 12,
                ESDG_POSITIONUNIT: 13,
                ESDG_COUNT: 14
            }, _ChartUtils.indicator.plotStyle = {
                ESSS_PL_LINE: 0,
                ESSS_PL_STICK: 1,
                ESSS_PL_POINT: 2,
                ESSS_SB_STICK: 3,
                ESSS_SB_BAR: 4,
                ESSS_SB_FILL: 5,
                ESSS_AV_BAR: 6,
                ESSS_AV_FILLBAR: 7,
                ESSS_AV_LINE: 8,
                ESSS_PL_KAGI: 100,
                ESSS_PL_RENKO: 101,
                ESSS_PL_PNF: 102,
                ESSS_PL_TLB: 103
            }, _ChartUtils.indicator.constValue = {
                ESCV_SYM_MONEY: 1,
                ESCV_SYM_PERCENT: 2
            }, _ChartUtils.indicator.didConvertMethodKeyword = function(argKey) {
                if (void 0 !== argKey && null != argKey) return _ChartUtils.constants.keywords.indicator.hasOwnProperty(argKey) ? _ChartUtils.constants.keywords.indicator[argKey] : void 0;
            }, _ChartUtils.indicator.didGetParamValueForDisplay = function(argParam) {
                if (void 0 === argParam || null == argParam) return "";
                var value = argParam.value;
                if (void 0 !== argParam.list && null != argParam.list) {
                    for (var nCount = argParam.list.length, ii = 0; ii < nCount; ii++) {
                        var xItem = argParam.list[ii];
                        if (xItem.value === value) return xItem.display;
                    }
                    return value;
                }
                return value;
            }, _ChartUtils.indicator.didGetDefaultInfo = function(argCode) {
                if (void 0 !== argCode && null != argCode && "" !== argCode) for (var ii in _ChartUtils.constants.indicators) {
                    var xInfo = _ChartUtils.constants.indicators[ii];
                    if (void 0 !== xInfo && null != xInfo && xInfo.code === argCode) return _ChartUtils.didClone(xInfo);
                }
            }, _ChartUtils.indicator.didGetDefaultSeriesInfos = function() {
                var indicators, count, target, xResult = {
                    trend: [],
                    oscillator: []
                };
                indicators = _ChartUtils.constants.indicatorGroups.trend.indicators, count = indicators.length, 
                target = xResult.trend;
                for (var ii = 0; ii < count; ii++) {
                    var code = indicators[ii], item = {
                        code: code,
                        show: !1,
                        info: _ChartUtils.indicator.didGetDefaultInfo(code)
                    };
                    target.push(item);
                }
                indicators = _ChartUtils.constants.indicatorGroups.oscillator.indicators, count = indicators.length, 
                target = xResult.oscillator;
                for (var ii = 0; ii < count; ii++) {
                    var code = indicators[ii], item = {
                        code: code,
                        show: !1,
                        info: _ChartUtils.indicator.didGetDefaultInfo(code)
                    };
                    target.push(item);
                }
                return xResult;
            }, _ChartUtils.indicator.didGetDefaultPlotColorInfos = function() {
                var indicators, count, target, xResult = {
                    trend: [],
                    oscillator: []
                };
                indicators = _ChartUtils.constants.indicatorGroups.trend.indicators, count = indicators.length, 
                target = xResult.trend;
                for (var ii = 0; ii < count; ii++) {
                    var code = indicators[ii], xInfo = _ChartUtils.indicator.didGetDefaultInfo(code);
                    if (xInfo) {
                        var item = {
                            code: code,
                            display: xInfo.display,
                            info: _ChartUtils.indicator.didGetDefaultPlotColorInfo(xInfo)
                        };
                        target.push(item);
                    }
                }
                indicators = _ChartUtils.constants.indicatorGroups.oscillator.indicators, count = indicators.length, 
                target = xResult.oscillator;
                for (var ii = 0; ii < count; ii++) {
                    var code = indicators[ii], xInfo = _ChartUtils.indicator.didGetDefaultInfo(code);
                    if (xInfo) {
                        var item = {
                            code: code,
                            display: xInfo.display,
                            info: _ChartUtils.indicator.didGetDefaultPlotColorInfo(xInfo)
                        };
                        target.push(item);
                    }
                }
                return xResult;
            }, _ChartUtils.indicator.didDecodeSeriesInformation = function(argSeriesInfo, argSaveInfo, useUpdate) {
                if (argSeriesInfo && argSaveInfo) {
                    var count, xSiNew = {
                        code: argSeriesInfo.code,
                        show: argSeriesInfo.show,
                        info: !0 === useUpdate ? argSeriesInfo.info : _ChartUtils.didClone(argSeriesInfo.info)
                    }, seriesInfo = xSiNew.info, xInfo = argSaveInfo.i;
                    if (xInfo && seriesInfo) {
                        var xDstParams = seriesInfo.params;
                        if (xInfo.pa && (count = xInfo.pa.length) > 0) for (var ii = 0; ii < count; ii++) {
                            var xSrcParam = xInfo.pa[ii];
                            try {
                                var index = xSrcParam[0], value = xSrcParam[1], xDstParam = xDstParams[index];
                                xDstParam.value = value;
                            } catch (e) {
                                console.error(e);
                            }
                        }
                        var xDstPlots = seriesInfo.plots;
                        if (xInfo.ps && (count = xInfo.ps.length) > 0) for (var ii = 0; ii < count; ii++) {
                            var xSrcPlot = xInfo.ps[ii];
                            try {
                                var index = xSrcPlot[0], hide = xSrcPlot[1], xDstPlot = xDstPlots[index];
                                xDstPlot.hide = !!hide;
                            } catch (e) {
                                console.error(e);
                            }
                        }
                        var xDstLines = seriesInfo.lines;
                        if (xInfo.l && (count = xInfo.l.length) > 0) for (var ii = 0; ii < count; ii++) {
                            var xSrcLine = xInfo.l[ii];
                            try {
                                var index = xSrcLine[0], hide = xSrcLine[1], xDstLine = xDstLines[index];
                                xDstLine.hide = !!hide;
                            } catch (e) {
                                console.error(e);
                            }
                        }
                    }
                    return seriesInfo;
                }
            }, _ChartUtils.indicator.didFindSeriesInfoWithTypeId = function(typeId, seriesInfos, isTrend) {
                if (void 0 !== typeId && null != typeId && "" !== typeId && void 0 !== seriesInfos && null != seriesInfos) try {
                    var indicators;
                    indicators = !0 === isTrend ? seriesInfos.trend : seriesInfos.oscillator;
                    for (var nCount = indicators.length, ii = 0; ii < nCount; ii++) {
                        var xSi = indicators[ii];
                        if (xSi.code === typeId) return xSi;
                    }
                    return;
                } catch (e) {}
            }, _ChartUtils.indicator.didConvertToShortSeriesInformation = function(argSrc, isSave, usePlotColor, dontUseLine) {
                if (argSrc) {
                    var count, xResult = {};
                    if (!0 === isSave) {
                        var xSave = {};
                        if (argSrc.params && (count = argSrc.params.length) > 0) {
                            xSave.pa = [];
                            for (var ii = 0; ii < count; ii++) {
                                var xSrcParam = argSrc.params[ii];
                                xSave.pa.push([ ii, xSrcParam.value ]);
                            }
                        }
                        if (argSrc.plots && (count = argSrc.plots.length) > 0) {
                            xSave.ps = [];
                            for (var ii = 0; ii < count; ii++) {
                                var xSrcPlot = argSrc.plots[ii];
                                !0 !== xSrcPlot.ignore && (!0 === xSrcPlot.hide ? xSave.ps.push([ ii, 1 ]) : xSave.ps.push([ ii, 0 ]));
                            }
                        }
                        if (!0 !== dontUseLine && argSrc.lines && (count = argSrc.lines.length) > 0) {
                            xSave.l = [];
                            for (var ii = 0; ii < count; ii++) {
                                var xSrcLine = argSrc.lines[ii];
                                !0 === xSrcLine.hide ? xSave.l.push([ ii, 1 ]) : xSave.l.push([ ii, 0 ]);
                            }
                        }
                        return xSave;
                    }
                    if (xResult.code = argSrc.code, !0 !== isSave && (xResult.display = argSrc.display, 
                    xResult.displya_s = argSrc.displya_s, !0 === argSrc.priceType && (xResult.priceType = !0)), 
                    argSrc.params) {
                        !0 === isSave ? xResult.pa = [] : xResult.params = [], count = argSrc.params.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSrcParam = argSrc.params[ii], xNewParam = {};
                            !0 === isSave ? (xNewParam.n = xSrcParam.name, xNewParam.v = xSrcParam.value, xResult.pa.push(xNewParam)) : (xNewParam.name = xSrcParam.name, 
                            xNewParam.value = xSrcParam.value, xNewParam.alias = xSrcParam.alias, xNewParam.default = xSrcParam.default, 
                            xSrcParam.range ? xNewParam.range = _ChartUtils.didClone(xSrcParam.range) : xSrcParam.list && (xNewParam.list = _ChartUtils.didClone(xSrcParam.list)), 
                            xSrcParam.linked && (xNewParam.linked = xSrcParam.linked), xResult.params.push(xNewParam));
                        }
                    }
                    if (argSrc.plots) {
                        !0 === isSave ? xResult.ps = [] : xResult.plots = [], count = argSrc.plots.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSrcPlot = argSrc.plots[ii];
                            if (!0 !== xSrcPlot.ignore && !0 === xSrcPlot.showHideOption) {
                                var xNewPlot = {};
                                !0 === isSave ? (xNewPlot.n = xSrcPlot.name, !0 === xSrcPlot.hide && (xNewPlot.h = !0), 
                                xResult.ps.push(xNewPlot)) : (xNewPlot.name = xSrcPlot.name, !0 === xSrcPlot.hide && (xNewPlot.hide = !0), 
                                xNewPlot.alias = xSrcPlot.alias, !0 === usePlotColor && (xNewPlot.color = xSrcPlot.color), 
                                xSrcPlot.paramLink && (xNewPlot.paramLink = xSrcPlot.paramLink), xResult.plots.push(xNewPlot));
                            }
                        }
                    }
                    if (!0 !== dontUseLine && argSrc.lines) {
                        !0 === isSave ? xResult.l = [] : xResult.lines = [], count = argSrc.lines.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSrcLine = argSrc.lines[ii];
                            if (!0 === xSrcLine.showHideOption) {
                                var xNewLine = {};
                                !0 === isSave ? (xNewLine.n = xSrcLine.name, !0 === xSrcLine.hide && (xNewLine.h = !0), 
                                xResult.l.push(xNewLine)) : (xNewLine.name = xSrcLine.name, !0 === xSrcLine.hide && (xNewLine.hide = !0), 
                                xNewLine.alias = xSrcLine.alias, xResult.lines.push(xNewLine));
                            }
                        }
                    }
                    return xResult;
                }
            }, _ChartUtils.indicator.didConvertToRestoreSeriesInformation = function(argSrc, isSave, usePlotColor, dontUseLine) {
                if (argSrc) {
                    var count, xResult = {};
                    if (xResult.code = argSrc.code, !0 !== isSave && (xResult.display = argSrc.display, 
                    xResult.displya_s = argSrc.displya_s, !0 === argSrc.priceType && (xResult.priceType = !0)), 
                    argSrc.params) {
                        !0 === isSave ? xResult.pa = [] : xResult.params = [], count = argSrc.params.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSrcParam = argSrc.params[ii], xNewParam = {};
                            !0 === isSave ? (xNewParam.n = xSrcParam.name, xNewParam.v = xSrcParam.value, xResult.pa.push(xNewParam)) : (xNewParam.name = xSrcParam.name, 
                            xNewParam.value = xSrcParam.value, xNewParam.alias = xSrcParam.alias, xNewParam.default = xSrcParam.default, 
                            xSrcParam.range ? xNewParam.range = _ChartUtils.didClone(xSrcParam.range) : xSrcParam.list && (xNewParam.list = _ChartUtils.didClone(xSrcParam.list)), 
                            xSrcParam.linked && (xNewParam.linked = xSrcParam.linked), xResult.params.push(xNewParam));
                        }
                    }
                    if (argSrc.plots) {
                        !0 === isSave ? xResult.ps = [] : xResult.plots = [], count = argSrc.plots.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSrcPlot = argSrc.plots[ii], xNewPlot = {};
                            !0 === isSave ? (xNewPlot.n = xSrcPlot.name, !0 === xSrcPlot.hide && (xNewPlot.h = !0), 
                            xResult.ps.push(xNewPlot)) : (xNewPlot.name = xSrcPlot.name, !0 === xSrcPlot.hide && (xNewPlot.hide = !0), 
                            xNewPlot.alias = xSrcPlot.alias, !0 === usePlotColor && (xNewPlot.color = xSrcPlot.color), 
                            xSrcPlot.paramLink && (xNewPlot.paramLink = xSrcPlot.paramLink), xResult.plots.push(xNewPlot));
                        }
                    }
                    if (!0 !== dontUseLine && argSrc.lines) {
                        !0 === isSave ? xResult.l = [] : xResult.lines = [], count = argSrc.lines.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSrcLine = argSrc.lines[ii];
                            if (!0 === xSrcLine.showHideOption) {
                                var xNewLine = {};
                                !0 === isSave ? (xNewLine.n = xSrcLine.name, !0 === xSrcLine.hide && (xNewLine.h = !0), 
                                xResult.l.push(xNewLine)) : (xNewLine.name = xSrcLine.name, !0 === xSrcLine.hide && (xNewLine.hide = !0), 
                                xNewLine.alias = xSrcLine.alias, xResult.lines.push(xNewLine));
                            }
                        }
                    }
                    return xResult;
                }
            }, _ChartUtils.indicator.didGetDefaultPlotColorInfo = function(argSrc) {
                if (argSrc) {
                    var count, xResult = {};
                    if (xResult.code = argSrc.code, argSrc.plots) {
                        xResult.plots = [], count = argSrc.plots.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSrcPlot = argSrc.plots[ii];
                            if (!0 !== xSrcPlot.ignore) {
                                var xNewPlot = {};
                                xNewPlot.no = ii, xNewPlot.color = xSrcPlot.color, xResult.plots.push(xNewPlot);
                            }
                        }
                    }
                    return xResult;
                }
            }, _ChartUtils.indicator.didApplySeriesInfos = function(dest, src) {
                if (dest && src) {
                    var destCount, destObjs, srcObjs, srcCount;
                    if (void 0 !== src.extraDiff && null != src.extraDiff && (dest.extraDiff = src.extraDiff), 
                    destObjs = dest.params, srcObjs = src.params, destObjs && destObjs.length && srcObjs && srcObjs.length) {
                        srcCount = srcObjs.length;
                        for (var ii = 0; ii < srcCount; ii++) {
                            var srcItem = srcObjs[ii];
                            destCount = destObjs.length;
                            for (var jj = 0; jj < destCount; jj++) {
                                var destItem = destObjs[jj];
                                if (srcItem.name && srcItem.name === destItem.name) {
                                    void 0 !== srcItem.value && null != srcItem.value && (destItem.value = srcItem.value);
                                    break;
                                }
                            }
                        }
                    }
                    if (destObjs = dest.plots, srcObjs = src.plots, destObjs && destObjs.length && srcObjs && srcObjs.length) {
                        srcCount = srcObjs.length;
                        for (var ii = 0; ii < srcCount; ii++) {
                            var srcItem = srcObjs[ii];
                            destCount = destObjs.length;
                            for (var jj = 0; jj < destCount; jj++) {
                                var destItem = destObjs[jj];
                                if (srcItem.name && srcItem.name === destItem.name) {
                                    void 0 !== srcItem.plotStyle && null != srcItem.plotStyle && (destItem.plotStyle = srcItem.plotStyle), 
                                    void 0 !== srcItem.color && null != srcItem.color && (destItem.color = srcItem.color), 
                                    void 0 !== srcItem.lineStyle && null != srcItem.lineStyle && (destItem.lineStyle = srcItem.lineStyle), 
                                    void 0 !== srcItem.lineWeight && null != srcItem.lineWeight && (destItem.lineWeight = srcItem.lineWeight), 
                                    void 0 !== srcItem.hide && null != srcItem.hide && (destItem.hide = srcItem.hide);
                                    break;
                                }
                            }
                        }
                    }
                    if (destObjs = dest.lines, srcObjs = src.lines, destObjs && destObjs.length && srcObjs && srcObjs.length) {
                        srcCount = srcObjs.length;
                        for (var ii = 0; ii < srcCount; ii++) {
                            var srcItem = srcObjs[ii];
                            destCount = destObjs.length;
                            for (var jj = 0; jj < destCount; jj++) {
                                var destItem = destObjs[jj];
                                if (srcItem.name && srcItem.name === destItem.name) {
                                    void 0 !== srcItem.value && null != srcItem.value && (destItem.value = srcItem.value), 
                                    void 0 !== srcItem.lineColor && null != srcItem.lineColor && (destItem.lineColor = srcItem.lineColor), 
                                    void 0 !== srcItem.lineStyle && null != srcItem.lineStyle && (destItem.lineStyle = srcItem.lineStyle), 
                                    void 0 !== srcItem.lineWeight && null != srcItem.lineWeight && (destItem.lineWeight = srcItem.lineWeight), 
                                    void 0 !== srcItem.hide && null != srcItem.hide && (destItem.hide = srcItem.hide);
                                    break;
                                }
                            }
                        }
                    }
                }
            }, _ChartUtils.indicator.didApplySeriesPlotColorInfos = function(dest, plotColorInfos) {
                if (!dest || !plotColorInfos) return !1;
                var destCount, destObjs, srcObjs, srcCount;
                if (destObjs = dest.plots, srcObjs = plotColorInfos, destObjs && destObjs.length && srcObjs && srcObjs.length) {
                    srcCount = srcObjs.length;
                    for (var ii = 0; ii < srcCount; ii++) {
                        var srcItem = srcObjs[ii], color = srcItem.color, colorUp = (srcItem.bar, srcItem.colorUp), colorDn = srcItem.colorDn, targets = srcItem.targets;
                        if (void 0 !== targets && null != targets) {
                            destCount = destObjs.length;
                            for (var jj = 0; jj < destCount; jj++) try {
                                if (targets.indexOf(jj) < 0) continue;
                                var destItem = destObjs[jj];
                                void 0 !== color && null != color && (destItem.color = color), void 0 !== colorUp && null != colorUp && (destItem.colorUp = colorUp), 
                                void 0 !== colorDn && null != colorDn && (destItem.colorDn = colorDn);
                            } catch (e) {}
                        }
                    }
                }
                return !0;
            }, _ChartUtils.validator = {}, _ChartUtils.validator.isValidPrice = function(argxPrice, isAverage) {
                return void 0 !== argxPrice && null !== argxPrice && void 0 !== argxPrice.close && null != argxPrice.close && 0 !== parseInt(argxPrice.close) && !!(!0 !== isAverage || argxPrice.avgClose && argxPrice.avgOpen);
            }, _ChartUtils.validator.isFixedPrice = function(argxPrice, xEnv) {
                try {
                    if (xEnv && !0 === xEnv.System.ShowFixedData) return !1;
                    if (argxPrice && !0 === argxPrice.fixed) return !0;
                } catch (e) {}
                return !1;
            }, _ChartUtils.axis = {}, _ChartUtils.axis.label = {}, _ChartUtils.axis.label.multipleValue = {
                1: "(x) 10",
                2: "(x) 100",
                3: "(x) 1000",
                4: "(x) ",
                5: "(x) ",
                6: "(x) ",
                7: "(x) ",
                8: "(x) ",
                9: "(x) "
            }, _ChartUtils.axis.didCalcBarGapInfoFromLevelInfo = function(barSize, barGap, levelInfo) {
                var result = {
                    barSize: barSize,
                    barGap: barGap
                };
                return levelInfo ? (result.barGap = levelInfo.gap, result.barSize = Math.round((levelInfo.bar - 1) / 2), 
                result) : result;
            }, _ChartUtils.axis.label.didCalcMutipleValue = function(value1, value2) {
                if (_ChartUtils.constants.chartConfigConstants.YLabelLengthLimit && !(_ChartUtils.constants.chartConfigConstants.YLabelLengthLimit < 1) && "number" == typeof value1) {
                    var value, nLen1 = String(value1).length, nLen2 = 0;
                    "number" == typeof value2 && (nLen2 = String(value2).length), value = nLen1 < nLen2 ? value2 : value1;
                    for (var checkValue = 0, ii = 0; ii < _ChartUtils.constants.chartConfigConstants.YLabelLengthLimit; ii++) checkValue += 9 * Math.pow(10, ii);
                    if ((value = Math.abs(value)) > checkValue) {
                        for (var _temp = value, multiple = 1; _temp > 999999; ) {
                            _temp *= Math.pow(.1, multiple), multiple++;
                        }
                        return {
                            multiple: multiple,
                            display: _ChartUtils.axis.label.multipleValue[multiple],
                            pow: Math.pow(.1, multiple)
                        };
                    }
                }
            }, _ChartUtils.axis.didAdjustZFValue = function(argValue, isFive) {
                return argValue;
            }, _ChartUtils.axis.didGetLocalYPos = function(argBase, argPriceDiff) {
                var base = argBase, offset = base.rv * argPriceDiff;
                return Math.round(base.height + base.y - offset);
            }, _ChartUtils.axis.didGetLocalXPos = function(argBase, argDiff) {
                var base = argBase, offset = base.rh * argDiff;
                return Math.round(base.width + base.x - offset);
            }, _ChartUtils.axis.didGetLocalPos = function(argBase, argValueDiff, bHorz) {
                var base = argBase, nLocalPos = 0;
                if (!0 === bHorz) {
                    var offset = base.rh * argValueDiff;
                    nLocalPos = Math.round(base.x + offset);
                } else {
                    var offset = base.rv * argValueDiff;
                    nLocalPos = Math.round(pixelSize + base.y - offset);
                }
                return nLocalPos;
            }, _ChartUtils.axis.didCalcRulerUnitY = function(argPriceDiff, argHeight, verpos) {
                verpos = verpos || 0;
                var rulerUnit = Math.round(argPriceDiff / 5), bMicro = !1;
                if (rulerUnit <= 1) bMicro = !0; else {
                    var nGap = Math.round(argHeight / 50);
                    0 === nGap && (nGap = 1), nGap > rulerUnit && (rulerUnit = nGap), rulerUnit = Math.round(5 * (rulerUnit / nGap + .5));
                }
                return {
                    flag: bMicro,
                    unit: rulerUnit
                };
            }, _ChartUtils.axis.didCalcRulerUnitYAsGuideOffset = function(argPriceDiff, argHeight, guideOffset, verpos) {
                verpos = verpos || 0;
                var rulerUnit = guideOffset, bMicro = !1;
                return rulerUnit <= 1 && (bMicro = !0), {
                    flag: bMicro,
                    unit: rulerUnit
                };
            }, _ChartUtils.axis.didCalcRulerUnitAsGuideOffset = function(argParams) {
                var dOrg = argParams.dOrg, dMax = (argParams.dXVal, argParams.dMax), dMin = argParams.dMin, dCheck = (argParams.bSign, 
                argParams.bDiff, argParams.bLog, Math.pow(10, -0)), dTemp1 = 0, dMMChk = (dMax - dMin) * _ChartUtils.constants.ngcl.define.NGCL_AXIS_RATE1;
                _ChartUtils.constants.ngcl.define.NGCL_AXIS_RATE2;
                if (0 === dOrg) return dCheck;
                if (dOrg <= 5) return dOrg;
                if (dOrg < 10) return 10;
                var dTemp1 = dOrg % 10, dTemp2 = dOrg - dTemp1;
                return dTemp1 < 5 ? dTemp2 + 5 : dTemp2 + 10;
            }, _ChartUtils.axis.didCalcRulerUnit = function(argValueDiff, argPixelDiff) {
                var rulerUnit = Math.round(argValueDiff / 5), bMicro = !1;
                if (rulerUnit <= 1) bMicro = !0; else {
                    var nGap = Math.round(argPixelDiff / 50);
                    0 === nGap && (nGap = 1), nGap > rulerUnit && (rulerUnit = nGap), rulerUnit = Math.round(5 * (rulerUnit / nGap + .5));
                }
                return {
                    flag: bMicro,
                    unit: rulerUnit
                };
            }, _ChartUtils.axis.didCalcRulerBase = function(argOrigin, argOffset) {
                var dOrg = argOrigin, dDOff = argOffset, nSign = dOrg < 0 ? -1 : 1, dTemp = dOrg * nSign;
                return (dTemp = dDOff * parseInt(dTemp / dDOff)) * nSign;
            }, _ChartUtils.axis.didDrawXAxisVer0 = function(argDrawParam) {
                if (!0 === argDrawParam.isGrid && !0 !== argDrawParam.config.show) return !1;
                for (var nScrSize = (argDrawParam.scrollInfo.pos, argDrawParam.scrollInfo.screenSize), drawWrapper = argDrawParam.drawWrapper, xAxisX = argDrawParam.axis, nDiv = parseInt(nScrSize / 4), gridStyle = argDrawParam.config.gridStyle, gridColor = argDrawParam.config.gridColor, fontColor = argDrawParam.config.fontColor, font = argDrawParam.config.font, leftWidth = (argDrawParam.config.show, 
                argDrawParam.target.leftWidth), rightWidth = argDrawParam.target.rightWidth, gridWidth = argDrawParam.target.gridWidth, height = argDrawParam.height, nTType = argDrawParam.timeType, drawLineParam = {
                    context: argDrawParam.target.context,
                    pt1: {
                        x: 0,
                        y: 0
                    },
                    pt2: {
                        x: 0,
                        y: 0
                    },
                    lineWidth: 1,
                    lineColor: gridColor
                }, drawTextParam = {
                    context: argDrawParam.target.context,
                    pt: {
                        x: 0,
                        y: 0
                    },
                    text: "",
                    font: font,
                    fillStyle: fontColor
                }, ii = 1; ii <= 3; ii++) {
                    var nLocalIdx = ii * nDiv, localXPos = xAxisX.GetXPos(nLocalIdx), dataIdx = drawWrapper.didConvertLocalIndexToDataIndex(nLocalIdx);
                    if (!0 === argDrawParam.isGrid) drawLineParam.pt1.x = localXPos, drawLineParam.pt1.y = 1, 
                    drawLineParam.pt2.x = localXPos, drawLineParam.pt2.y = height - 1, drawLineParam.lineStyle = gridStyle, 
                    drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam); else {
                        drawLineParam.pt1.x = localXPos, drawLineParam.pt1.y = -1, drawLineParam.pt2.x = localXPos, 
                        drawLineParam.pt2.y = 2, drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam);
                        var xTimeData = drawWrapper.didGetTimedataAt(dataIdx, !1, !0);
                        if (void 0 === xTimeData || null === xTimeData) continue;
                        var timeData = xTimeData.dateTime;
                        if (void 0 === timeData || null === timeData) continue;
                        var strRuler = "", strTemp = "";
                        nTType <= _ChartUtils.constants.timeType.minute ? (strTemp = timeData.slice(8), 
                        strRuler = _ChartUtils.dateTime.formatTimeString(strTemp, _ChartUtils.dateTime.timeFormat1)) : (strTemp = timeData.slice(0, 8), 
                        strRuler = _ChartUtils.dateTime.formatDateString(strTemp, _ChartUtils.dateTime.dateFormat1));
                        var strWidth = argDrawParam.target.context.measureText(strRuler).width, localXPosText = parseInt(localXPos - strWidth / 2);
                        localXPosText < leftWidth ? localXPosText = leftWidth + 2 : localXPosText + strWidth > gridWidth - rightWidth && (localXPosText = gridWidth - rightWidth - strWidth - 5);
                        drawTextParam.text = strRuler, drawTextParam.pt.x = localXPosText, drawTextParam.pt.y = 14, 
                        drawTextParam.font = font, drawTextParam.fillStyle = fontColor, gxDc.TextOut(drawTextParam);
                    }
                }
            }, _ChartUtils.axis.canBePrintLabelOnXAxis = function(timeType, timeInterval, xTimeDataCur, xTimeDataPre, offset, nDiv) {
                if (void 0 === xTimeDataCur || null === xTimeDataCur) return !1;
                var timeDataCur = xTimeDataCur.dateTime;
                if (void 0 === timeDataCur || null === timeDataCur) return !1;
                if (!xTimeDataPre) return !0;
                var timeDataPre = xTimeDataPre.dateTime;
                if (!timeDataPre) return !0;
                var nCDate = parseInt(timeDataCur.slice(0, 8)), nCTime = parseInt(timeDataCur.slice(8)), nPDate = (xTimeDataCur.tickNo, 
                parseInt(timeDataPre.slice(0, 8))), nPTime = parseInt(timeDataPre.slice(8)), stCur = (xTimeDataPre.tickNo, 
                _ChartUtils.dateTime.convertNumberToDatetime(nCDate, nCTime)), stPre = _ChartUtils.dateTime.convertNumberToDatetime(nPDate, nPTime);
                if (nDiv = nDiv || 3, offset = offset || 0, offset = Math.abs(offset), _ChartUtils.constants.timeType.hour < timeType) {
                    if (offset % nDiv == 0) return !0;
                } else if (_ChartUtils.constants.timeType.hour == timeType) {
                    if (stPre.year < stCur.year) return !0;
                    if (stPre.month < stCur.month) return !0;
                    if (stPre.day < stCur.day) return !0;
                    if (offset % nDiv == 0) return !0;
                } else if (_ChartUtils.constants.timeType.minute == timeType) {
                    if (stPre.year < stCur.year) return !0;
                    if (stPre.month < stCur.month) return !0;
                    if (stPre.day < stCur.day) return !0;
                    if (offset % nDiv == 0) return !0;
                } else if (_ChartUtils.constants.timeType.tick == timeType) {
                    if (offset % nDiv == 0) return !0;
                } else if (offset % nDiv == 0) return !0;
                return !1;
            }, _ChartUtils.axis.canBePrintLabelOnXAxisVer0 = function(timeType, timeInterval, xTimeDataCur, xTimeDataPre) {
                if (void 0 === xTimeDataCur || null === xTimeDataCur) return !1;
                var timeDataCur = xTimeDataCur.dateTime;
                if (void 0 === timeDataCur || null === timeDataCur) return !1;
                if (!xTimeDataPre) return !0;
                var timeDataPre = xTimeDataPre.dateTime;
                if (!timeDataPre) return !0;
                var nCDate = parseInt(timeDataCur.slice(0, 8)), nCTime = parseInt(timeDataCur.slice(8)), nPDate = (xTimeDataCur.tickNo, 
                parseInt(timeDataPre.slice(0, 8))), nPTime = parseInt(timeDataPre.slice(8)), stCur = (xTimeDataPre.tickNo, 
                _ChartUtils.dateTime.convertNumberToDatetime(nCDate, nCTime)), stPre = _ChartUtils.dateTime.convertNumberToDatetime(nPDate, nPTime);
                if (_ChartUtils.constants.timeType.week < timeType) {
                    if (stPre.year < stCur.year) return !0;
                } else if (_ChartUtils.constants.timeType.hour < timeType) {
                    if (stPre.year < stCur.year) return !0;
                    if (stPre.year == stCur.year && stPre.month < stCur.month) return !0;
                    if (stPre.day < stCur.day) return !0;
                } else if (_ChartUtils.constants.timeType.hour == timeType) {
                    if (stPre.year < stCur.year) return !0;
                    if (stPre.month < stCur.month) return !0;
                    if (stPre.day < stCur.day) return !0;
                    if (stPre.hour < stPre.hour) return !0;
                    var nDiv = 5;
                    if (nDiv = timeInterval <= 3 ? 5 : timeInterval <= 10 ? 15 : 60, stCur.minute % nDiv == 0) return !0;
                } else if (_ChartUtils.constants.timeType.hour == timeType) {
                    if (stPre.year < stCur.year) return !0;
                    if (stPre.month < stCur.month) return !0;
                    if (stPre.day < stCur.day) return !0;
                    if (stPre.hour < stPre.hour) return !0;
                    var nDiv = 5;
                    if (nDiv = timeInterval <= 3 ? 4 : timeInterval <= 10 ? 8 : 24, stCur.hour % nDiv == 0) return !0;
                } else if (_ChartUtils.constants.timeType.minute == timeType) {
                    if (stPre.year < stCur.year) return !0;
                    if (stPre.month < stCur.month) return !0;
                    if (stPre.day < stCur.day) return !0;
                    if (stPre.hour < stPre.hour) return !0;
                    var nDiv = 5;
                    if (nDiv = timeInterval <= 3 ? 5 : timeInterval <= 10 ? 15 : 60, stCur.minute % nDiv == 0) return !0;
                } else if (_ChartUtils.constants.timeType.tick == timeType) {
                    if (stPre.year < stCur.year) return !0;
                    if (stPre.month < stCur.month) return !0;
                    if (stPre.day < stCur.day) return !0;
                    if (stPre.hour < stPre.hour) return !0;
                    if (stPre.minute < stPre.minute) return !0;
                    var nDiv = 5;
                    if (nDiv = timeInterval <= 3 ? 5 : timeInterval <= 10 ? 15 : 60, stCur.second % nDiv == 0) return !0;
                }
                return !1;
            }, _ChartUtils.axis.didDrawXAxis = function(argDrawParam) {
                if (!0 === argDrawParam.isGrid && !0 !== argDrawParam.config.show) return !1;
                var nScrSize = (argDrawParam.scrollInfo.pos, argDrawParam.scrollInfo.screenSize);
                if (nScrSize < 1) return !1;
                var drawWrapper = argDrawParam.drawWrapper, xAxisX = argDrawParam.axis, gridStyle = argDrawParam.config.gridStyle, gridColor = argDrawParam.config.gridColor, fontColor = argDrawParam.config.fontColor, font = argDrawParam.config.font, leftWidth = (argDrawParam.config.show, 
                argDrawParam.target.leftWidth), gridWidth = (argDrawParam.target.rightWidth, argDrawParam.target.gridWidth), height = argDrawParam.height, nTType = argDrawParam.timeType, nTGap = argDrawParam.timeInterval, drawLineParam = {
                    context: argDrawParam.target.context,
                    pt1: {
                        x: 0,
                        y: 0
                    },
                    pt2: {
                        x: 0,
                        y: 0
                    },
                    lineWidth: 1,
                    lineColor: gridColor
                }, drawTextParam = {
                    context: argDrawParam.target.context,
                    pt: {
                        x: 0,
                        y: 0
                    },
                    text: "",
                    font: font,
                    fillStyle: fontColor
                };
                argDrawParam.clip && (drawTextParam.clip = argDrawParam.clip);
                var __tmpCanvas__ = document.createElement("canvas"), __tmpContext__ = __tmpCanvas__.getContext("2d"), __calcText__ = _ChartUtils.timeZone.getDefaultDisplayString(nTType);
                __tmpContext__.font = font;
                var __calcWidth__ = __tmpContext__.measureText(__calcText__).width;
                __tmpContext__ = void 0, __tmpCanvas__ = void 0;
                var maxDiv = Math.min(Math.max(3, parseInt(gridWidth / __calcWidth__)), 8), nDiv = parseInt(nScrSize / maxDiv);
                isNaN(nDiv) && (nDiv = 3);
                for (var nLastX, ii = 0; ii < nScrSize; ii++) {
                    var nLocalIdx = ii, localXPos = xAxisX.GetXPos(nLocalIdx), dataIdx = drawWrapper.didConvertLocalIndexToDataIndex(nLocalIdx), xTimeData = drawWrapper.didGetTimedataAt(dataIdx, !1, !0);
                    if (void 0 !== xTimeData && null !== xTimeData) {
                        var timeData = xTimeData.dateTime;
                        if (void 0 !== timeData && null !== timeData) {
                            var xTimeDataPre = drawWrapper.didGetTimedataAt(dataIdx - 1, !1, !0), nOffset = 0;
                            if (nOffset = dataIdx, !0 === _ChartUtils.axis.canBePrintLabelOnXAxis(nTType, nTGap, xTimeData, xTimeDataPre, nOffset, nDiv)) {
                                var strRuler = "", strTemp = "";
                                nTType <= _ChartUtils.constants.timeType.hour ? (strTemp = timeData.slice(8), strRuler = _ChartUtils.dateTime.formatTimeString(strTemp, _ChartUtils.dateTime.timeFormat1)) : (strTemp = timeData.slice(0, 8), 
                                strRuler = _ChartUtils.dateTime.formatDateString(strTemp, _ChartUtils.dateTime.dateFormat1));
                                var strWidth = __calcWidth__, localXPosText = parseInt(localXPos - strWidth / 2);
                                if (!(localXPosText < leftWidth || void 0 !== nLastX && null != nLastX && nLastX > localXPosText - (strWidth + 5))) {
                                    if (!0 === argDrawParam.isGrid) drawLineParam.pt1.x = localXPos, drawLineParam.pt1.y = 1, 
                                    drawLineParam.pt2.x = localXPos, drawLineParam.pt2.y = height - 1, drawLineParam.lineStyle = gridStyle, 
                                    drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam); else {
                                        argDrawParam.showRuler && (drawLineParam.pt1.x = localXPos, drawLineParam.pt1.y = -1, 
                                        drawLineParam.pt2.x = localXPos, drawLineParam.pt2.y = 2, drawLineParam.lineColor = gridColor, 
                                        gxDc.Line(drawLineParam));
                                        drawTextParam.text = strRuler, drawTextParam.pt.x = localXPosText, drawTextParam.pt.y = 9, 
                                        drawTextParam.font = font, drawTextParam.fillStyle = fontColor, gxDc.TextOut(drawTextParam);
                                    }
                                    nLastX = localXPosText, dataIdx;
                                }
                            }
                        }
                    }
                }
            }, _ChartUtils.axis.didDrawXAxisWithLevel = function(argDrawParam) {
                if (void 0 === argDrawParam.levelInfo || null == argDrawParam.levelInfo) return _ChartUtils.axis.didDrawXAxis(argDrawParam);
                if (!0 === argDrawParam.isGrid && !0 !== argDrawParam.config.show) return !1;
                var nScrSize = (argDrawParam.scrollInfo.pos, argDrawParam.scrollInfo.screenSize);
                if (nScrSize < 1) return !1;
                var drawWrapper = argDrawParam.drawWrapper, xAxisX = argDrawParam.axis, gridStyle = argDrawParam.config.gridStyle, gridColor = argDrawParam.config.gridColor, fontColor = argDrawParam.config.fontColor, font = argDrawParam.config.font, height = (argDrawParam.config.show, 
                argDrawParam.target.leftWidth, argDrawParam.target.rightWidth, argDrawParam.target.gridWidth, 
                argDrawParam.height), nTType = argDrawParam.timeType, levelInfo = (argDrawParam.timeInterval, 
                argDrawParam.levelInfo), levelGuide = levelInfo.guideOffset || 1;
                levelGuide = Math.max(1, levelGuide);
                var guideSize = levelInfo.guideSize, drawLineParam = {
                    context: argDrawParam.target.context,
                    pt1: {
                        x: 0,
                        y: 0
                    },
                    pt2: {
                        x: 0,
                        y: 0
                    },
                    lineWidth: 1,
                    lineColor: gridColor
                }, drawTextParam = {
                    context: argDrawParam.target.context,
                    pt: {
                        x: 0,
                        y: 0
                    },
                    text: "",
                    font: font,
                    fillStyle: fontColor
                };
                argDrawParam.clip && (drawTextParam.clip = argDrawParam.clip);
                var __tmpCanvas__ = document.createElement("canvas"), __tmpContext__ = __tmpCanvas__.getContext("2d"), __calcText__ = _ChartUtils.timeZone.getDefaultDisplayString(nTType), __calcWidth__ = __tmpContext__.measureText(__calcText__).width;
                __tmpContext__ = void 0, __tmpCanvas__ = void 0;
                for (var textDiv = levelGuide * Math.max(1, Math.ceil(__calcWidth__ / guideSize)), ii = 0; ii < nScrSize; ii++) {
                    var nLocalIdx = ii, localXPos = xAxisX.GetXPos(nLocalIdx), dataIdx = drawWrapper.didConvertLocalIndexToDataIndex(nLocalIdx);
                    if (dataIdx % levelGuide == 0) {
                        if (!0 === argDrawParam.isGrid ? (drawLineParam.pt1.x = localXPos, drawLineParam.pt1.y = 1, 
                        drawLineParam.pt2.x = localXPos, drawLineParam.pt2.y = height - 1, drawLineParam.lineStyle = gridStyle, 
                        drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam)) : (drawLineParam.pt1.x = localXPos, 
                        drawLineParam.pt1.y = -1, drawLineParam.pt2.x = localXPos, drawLineParam.pt2.y = 2, 
                        drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam)), 1 != argDrawParam.isGrid && !0 !== argDrawParam.isNontime) {
                            if (dataIdx % textDiv != 0) continue;
                            var xTimeData = drawWrapper.didGetTimedataAt(dataIdx, !1, !0);
                            if (void 0 === xTimeData || null === xTimeData) continue;
                            var timeData = xTimeData.dateTime;
                            if (void 0 === timeData || null === timeData) continue;
                            drawWrapper.didGetTimedataAt(dataIdx - 1, !1, !0);
                            dataIdx;
                            var strRuler = "", strTemp = "";
                            nTType <= _ChartUtils.constants.timeType.hour ? (strTemp = timeData.slice(8), strRuler = _ChartUtils.dateTime.formatTimeString(strTemp, _ChartUtils.dateTime.timeFormat1)) : (strTemp = timeData.slice(0, 8), 
                            strRuler = _ChartUtils.dateTime.formatDateString(strTemp, _ChartUtils.dateTime.dateFormat1));
                            var strWidth = __calcWidth__, localXPosText = parseInt(localXPos - strWidth / 2);
                            drawTextParam.text = strRuler, drawTextParam.pt.x = localXPosText, drawTextParam.pt.y = 14, 
                            drawTextParam.font = font, drawTextParam.fillStyle = fontColor, gxDc.TextOut(drawTextParam), 
                            localXPosText, dataIdx;
                        }
                    }
                }
            }, _ChartUtils.axis.didDrawXAxisVer1 = function(argDrawParam) {
                if (!0 === argDrawParam.isGrid && !0 !== argDrawParam.config.show) return !1;
                var nScrSize = (argDrawParam.scrollInfo.pos, argDrawParam.scrollInfo.screenSize), drawWrapper = argDrawParam.drawWrapper, xAxisX = argDrawParam.axis, gridStyle = (parseInt(nScrSize / 4), 
                argDrawParam.config.gridStyle), gridColor = argDrawParam.config.gridColor, fontColor = argDrawParam.config.fontColor, font = argDrawParam.config.font, height = (argDrawParam.config.show, 
                argDrawParam.target.leftWidth, argDrawParam.target.rightWidth, argDrawParam.target.gridWidth, 
                argDrawParam.height), nTType = argDrawParam.timeType, nTGap = argDrawParam.timeInterval, drawLineParam = {
                    context: argDrawParam.target.context,
                    pt1: {
                        x: 0,
                        y: 0
                    },
                    pt2: {
                        x: 0,
                        y: 0
                    },
                    lineWidth: 1,
                    lineColor: gridColor
                }, drawTextParam = {
                    context: argDrawParam.target.context,
                    pt: {
                        x: 0,
                        y: 0
                    },
                    text: "",
                    font: font,
                    fillStyle: fontColor
                };
                argDrawParam.clip && (drawTextParam.clip = argDrawParam.clip);
                for (var nLastX, ii = 0; ii < nScrSize; ii++) {
                    var nLocalIdx = ii, localXPos = xAxisX.GetXPos(nLocalIdx), dataIdx = drawWrapper.didConvertLocalIndexToDataIndex(nLocalIdx), xTimeData = drawWrapper.didGetTimedataAt(dataIdx, !1, !0);
                    if (void 0 !== xTimeData && null !== xTimeData) {
                        var timeData = xTimeData.dateTime;
                        if (void 0 !== timeData && null !== timeData) {
                            var xTimeDataPre = drawWrapper.didGetTimedataAt(dataIdx - 1, !1, !0);
                            if (!0 === _ChartUtils.axis.canBePrintLabelOnXAxis(nTType, nTGap, xTimeData, xTimeDataPre)) {
                                var strRuler = "", strTemp = "";
                                nTType <= _ChartUtils.constants.timeType.hour ? (strTemp = timeData.slice(8), strRuler = _ChartUtils.dateTime.formatTimeString(strTemp, _ChartUtils.dateTime.timeFormat1)) : (strTemp = timeData.slice(0, 8), 
                                strRuler = _ChartUtils.dateTime.formatDateString(strTemp, _ChartUtils.dateTime.dateFormat1));
                                var __tmp__ = document.createElement("canvas").getContext("2d");
                                drawTextParam.text = strRuler;
                                var strWidth = __tmp__.measureText(strRuler).width, localXPosText = parseInt(localXPos - strWidth / 2);
                                if (!(void 0 !== nLastX && null != nLastX && nLastX < localXPosText + strWidth + 5)) {
                                    if (!0 === argDrawParam.isGrid) drawLineParam.pt1.x = localXPos, drawLineParam.pt1.y = 1, 
                                    drawLineParam.pt2.x = localXPos, drawLineParam.pt2.y = height - 1, drawLineParam.lineStyle = gridStyle, 
                                    drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam); else {
                                        drawLineParam.pt1.x = localXPos, drawLineParam.pt1.y = -1, drawLineParam.pt2.x = localXPos, 
                                        drawLineParam.pt2.y = 2, drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam);
                                        drawTextParam.text = strRuler, drawTextParam.pt.x = localXPosText, drawTextParam.pt.y = 14, 
                                        drawTextParam.font = font, drawTextParam.fillStyle = fontColor, gxDc.TextOut(drawTextParam);
                                    }
                                    nLastX = localXPosText;
                                }
                            }
                        }
                    }
                }
            }, _ChartUtils.axis.didDrawYAxis = function(argDrawParam) {
                var nMaxValue = parseInt(argDrawParam.price.max.toFixed(0)), nMinValue = parseInt(argDrawParam.price.min.toFixed(0)), nMMPrice = _ChartUtils.didCalcPriceSize(nMaxValue, nMinValue), verpos = argDrawParam.price.verpos;
                if (nMMPrice <= 0) return !1;
                for (var rulerInfo = _ChartUtils.axis.didCalcRulerUnitY(nMMPrice, argDrawParam.height), strPrice = "", gridStyle = argDrawParam.config.gridStyle, gridColor = argDrawParam.config.gridColor, fontColor = argDrawParam.config.fontColor, font = argDrawParam.config.font, bShowGrid = argDrawParam.config.show, leftWidth = argDrawParam.target.left.width, gridWidth = (argDrawParam.target.right.width, 
                argDrawParam.target.grid.width), iXPosLY = (argDrawParam.height, leftWidth - 4), xAxisY = argDrawParam.axis, xMultipleFactor = _ChartUtils.axis.label.didCalcMutipleValue(nMaxValue, nMinValue), drawLineParam = {
                    context: null,
                    pt1: {
                        x: 0,
                        y: 0
                    },
                    pt2: {
                        x: 0,
                        y: 0
                    },
                    lineWidth: 1,
                    lineColor: gridColor
                }, drawTextParam = {
                    context: null,
                    pt: {
                        x: 0,
                        y: 0
                    },
                    text: "",
                    font: font,
                    fillStyle: fontColor
                }, nStartValue = parseInt(nMinValue), nEndValue = parseInt(nMaxValue), priceValue = nStartValue; priceValue <= nEndValue; priceValue++) {
                    var nXPosLY = iXPosLY, nXPosRY = 0;
                    if (!0 === rulerInfo.flag || priceValue % rulerInfo.unit == 0) {
                        var nYPos = xAxisY.GetYPos(priceValue);
                        !0 === bShowGrid && (drawLineParam.context = argDrawParam.target.grid.context, drawLineParam.pt1.x = 1, 
                        drawLineParam.pt1.y = nYPos, drawLineParam.pt2.x = gridWidth - 1, drawLineParam.pt2.y = nYPos, 
                        drawLineParam.lineStyle = gridStyle, drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam)), 
                        drawLineParam.context = argDrawParam.target.left.context, drawLineParam.pt1.x = nXPosLY, 
                        drawLineParam.pt1.y = nYPos, drawLineParam.pt2.x = nXPosLY + 3, drawLineParam.pt2.y = nYPos, 
                        drawLineParam.lineStyle = null, drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam), 
                        drawLineParam.context = argDrawParam.target.right.context, drawLineParam.pt1.x = nXPosRY, 
                        drawLineParam.pt1.y = nYPos, drawLineParam.pt2.x = nXPosRY + 3, drawLineParam.pt2.y = nYPos, 
                        drawLineParam.lineStyle = null, drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam);
                        var rulerData = priceValue;
                        xMultipleFactor && (rulerData = Math.round(rulerData * xMultipleFactor.pow)), strPrice = _ChartUtils.number.didGetPointedValue(rulerData, verpos), 
                        nXPosLY = leftWidth - argDrawParam.target.left.context.measureText(strPrice).width - 6, 
                        nXPosRY = 6, drawTextParam.context = argDrawParam.target.left.context, drawTextParam.text = strPrice, 
                        drawTextParam.pt.x = nXPosLY, drawTextParam.pt.y = nYPos, drawTextParam.font = font, 
                        drawTextParam.fillStyle = fontColor, gxDc.TextOut(drawTextParam), drawTextParam.context = argDrawParam.target.right.context, 
                        drawTextParam.text = strPrice, drawTextParam.pt.x = nXPosRY, drawTextParam.pt.y = nYPos, 
                        drawTextParam.font = font, drawTextParam.fillStyle = fontColor, gxDc.TextOut(drawTextParam);
                    }
                }
                if (xMultipleFactor) {
                    var strDisp = xMultipleFactor.display;
                    nYPos = 8, nXPosLY = leftWidth - argDrawParam.target.left.context.measureText(strDisp).width - 6, 
                    nXPosRY = 6, drawTextParam.useBox = !0, drawTextParam.boxStyle = argDrawParam.config.multiColor, 
                    drawTextParam.context = argDrawParam.target.left.context, drawTextParam.text = strDisp, 
                    drawTextParam.pt.x = nXPosLY, drawTextParam.pt.y = nYPos, drawTextParam.font = font, 
                    drawTextParam.fillStyle = fontColor, gxDc.DrawSingleLineText(drawTextParam, !0), 
                    drawTextParam.context = argDrawParam.target.right.context, drawTextParam.text = strDisp, 
                    drawTextParam.pt.x = nXPosRY, drawTextParam.pt.y = nYPos, drawTextParam.font = font, 
                    drawTextParam.fillStyle = fontColor, gxDc.DrawSingleLineText(drawTextParam, !0);
                }
                return !0;
            }, _ChartUtils.axis.didCalcRulerUnit = function(argParams) {
                var dOrg = argParams.dOrg, dXVal = argParams.dXVal, dMax = argParams.dMax, dMin = argParams.dMin, bSign = argParams.bSign, bLog = (argParams.bDiff, 
                argParams.bLog), dCheck = Math.pow(10, -0), nSign = dOrg < 0 ? -1 : 1, dTemp = dOrg * nSign, dTemp1 = 0, ii = 0, dMMChk = (dMax - dMin) * _ChartUtils.constants.ngcl.define.NGCL_AXIS_RATE1, dCvt = 0, dDCheck = dMMChk * _ChartUtils.constants.ngcl.define.NGCL_AXIS_RATE2;
                if (0 === dOrg) return dCheck;
                dTemp > dMMChk && (dMMChk = 1.5 * dTemp, dDCheck = dMMChk * _ChartUtils.constants.ngcl.define.NGCL_AXIS_RATE2), 
                !0 !== bLog && (dTemp = Math.max(dTemp, dDCheck));
                var dPoint = 1, nCnt = 0;
                if (dXVal = 1, dTemp < 1) for (-1, nCnt = 1; dTemp < .1; ) dTemp *= 10, dPoint /= 10, 
                nCnt++; else for (;dTemp > 1; ) dTemp /= 10, dPoint *= 10, nCnt++;
                var n64Temp = 0, n64Frag = 0;
                for (ii = nCnt + 0; ii >= 0; ii--) {
                    if (n64Temp = parseInt(10 * dTemp), n64Frag = parseInt(n64Temp + 5) % 5, n64Temp = n64Temp - n64Frag + 5, 
                    dCvt = 1 * n64Temp, dTemp1 = dCvt * dPoint / 10, dDCheck <= dTemp1 && dMMChk >= dTemp1) {
                        dPoint /= 10, dTemp *= 10;
                        break;
                    }
                    if (dCvt -= 5, dTemp1 = dCvt * dPoint / 10, dDCheck <= dTemp1 && dMMChk >= dTemp1) {
                        dPoint /= 10, dTemp *= 10;
                        break;
                    }
                    dPoint /= 10, dTemp *= 10;
                }
                dCvt *= dPoint;
                var dFactor1 = Math.pow(10, 1), lTemp = parseInt(dCvt * dFactor1);
                return lTemp % 10 != 0 && (lTemp = 10 * (lTemp / 10 + 1), dCvt = lTemp / dFactor1), 
                dOrg = bSign ? dCvt * nSign : dCvt, argParams.dXVal = dXVal, dOrg;
            }, _ChartUtils.axis.didDrawYAxisAsBeauty = function(argDrawParam) {
                var nMaxValue = parseInt(argDrawParam.price.max.toFixed(0)), nMinValue = parseInt(argDrawParam.price.min.toFixed(0)), nMMPrice = _ChartUtils.didCalcPriceSize(nMaxValue, nMinValue), verpos = argDrawParam.price.verpos;
                if (nMMPrice <= 0) return !1;
                var rulerInfo, isGuideOffset = !1;
                if (void 0 !== argDrawParam.guideSize && null !== argDrawParam.guideSize) {
                    var guideOffset = argDrawParam.axis.GetYPixelToVal(argDrawParam.guideSize);
                    rulerInfo = _ChartUtils.axis.didCalcRulerUnitYAsGuideOffset(nMMPrice, argDrawParam.height, guideOffset), 
                    isGuideOffset = !0;
                } else rulerInfo = _ChartUtils.axis.didCalcRulerUnitY(nMMPrice, argDrawParam.height);
                var rulerUnit, rulerCalcParam = {
                    dOrg: rulerInfo.unit,
                    nPointVal: 0,
                    dXVal: 1,
                    dMax: argDrawParam.price.max,
                    dMin: argDrawParam.price.min,
                    bSign: !1,
                    bDiff: !0,
                    bLog: !1
                };
                rulerUnit = 1 == isGuideOffset ? Math.round(_ChartUtils.axis.didCalcRulerUnitAsGuideOffset(rulerCalcParam)) : Math.round(_ChartUtils.axis.didCalcRulerUnit(rulerCalcParam));
                var strPrice = "", gridStyle = argDrawParam.config.gridStyle, gridColor = argDrawParam.config.gridColor, fontColor = argDrawParam.config.fontColor, font = argDrawParam.config.font, bShowGrid = argDrawParam.config.show, leftWidth = argDrawParam.target.left.width, gridWidth = (argDrawParam.target.right.width, 
                argDrawParam.target.grid.width), iXPosLY = (argDrawParam.height, leftWidth - 4), xAxisY = argDrawParam.axis, nDOff = parseInt(rulerInfo.unit * xAxisY.m_iGridHeight * 1.5), xMultipleFactor = _ChartUtils.axis.label.didCalcMutipleValue(nMaxValue, nMinValue), drawLineParam = {
                    context: null,
                    pt1: {
                        x: 0,
                        y: 0
                    },
                    pt2: {
                        x: 0,
                        y: 0
                    },
                    lineWidth: 1,
                    lineColor: gridColor
                }, drawTextParam = {
                    context: null,
                    pt: {
                        x: 0,
                        y: 0
                    },
                    text: "",
                    font: font,
                    fillStyle: fontColor
                }, dNewD = _ChartUtils.axis.didCalcRulerBase(nMinValue, rulerUnit), dData = 0, dUpperLimit = (_ChartUtils.constants.default.DEFAULT_WRONG_VALUE, 
                nMaxValue + 2 * rulerUnit);
                for (dData = dNewD; dData < dUpperLimit; dData += rulerUnit) {
                    var nXPosLY = iXPosLY, nXPosRY = 0, nYPos = xAxisY.GetYPos(dData);
                    if (nYPos < 0 - 2 * nDOff || nYPos > argDrawParam.y + argDrawParam.height + 3 * nDOff) break;
                    !0 === bShowGrid && (drawLineParam.context = argDrawParam.target.grid.context, drawLineParam.pt1.x = 1, 
                    drawLineParam.pt1.y = nYPos, drawLineParam.pt2.x = gridWidth - 1, drawLineParam.pt2.y = nYPos, 
                    drawLineParam.lineStyle = gridStyle, drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam)), 
                    argDrawParam.showRuler && (drawLineParam.context = argDrawParam.target.left.context, 
                    drawLineParam.pt1.x = nXPosLY, drawLineParam.pt1.y = nYPos, drawLineParam.pt2.x = nXPosLY + 3, 
                    drawLineParam.pt2.y = nYPos, drawLineParam.lineStyle = null, drawLineParam.lineColor = gridColor, 
                    gxDc.Line(drawLineParam), drawLineParam.context = argDrawParam.target.right.context, 
                    drawLineParam.pt1.x = nXPosRY, drawLineParam.pt1.y = nYPos, drawLineParam.pt2.x = nXPosRY + 3, 
                    drawLineParam.pt2.y = nYPos, drawLineParam.lineStyle = null, drawLineParam.lineColor = gridColor, 
                    gxDc.Line(drawLineParam));
                    var rulerData = dData;
                    xMultipleFactor && (rulerData = Math.round(rulerData * xMultipleFactor.pow)), strPrice = _ChartUtils.number.didGetPointedValue(rulerData, verpos), 
                    nXPosLY = leftWidth - argDrawParam.target.left.context.measureText(strPrice).width - _ChartUtils.constants.default.RULER_MARGIN, 
                    nXPosRY = _ChartUtils.constants.default.RULER_MARGIN, drawTextParam.context = argDrawParam.target.left.context, 
                    drawTextParam.text = strPrice, drawTextParam.pt.x = Math.round(nXPosLY), drawTextParam.pt.y = nYPos + .5, 
                    drawTextParam.font = font, drawTextParam.fillStyle = fontColor, drawTextParam.clip = argDrawParam.target.left.clip, 
                    gxDc.TextOut(drawTextParam), drawTextParam.context = argDrawParam.target.right.context, 
                    drawTextParam.text = strPrice, drawTextParam.pt.x = Math.round(nXPosRY), drawTextParam.pt.y = nYPos + .5, 
                    drawTextParam.font = font, drawTextParam.fillStyle = fontColor, drawTextParam.clip = argDrawParam.target.right.clip, 
                    gxDc.TextOut(drawTextParam);
                }
                var dLowerLimit = nMinValue - 2 * rulerUnit;
                for (dData = dNewD - rulerUnit; dData > dLowerLimit; dData -= rulerUnit) {
                    var nXPosLY = iXPosLY, nXPosRY = 0, nYPos = xAxisY.GetYPos(dData);
                    if (nYPos < 0 - 2 * nDOff || nYPos > argDrawParam.y + argDrawParam.height + 3 * nDOff) break;
                    !0 === bShowGrid && (drawLineParam.context = argDrawParam.target.grid.context, drawLineParam.pt1.x = 1, 
                    drawLineParam.pt1.y = nYPos, drawLineParam.pt2.x = gridWidth - 1, drawLineParam.pt2.y = nYPos, 
                    drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam)), drawLineParam.context = argDrawParam.target.left.context, 
                    drawLineParam.pt1.x = nXPosLY, drawLineParam.pt1.y = nYPos, drawLineParam.pt2.x = nXPosLY + 3, 
                    drawLineParam.pt2.y = nYPos, drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam), 
                    drawLineParam.context = argDrawParam.target.right.context, drawLineParam.pt1.x = nXPosRY, 
                    drawLineParam.pt1.y = nYPos, drawLineParam.pt2.x = nXPosRY + 3, drawLineParam.pt2.y = nYPos, 
                    drawLineParam.lineColor = gridColor, gxDc.Line(drawLineParam);
                    var rulerData = dData;
                    xMultipleFactor && (rulerData = Math.round(rulerData * xMultipleFactor.pow)), strPrice = _ChartUtils.number.didGetPointedValue(rulerData, verpos), 
                    nXPosLY = leftWidth - argDrawParam.target.left.context.measureText(strPrice).width - _ChartUtils.constants.default.RULER_MARGIN, 
                    nXPosRY = _ChartUtils.constants.default.RULER_MARGIN, drawTextParam.context = argDrawParam.target.left.context, 
                    drawTextParam.text = strPrice, drawTextParam.pt.x = Math.round(nXPosLY), drawTextParam.pt.y = nYPos, 
                    drawTextParam.font = font, drawTextParam.fillStyle = fontColor, drawTextParam.clip = argDrawParam.target.left.clip, 
                    gxDc.TextOut(drawTextParam), drawTextParam.context = argDrawParam.target.right.context, 
                    drawTextParam.text = strPrice, drawTextParam.pt.x = Math.round(nXPosRY), drawTextParam.pt.y = nYPos, 
                    drawTextParam.font = font, drawTextParam.fillStyle = fontColor, drawTextParam.clip = argDrawParam.target.right.clip, 
                    gxDc.TextOut(drawTextParam);
                }
                if (xMultipleFactor) {
                    var strDisp = xMultipleFactor.display;
                    nYPos = 8, nXPosLY = leftWidth - argDrawParam.target.left.context.measureText(strDisp).width - 6, 
                    nXPosRY = 6, drawTextParam.useBox = !0, drawTextParam.boxStyle = argDrawParam.config.multiColor, 
                    drawTextParam.context = argDrawParam.target.left.context, drawTextParam.text = strDisp, 
                    drawTextParam.pt.x = nXPosLY, drawTextParam.pt.y = nYPos, drawTextParam.font = font, 
                    drawTextParam.fillStyle = fontColor, drawTextParam.clip = argDrawParam.target.left.clip, 
                    gxDc.DrawSingleLineText(drawTextParam, !0), drawTextParam.context = argDrawParam.target.right.context, 
                    drawTextParam.text = strDisp, drawTextParam.pt.x = nXPosRY, drawTextParam.pt.y = nYPos, 
                    drawTextParam.font = font, drawTextParam.fillStyle = fontColor, drawTextParam.clip = argDrawParam.target.right.clip, 
                    gxDc.DrawSingleLineText(drawTextParam, !0);
                }
                return !0;
            }, _ChartUtils.axis.didDrawLastValueOnYAxis = function(argDrawParam) {
                try {
                    var verpos = argDrawParam.price.verpos, dData = argDrawParam.price.value, fillColor = argDrawParam.price.color, strPrice = "", fontColor = argDrawParam.config.fontColor, font = argDrawParam.config.font, leftWidth = argDrawParam.target.left.width, rightWidth = argDrawParam.target.right.width, iXPosLY = leftWidth - 4, xAxisY = argDrawParam.axis, drawTextParam = {
                        context: null,
                        pt: {
                            x: 0,
                            y: 0
                        },
                        text: "",
                        font: font,
                        fillStyle: fontColor,
                        boxStyle: fillColor
                    }, nXPosLY = iXPosLY, nXPosRY = 0, nYPos = xAxisY.GetYPos(dData), xScaleUnit = xAxisY.didGetScaleUnit(), xMMScreen = xScaleUnit.minMaxScreen, xMultipleFactor = _ChartUtils.axis.label.didCalcMutipleValue(xMMScreen.maxValue, xMMScreen.minValue);
                    xMultipleFactor && (dData = Math.round(dData * xMultipleFactor.pow)), strPrice = _ChartUtils.number.didGetPointedValue(dData, verpos);
                    var nMargin = _ChartUtils.constants.default.RULER_MARGIN;
                    return leftWidth > 0 && (nXPosLY = leftWidth - argDrawParam.target.left.context.measureText(strPrice).width - nMargin, 
                    drawTextParam.context = argDrawParam.target.left.context, drawTextParam.text = strPrice, 
                    drawTextParam.pt.x = nXPosLY, drawTextParam.pt.y = nYPos, drawTextParam.font = font, 
                    drawTextParam.fillStyle = fontColor, gxDc.DrawSingleLineText(drawTextParam)), rightWidth > 0 && (nXPosRY = nMargin, 
                    drawTextParam.context = argDrawParam.target.right.context, drawTextParam.text = strPrice, 
                    drawTextParam.pt.x = nXPosRY, drawTextParam.pt.y = nYPos, drawTextParam.font = font, 
                    drawTextParam.fillStyle = fontColor, gxDc.DrawSingleLineText(drawTextParam)), !0;
                } catch (e) {
                    console.error(e);
                }
                return !1;
            }, _ChartUtils.axis.didGetAdjustedBarInfo = function(argBarWidth, nLocalXPos) {
                var __barWidth = parseInt(argBarWidth), __barWidth1 = __barWidth - 1, __halfRatio = __barWidth1 / 2, __halfBar = parseInt(__halfRatio), __result = {
                    grid: __barWidth
                };
                return void 0 !== nLocalXPos && (__barWidth > 30 ? (__result.pos = parseInt(nLocalXPos - __halfBar + 3), 
                __result.width = parseInt(nLocalXPos + __halfBar - 3) - __result.pos) : __barWidth > 15 ? (__result.pos = parseInt(nLocalXPos - __halfBar + 2), 
                __result.width = parseInt(nLocalXPos + __halfBar - 2) - __result.pos) : __barWidth > 10 ? (__result.pos = parseInt(nLocalXPos - __halfBar + 1), 
                __result.width = parseInt(nLocalXPos + __halfBar - 1) - __result.pos) : __barWidth > 3 ? (__result.pos = parseInt(nLocalXPos - __halfBar), 
                __result.width = parseInt(nLocalXPos + __halfBar) - __result.pos) : __barWidth > 1 ? (__result.pos = parseInt(nLocalXPos - 1), 
                __result.width = parseInt(nLocalXPos + 1) - __result.pos) : (__result.pos = nLocalXPos, 
                __result.width = 1)), __result;
            }, _ChartUtils.dataValidator = {}, _ChartUtils.dataValidator.isValidData = function(argValue, bFlag) {
                return void 0 !== argValue && parseInt(argValue) !== _ChartUtils.constants.default.DEFAULT_WRONG_VALUE && (!0 !== bFlag || 0 !== parseInt(argValue));
            }, _ChartUtils.array = {}, _ChartUtils.array.insertAt = function(array, index, datas) {
                if (void 0 === array || null == array) return datas;
                var nCount = array.length;
                return void 0 === nCount || null == nCount || nCount < 1 ? datas : (index < 0 && (index = 0), 
                index >= nCount ? array.concat(datas) : array.slice(0, index).concat(datas, array.slice(index)));
            }, _ChartUtils.number = {}, _ChartUtils.number.util = {}, _ChartUtils.number.util.getComma = function(v) {
                return String(v).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
            }, _ChartUtils.number.util.float2int = function(v) {
                return v || 0;
            }, _ChartUtils.number.util.floatFormat = function(number, n) {
                var __pow = Math.pow(10, n);
                return Math.round(number * __pow) / __pow;
            }, _ChartUtils.number.util.getPointValue = function(p) {
                var strPoint, priceValue = p.price, pointValue = p.point, strZero = "", strSign = "", strTemp = priceValue.toString(), arrayOfStrings = strTemp.split(".");
                arrayOfStrings.length > 1 && (strPoint = arrayOfStrings[1], strTemp = arrayOfStrings[0]), 
                "-" == strTemp.substring(0, 1) && (strTemp = strTemp.substring(1, strTemp.length), 
                strSign = "-");
                for (var idx = strTemp.length; idx <= pointValue; idx++) strZero += "0";
                strTemp = strZero + strTemp;
                var nPointed = strTemp.length - pointValue, strNonPoint = _ChartUtils.number.util.getComma(strTemp.substring(0, nPointed));
                _ChartUtils.number.config && !0 === _ChartUtils.number.config.invalidComma && (strNonPoint = strTemp.substring(0, nPointed));
                var __trimCheck, __trimCheck, strPointValue = strTemp.substring(nPointed, strTemp.length), strPointData = strPointValue + (void 0 !== strPoint ? strPoint : ""), strRealPointData = strPointData.substring(0, p.point), hasPoint = !1;
                if (void 0 !== strRealPointData && null != strRealPointData) {
                    var __trimCheck = strRealPointData;
                    __trimCheck.trim(), "" !== __trimCheck && (hasPoint = !0);
                }
                return !0 === hasPoint ? strSign + strNonPoint + "." + strRealPointData : strSign + strNonPoint;
            }, _ChartUtils.number.util.didGetPointedValue = function(argData) {
                return argData.price = Math.round(argData.price), _ChartUtils.number.util.getPointValue(argData);
            }, _ChartUtils.number.util.roundXL = function(n, digits) {
                if (digits >= 0) return parseFloat(n.toFixed(digits));
                digits = Math.pow(10, digits);
                var t = Math.round(n * digits) / digits;
                return parseFloat(t.toFixed(0));
            }, _ChartUtils.number.util.getDigit = function(n, digits) {
                if (digits <= 0) return parseFloat(n);
                var _nBase = 10 * digits;
                return parseInt((n / _nBase).toFixed(0)) * _nBase;
            }, _ChartUtils.number.formatAsfillSize = function(argNum, argFill, argCount) {
                return new Array(argCount + 1 - argNum.toString().length).join(argFill) + argNum;
            }, _ChartUtils.number.didGetPointedValue = function(argValue, argPoint, isFloor) {
                return !0 !== isFloor && (argValue = Math.round(argValue)), String(_ChartUtils.number.util.getPointValue({
                    price: argValue,
                    point: argPoint
                }));
            }, _ChartUtils.scroll = {}, _ChartUtils.scroll.getZoomFactorBy = function(argSize) {
                return argSize < 20 ? 1 : argSize < 50 ? 2 : argSize < 100 ? 5 : argSize < 200 ? 10 : argSize < 300 ? 20 : 30;
            }, _ChartUtils.struct = {}, _ChartUtils.struct.ST_VALUE_INFO = {
                nNo: 0,
                nData: 0,
                nExIData: 0,
                dRatio: 0,
                strName: "",
                lpData: null
            }, _ChartUtils.error = {}, _ChartUtils.error.errorCodes = {
                errorStart: 100,
                overLimitForTrendline: 101
            }, _ChartUtils.constants = {}, _ChartUtils.constants.text = {
                dataView: {
                    open: "",
                    avgOpen: "",
                    high: "",
                    low: "",
                    close: "",
                    avgClose: "",
                    volume: "",
                    amount: "",
                    oi: "OI",
                    invalid: " "
                }
            }, _ChartUtils.constants.chartConfigConstants = {
                TextSpace: 10,
                LineSpace: 20,
                SelectedMark: {
                    lineColor: "#599cbf",
                    fillColor: "#ffff96"
                },
                SelectedFill: {
                    lineColor: "#a0a0a0",
                    fillColor: "#eeeeee"
                },
                Scroll: {
                    zoom: 90,
                    screenSize: {
                        max: 100,
                        min: 10
                    },
                    barSize: 3,
                    barGap: 1
                },
                YAxisWidth: 60,
                YAxisLeft: 0,
                YAxisRight: 60,
                Gap: 0,
                MultipleSeries: !1,
                UseGlobalTrendlineColor: !1,
                TrendlineLimits: 10,
                TickJustLine: !1,
                IndicatorLimits: 10,
                ContainerSelect: !0,
                IndicatorSelect: !0,
                MinimumPanelSpace: 30,
                ValueSmoothFactor: 10,
                UseContextMenu: !1,
                UseScrollAction: !0,
                ContextMenuOrderAll: !1,
                UseOneClickOepMode: !1,
                UseRequestPreviousNext: !1,
                OepAmendLimitPixel: 5,
                MultipleLabelLimit: 99999,
                YLabelLengthLimit: 7,
                ShowFixedData: !1,
                UseObjectCrossline: !1,
                CrosslineBoxRadius: 15,
                UseMouseWheel: !0,
                DefaultPriceBar: "default",
                AllowSmoothScroll: !0
            }, _ChartUtils.constants.chartConfig = {
                System: _ChartUtils.didClone(_ChartUtils.constants.chartConfigConstants),
                Focusing: !1,
                FocusingBackground: "#95372F",
                FocusingForeground: "#FFFFFF",
                UnfocusingBackground: "#FAF5F1",
                UnfocusingForeground: "#95372F",
                FocusingAlpha: .3,
                UseSmoothScroll: !0,
                UseNewOrderLine: !1,
                BackgroundColor: "#FFFFFF",
                BorderColor: "#949494",
                MarginTopBottom: "5",
                MarginRight: "5",
                ConfigAxis: {
                    ShowLeft: !1,
                    ShowRight: !0,
                    Font: "12px Arial",
                    FontColor: "#949494",
                    GridShow: !0,
                    GridColor: "#949494",
                    GridStyle: gxDc.penstyle.dot,
                    GridVertColor: "#949494",
                    GridHorzColor: "#949494",
                    MultipleLabelColor: "#95372F"
                },
                DontMoveOnTrendlineSelectMode: !1,
                CrossLine: {
                    hide: !1,
                    fontStyle: {
                        fontSize: "12px",
                        fontColor: "#949494"
                    },
                    lineStyle: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#949494"
                    },
                    box: {
                        isCircle: !0
                    },
                    height: "17px",
                    backgroundColor: "#303030"
                },
                TrendlineColor: "#E64546",
                TrendlineFillAlpha: .5,
                Font: "12px Arial",
                FontColor: "#949494",
                ShowDataView: !0,
                ReflectDataView: !0,
                GoToEndPos: !0,
                OrderStyleConfig: {
                    default: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#fe4a4a"
                    },
                    bid: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#0D87F2"
                    },
                    ask: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#FE4A4A"
                    },
                    dummy: {
                        strokeStyle: gxDc.penstyle.dashdotdot,
                        strokeWeight: 1,
                        strokeColor: "#fe4a4a"
                    }
                },
                PositStyleConfig: {
                    default: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#0d87f2"
                    },
                    bid: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#0D87F2"
                    },
                    ask: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#FE4A4A"
                    },
                    dummy: {
                        strokeStyle: gxDc.penstyle.dashdotdot,
                        strokeWeight: 1,
                        strokeColor: "#0d87f2"
                    }
                },
                AlertStyleConfig: {
                    default: {
                        strokeStyle: gxDc.penstyle.dash,
                        strokeWeight: 1,
                        strokeColor: "#0d87f2"
                    },
                    bid: {
                        strokeStyle: gxDc.penstyle.dash,
                        strokeWeight: 1,
                        strokeColor: "#0D87F2"
                    },
                    ask: {
                        strokeStyle: gxDc.penstyle.dash,
                        strokeWeight: 1,
                        strokeColor: "#FE4A4A"
                    },
                    dummy: {
                        strokeStyle: gxDc.penstyle.dashdotdot,
                        strokeWeight: 1,
                        strokeColor: "#0d87f2"
                    }
                },
                ExecutionStyleConfig: {
                    noFill: !0,
                    default: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#0d87f2"
                    },
                    bid: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#0D87F2"
                    },
                    ask: {
                        strokeStyle: gxDc.penstyle.solid,
                        strokeWeight: 1,
                        strokeColor: "#FE4A4A"
                    },
                    dummy: {
                        strokeStyle: gxDc.penstyle.dashdotdot,
                        strokeWeight: 1,
                        strokeColor: "#0d87f2"
                    }
                },
                ChartType: "Candle",
                PriceStyleConfig: {
                    Candle: {
                        strokeWeight: 1,
                        strokeColor: "#eeeeee",
                        strokeUpColor: "#fe4a4a",
                        strokeDnColor: "#0d87f2",
                        fillUpColor: "#fe7c7c",
                        fillDnColor: "#55abf6"
                    },
                    Line: {
                        strokeWeight: 1,
                        strokeColor: "#fe7c7c"
                    },
                    OHLC: {
                        strokeWeight: 1,
                        strokeUpColor: "#fe7c7c",
                        strokeDnColor: "#55abf6"
                    },
                    HLC: {
                        strokeWeight: 1,
                        strokeUpColor: "#fe7c7c",
                        strokeDnColor: "#55abf6"
                    },
                    TLB: {
                        params: [ {
                            name: "period",
                            value: 5
                        } ],
                        strokeWeight: 1,
                        strokeUpColor: "#fe4a4a",
                        strokeDnColor: "#0d87f2",
                        fillUpColor: "#fe7c7c",
                        fillDnColor: "#55abf6"
                    },
                    KAGI: {
                        params: [ {
                            name: "period",
                            value: .5
                        } ],
                        strokeWeight: 1,
                        strokeUpColor: "#fe4a4a",
                        strokeDnColor: "#0d87f2"
                    },
                    RENKO: {
                        params: [ {
                            name: "period",
                            value: 5
                        } ],
                        strokeWeight: 1,
                        strokeUpColor: "#fe4a4a",
                        strokeDnColor: "#0d87f2"
                    },
                    PNF: {
                        params: [ {
                            name: "period",
                            value: 3
                        } ],
                        strokeWeight: 1,
                        strokeUpColor: "#fe4a4a",
                        strokeDnColor: "#0d87f2"
                    },
                    RCL: {
                        params: [ {
                            name: "period",
                            value: 5
                        } ],
                        strokeWeight: 1,
                        strokeColor: "#fe7c7c",
                        strokeUpColor: "#fe4a4a",
                        strokeDnColor: "#0d87f2"
                    },
                    CompareChart: {
                        strokeWeight: 1,
                        strokeColors: {
                            "0": _ChartUtils.color.tables.lists[0],
                            "1": _ChartUtils.color.tables.lists[1],
                            "2": _ChartUtils.color.tables.lists[2],
                            "3": _ChartUtils.color.tables.lists[3],
                            "4": _ChartUtils.color.tables.lists[4],
                            "5": _ChartUtils.color.tables.lists[5],
                            "6": _ChartUtils.color.tables.lists[6]
                        }
                    }
                }
            }, _ChartUtils.constants.didGetClonedDefaultChartConfig = function() {
                return _ChartUtils.didClone(_ChartUtils.constants.chartConfig);
            }, _ChartUtils.constants.colors = {
                default: [ "#f675c4", "#25b5a6", "#459915", "#ff007f", "#0f8989", "#8d2582", "#39a6d4", "#d439b9", "#f33603", "#00d8ff", "#f05d15", "#b59f25", "#54b525" ],
                indicator: [ "#f675c4", "#25b5a6", "#459915", "#ff007f", "#0f8989", "#8d2582", "#39a6d4", "#d439b9", "#f33603", "#00d8ff", "#f05d15", "#b59f25", "#54b525" ]
            }, _ChartUtils.constants.timeType = {
                tick: 0,
                minute: 1,
                hour: 2,
                day: 3,
                week: 4,
                month: 5
            }, _ChartUtils.constants.default = {
                XAXIS_HEIGHT: 30,
                YAXIS_WIDTH: 60,
                TOP_HEIGHT: 0,
                DELETEKEY: 46,
                TREND_WIDTH: 0,
                RIGHTMARGINAREA: 0,
                LEFTMARGINAREA: 0,
                BOTTOMMARGINAREA: 0,
                DEFAULT_WRONG_VALUE: 9999999999999,
                DISPLAY_NONE_DATA: "",
                SHIFT_IS_ST: !1,
                RULER_MARGIN: 6
            }, _ChartUtils.constants.keyEvent = {
                DELETE: 46,
                RETURN: 13,
                SPACE: 32,
                SHIFT: 16,
                CTRL: 17,
                isCombineKey: function(keyValue) {
                    return keyValue === _ChartUtils.constants.keyEvent.SHIFT || keyValue === _ChartUtils.constants.keyEvent.CTRL;
                }
            }, _ChartUtils.constants.ngc = {
                enum: {
                    ELS_INVALID: -1,
                    ELS_NORMAL: 0,
                    ELS_FULL: 1,
                    ELS_VOLUME: 2,
                    ELS_KAGI: 3,
                    ELS_RENKO: 4,
                    ELS_TLB: 5,
                    ELS_PNF: 6,
                    ELS_REVC: 7,
                    ELS_NUMBER: 8,
                    ELS_AV: 9,
                    ELS_COUNT: 10,
                    ECTS_INIT: 0,
                    ECTS_CHANGE: 1,
                    ECTS_UPDATE: 2,
                    ECDS_NORMAL: 0,
                    ECDS_FULL: 1,
                    ECDS_VOLUME: 2,
                    ECDS_COUNT: 3,
                    ELDS_RESTORE: 0,
                    ELDS_LINEAR: 1,
                    ELDS_REVERSE: 2,
                    ELDS_LOG: 3,
                    ELDS_COUNT: 4
                },
                define: {
                    NGC_FAIL: 0,
                    NGC_SUCCESS: 1,
                    NGC_RULLERX: 2,
                    NGC_RULLERY: 3,
                    NGC_JUL_DATESTART: 19e6,
                    NGC_DATA_LOG: 10
                },
                macro: {
                    NGC_OK: function(x) {
                        return x === _ChartUtils.constants.ngc.NGC_SUCCESS;
                    },
                    __GETSIZE_INT: function(x) {
                        return void 0 === x || null == x ? 0 : x.hasOwnProperty("length") ? x.length : 0;
                    },
                    __GETDTYPE: function(high, low) {
                        return high << 16 | low;
                    },
                    __GETHTYPE: function(dtype) {
                        return dtype >> 16 & 65535;
                    },
                    __GETLTYPE: function(dtype) {
                        return 65535 & dtype;
                    },
                    __GETGTYPE: function(dtype) {
                        return dtype >> 12 & 15;
                    },
                    __GETSTYPE: function(dtype) {
                        return 4095 & dtype;
                    },
                    __GETTMARK: function(dtype) {
                        return 255 & dtype;
                    },
                    __GETTNUM: function(dtype) {
                        return dtype >> 8 & 16777215;
                    },
                    __GETTFLAG: function(num, mark) {
                        return num << 8 | mark;
                    }
                }
            }, _ChartUtils.constants.ngcl = {
                enum: {
                    EUS_UPDATE_IQ: 0,
                    EUS_UPDATE_RT: 1,
                    EUS_RESIZE: 2,
                    EUS_ZOOM: 3,
                    EUS_SCROLL: 4,
                    EUS_OBJECT_MOVE: 5,
                    EUS_CHANGE_LAYOUT: 6,
                    EUS_ADD_SERIES: 7,
                    EUS_YDIR_MOVE: 8,
                    EUS_COUNT: 9
                },
                define: {
                    NGCL_AXIS_RATE1: .33,
                    NGCL_AXIS_RATE2: .6
                }
            }, _ChartUtils.constants.keywords = {
                defaults: {
                    price: "Price",
                    period: "Period",
                    method: "Method",
                    subPrice: "SubPrice"
                },
                price: {
                    ymd: "ymd",
                    hms: "hms",
                    date: "ymd",
                    time: "hms",
                    close: "close",
                    c: "close",
                    open: "open",
                    o: "open",
                    high: "high",
                    h: "high",
                    low: "low",
                    l: "low",
                    volume: "volume",
                    vol: "volume",
                    v: "volume",
                    amount: "amount",
                    amt: "amount",
                    a: "amount",
                    openInterest: "oi",
                    oi: "oi",
                    open_interest: "oi",
                    typical: "typical",
                    t: "typical",
                    weight: "weight",
                    weighted: "weight",
                    w: "weight"
                },
                indicator: {
                    simple: "simple",
                    s: "simple",
                    exponent: "exponential",
                    exponential: "exponential",
                    exp: "exponential",
                    e: "exponential",
                    weight: "weight",
                    weighted: "weight",
                    w: "weight"
                }
            }, _ChartUtils.constants.indicatorCodes = {}, _ChartUtils.constants.indicatorGroups = {
                trend: {
                    name: "Trend",
                    display: "",
                    indicators: []
                },
                oscillator: {
                    name: "Oscillator",
                    display: "",
                    indicators: []
                }
            }, _ChartUtils.constants.indicatorColors = {
                baseline: "#FE7C7C"
            }, _ChartUtils.constants.indicators = [], _ChartUtils.constants.trendLineCodes = {
                _prefix: "TL",
                pointer: "TL0000",
                trendLine: "TL0004",
                horzLine: "TL0002",
                vertLine: "TL4099",
                crossLine: "TL4128",
                rectangle: "TL0006",
                triangle: "TL0007",
                text: "TL0009",
                trendLineByAngle: "TL0020",
                fiboArc: "TL0013",
                fiboFan: "TL0014",
                fiboRetracement: "TL0015",
                fiboTimezone: "TL4112",
                ganFanUp: "TL0033",
                ganFanDown: "TL0034",
                circle: "TL0035",
                tooltipText: "TL0090",
                doubleTrendline: "TL0091",
                deleteOne: "TL9990",
                deleteAll: "TL9999",
                deleteOneRepeat: "TL9991",
                crossHair: "TL0001",
                orderLine: "OL0002"
            }, _ChartUtils.constants.trendLineDefault = {
                lineStyle: 0,
                lineWeight: 1,
                lineColor: "#EE687B",
                fill: !1,
                fillColor: "#EE687B",
                text: "Text"
            }, _ChartUtils.constants.trendLines = [ {
                tool: !0,
                code: _ChartUtils.constants.trendLineCodes.pointer,
                display: "Select",
                image: _ChartUtils.constants.trendLineCodes.pointer
            }, {
                code: _ChartUtils.constants.trendLineCodes.trendLine,
                display: "Trend Line",
                image: _ChartUtils.constants.trendLineCodes.trendLine,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.horzLine,
                display: "Horizontal Line",
                image: _ChartUtils.constants.trendLineCodes.horzLine,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.vertLine,
                display: "Vertical Line",
                image: _ChartUtils.constants.trendLineCodes.vertLine,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.crossLine,
                display: "Cross Line",
                image: _ChartUtils.constants.trendLineCodes.crossLine,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.rectangle,
                display: "Rectangle",
                image: _ChartUtils.constants.trendLineCodes.rectangle,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !0,
                    fillColor: "#FFFFFF"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.triangle,
                display: "Triangle",
                image: _ChartUtils.constants.trendLineCodes.triangle,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !0,
                    fillColor: "#FFFFFF"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.trendLineByAngle,
                display: "Angle",
                image: _ChartUtils.constants.trendLineCodes.trendLineByAngle,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.fiboArc,
                display: "Fib Arc",
                image: _ChartUtils.constants.trendLineCodes.fiboArc,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.fiboFan,
                display: "Fib Fan",
                image: _ChartUtils.constants.trendLineCodes.fiboFan,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.fiboRetracement,
                display: "Fib Retracement",
                image: _ChartUtils.constants.trendLineCodes.fiboRetracement,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.fiboTimezone,
                display: "Fib TimeZone",
                image: _ChartUtils.constants.trendLineCodes.fiboTimezone,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.ganFanUp,
                display: "Gan Fan(Up)",
                image: _ChartUtils.constants.trendLineCodes.ganFanUp,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.ganFanDown,
                display: "Gan Fan(Down)",
                image: _ChartUtils.constants.trendLineCodes.ganFanDown,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                tool: !0,
                code: _ChartUtils.constants.trendLineCodes.deleteOne,
                display: "Delete",
                image: _ChartUtils.constants.trendLineCodes.deleteOne
            }, {
                tool: !0,
                code: _ChartUtils.constants.trendLineCodes.deleteAll,
                display: "Delete All",
                image: _ChartUtils.constants.trendLineCodes.deleteAll
            }, {
                code: _ChartUtils.constants.trendLineCodes.text,
                display: "Text",
                image: _ChartUtils.constants.trendLineCodes.text,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !0,
                    fillColor: "#FFFFFF"
                },
                textInfo: {
                    text: _ChartUtils.constants.trendLineDefault.text
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.doubleTrendline,
                display: "Channel Line",
                image: _ChartUtils.constants.trendLineCodes.doubleTrendline,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.tooltipText,
                display: "Tooltip",
                image: _ChartUtils.constants.trendLineCodes.text,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !0,
                    fillColor: "#FFFFFF"
                },
                textInfo: {
                    text: _ChartUtils.constants.trendLineDefault.text
                }
            }, {
                code: _ChartUtils.constants.trendLineCodes.orderLine,
                display: "Order Line",
                image: _ChartUtils.constants.trendLineCodes.horzLine,
                styles: {
                    lineStyle: 0,
                    lineWeight: 1,
                    lineColor: "#EE687B",
                    fill: !1,
                    fillColor: "#EE687B"
                }
            }, {
                tool: !0,
                code: _ChartUtils.constants.trendLineCodes.deleteOneRepeat,
                display: "Delete",
                image: _ChartUtils.constants.trendLineCodes.deleteOne
            }, {
                tool: !0,
                code: _ChartUtils.constants.trendLineCodes.crossHair,
                display: "Crosshair",
                image: _ChartUtils.constants.trendLineCodes.crossLine
            } ], _ChartUtils.constants.chartTypeCode = {
                candle: "Candle",
                line: "Line",
                bar_ohlc: "Bar",
                bar_hlc: "Bar(HLC)",
                threeLineBreak: "TLB",
                reverseCycleLine: "RCL",
                pointAndFigure: "P&F",
                transCandle: "TransCandle",
                longVolume: "LongVolume",
                equiVolume: "EquiVolume",
                averageCandle: "AverageCandle",
                kagi: "Kagi",
                renko: "Renko",
                compareChart: "CompareChart"
            }, _ChartUtils.constants.chartType = [ {
                code: _ChartUtils.constants.chartTypeCode.candle,
                display: "",
                valid: !0,
                numCode: _ChartUtils.constants.ngc.enum.ELS_NORMAL
            }, {
                code: _ChartUtils.constants.chartTypeCode.transCandle,
                display: "()",
                valid: !0,
                numCode: _ChartUtils.constants.ngc.enum.ELS_NORMAL
            }, {
                code: _ChartUtils.constants.chartTypeCode.bar_ohlc,
                display: "()",
                valid: !0,
                numCode: _ChartUtils.constants.ngc.enum.ELS_NORMAL
            }, {
                code: _ChartUtils.constants.chartTypeCode.bar_hlc,
                display: "()",
                valid: !0,
                numCode: _ChartUtils.constants.ngc.enum.ELS_NORMAL
            }, {
                code: _ChartUtils.constants.chartTypeCode.line,
                display: "",
                valid: !0,
                numCode: _ChartUtils.constants.ngc.enum.ELS_NORMAL
            }, {
                code: _ChartUtils.constants.chartTypeCode.longVolume,
                display: "",
                valid: !1,
                numCode: _ChartUtils.constants.ngc.enum.ELS_VOLUME
            }, {
                code: _ChartUtils.constants.chartTypeCode.equiVolume,
                display: "",
                valid: !1,
                numCode: _ChartUtils.constants.ngc.enum.ELS_VOLUME
            }, {
                code: _ChartUtils.constants.chartTypeCode.averageCandle,
                display: "",
                valid: !0,
                numCode: _ChartUtils.constants.ngc.enum.ELS_NORMAL
            }, {
                code: _ChartUtils.constants.chartTypeCode.pointAndFigure,
                display: "P&F",
                valid: !1,
                numCode: _ChartUtils.constants.ngc.enum.ELS_PNF
            }, {
                code: _ChartUtils.constants.chartTypeCode.kagi,
                display: "",
                valid: !1,
                numCode: _ChartUtils.constants.ngc.enum.ELS_KAGI
            }, {
                code: _ChartUtils.constants.chartTypeCode.renko,
                display: "",
                valid: !1,
                numCode: _ChartUtils.constants.ngc.enum.ELS_RENKO
            }, {
                code: _ChartUtils.constants.chartTypeCode.threeLineBreak,
                display: "()",
                valid: !1,
                numCode: _ChartUtils.constants.ngc.enum.ELS_TLB
            }, {
                code: _ChartUtils.constants.chartTypeCode.reverseCycleLine,
                display: "",
                valid: !1,
                numCode: _ChartUtils.constants.ngc.enum.ELS_REVC
            }, {
                code: _ChartUtils.constants.chartTypeCode.compareChart,
                display: "",
                valid: !1,
                numCode: _ChartUtils.constants.ngc.enum.ELS_NORMAL
            } ], _ChartUtils.hitTest = {}, _ChartUtils.hitTest.config = {
                size: 7,
                color: "#aaaaaa"
            }, _ChartUtils.hitTest.didHitTest = function(mctx, posval) {
                var ratio = _ChartUtils.didCalcRatioOfContext2D(), __posval = _ChartUtils.didClone(posval);
                __posval.XPos = Math.round(__posval.XPos * ratio), __posval.YPos = Math.round(__posval.YPos * ratio);
                var imageData, size = _ChartUtils.hitTest.config.size || 3, ratio = _ChartUtils.didCalcRatioOfContext2D();
                size = Math.round(ratio * size), size = Math.max(size, 3);
                var __xPos = __posval.XPos - size, __yPos = __posval.YPos - size, __size = 2 * size + 1;
                imageData = mctx.getImageData(__xPos, __yPos, __size, __size);
                for (var nLen = parseInt(imageData.data.length / 4), __ii = 0; __ii < nLen; __ii++) if (imageData.data[4 * __ii + 3] > 0) return !0;
                return !1;
            }, _ChartUtils.hitTest.prepareTools = function(rect, posvalHit, canvas, context) {
                return new function(rect, posvalHit, canvas, context) {
                    var _self = this;
                    this.m_rect = _ChartUtils.didClone(rect), this.m_canvas = canvas, this.m_context = context, 
                    this.m_bFlag = !1, this.m_posvalHit = _ChartUtils.didClone(posvalHit), void 0 !== _self.m_canvas && null != _self.m_canvas || (_self.m_canvas = document.createElement("canvas"), 
                    _self.m_context = _self.m_canvas.getContext("2d"), _self.m_bFlag = !0), this.willBeHitTest = function(isFirst) {
                        _self.m_canvas.left = 0, _self.m_canvas.top = 0, _self.m_canvas.width = _self.m_rect.width, 
                        _self.m_canvas.height = _self.m_rect.height, _self.m_context.clearRect(0, 0, _self.m_canvas.width, _self.m_canvas.height), 
                        !0 === isFirst && _self.m_context.translate(.5, .5);
                    }, this.didHitTest = function() {
                        return _ChartUtils.hitTest.didHitTest(_self.m_context, _self.m_posvalHit);
                    }, this.closeHitTest = function(isEnd) {
                        !0 === isEnd && _self.m_context.translate(-.5, -.5), _self.m_context.clearRect(0, 0, _self.m_canvas.width, _self.m_canvas.height), 
                        !0 === _self.m_bFlag && (_self.m_canvas = {}, _self.m_context = {}, _self.m_rect = {}, 
                        _self.m_posvalHit = {});
                    };
                }(rect, posvalHit, canvas, context);
            }, _ChartUtils.timeZone = {}, _ChartUtils.timeZone.oneDayUnit = 1440, _ChartUtils.timeZone.getDefaultDisplayString = function(timeType) {
                return timeType > _ChartUtils.constants.timeType.hour ? "9999/99/99" : "99:99";
            }, _ChartUtils.timeZone.convertTimeunitToDatetime = function(timeUnit) {
                var result = {
                    date: 0,
                    time: 0
                }, xDatetime = new Date(1e3 * timeUnit);
                return result.date = _ChartUtils.dateTime.convertDateToNumber(xDatetime), result.time = _ChartUtils.dateTime.convertTimeToNumber(xDatetime), 
                result;
            }, _ChartUtils.timeZone.convertDatetimeToTimeunit = function(argDate, argTime) {
                return _ChartUtils.dateTime.convertNumberToDate(argDate, argTime).getTime() / 1e3;
            }, _ChartUtils.timeZone.convertDatetimeStringFromPriceData = function(stPrice, timeType) {
                try {
                    var date = stPrice.ymd, time = stPrice.hms, ret = _ChartUtils.dateTime.convertNumberToDateString(date, _ChartUtils.dateTime.dateFormat1);
                    return timeType < _ChartUtils.constants.timeType.day && (ret += " " + _ChartUtils.dateTime.convertNumberToTimeString(time, _ChartUtils.dateTime.timeFormat1)), 
                    ret;
                } catch (e) {
                    console.error(e);
                }
                return "";
            }, _ChartUtils.timeZone.calculateTimezoneUnit = function(businessDate, timeZone) {
                timeZone.unit = {};
                var baseDate = businessDate + timeZone.dateOffset;
                return timeZone.unit.begin = _ChartUtils.timeZone.convertDatetimeToTimeunit(baseDate, timeZone.begin), 
                timeZone.unit.limit = _ChartUtils.timeZone.convertDatetimeToTimeunit(baseDate, timeZone.limit), 
                timeZone.unit.final = _ChartUtils.timeZone.convertDatetimeToTimeunit(baseDate, timeZone.final), 
                !0;
            }, _ChartUtils.timeZone.didGetTimeGapForTimezoneUnitAs = function(timeType, timeGap) {
                return timeType === _ChartUtils.constants.timeType.hour ? 60 * timeGap * 60 : timeType === _ChartUtils.constants.timeType.minute ? 60 * timeGap : timeType === _ChartUtils.constants.timeType.day ? 60 * timeGap * 60 * 24 : timeType === _ChartUtils.constants.timeType.week ? 60 * timeGap * 60 * 24 * 7 : timeType === _ChartUtils.constants.timeType.month ? 60 * timeGap * 60 * 24 * 30 : 1;
            }, _ChartUtils.timeZone.didCheckTimeType = function(timeType) {
                var isTick = !1, isDwm = !1;
                return timeType === _ChartUtils.constants.timeType.tick ? (isTick = !0, isDwm = !1) : timeType === _ChartUtils.constants.timeType.minute || timeType === _ChartUtils.constants.timeType.hour ? (isTick = !1, 
                isDwm = !1) : (isTick = !1, isDwm = !0), {
                    isTick: isTick,
                    isDwm: isDwm
                };
            }, _ChartUtils.timeZone.didAdjustDatetimeUnitAsTimezone = function(dateTimeUnit, timeZone, timeType, timeGap) {
                if (timeType !== _ChartUtils.constants.timeType.hour && timeType !== _ChartUtils.constants.timeType.minute) return dateTimeUnit;
                var timeGapForTimezoneUnit = _ChartUtils.timeZone.didGetTimeGapForTimezoneUnitAs(timeType, timeGap), beginTimezoneUnit = timeZone.unit.begin, finalTimezoneUnit = timeZone.unit.final, diff = dateTimeUnit - beginTimezoneUnit, quotient = parseInt(diff / timeGapForTimezoneUnit), adjustedDatetimeUnit = (parseInt(diff % timeGapForTimezoneUnit), 
                beginTimezoneUnit + quotient * timeGapForTimezoneUnit);
                if (adjustedDatetimeUnit > timeZone.unit.final) {
                    diff = finalTimezoneUnit - beginTimezoneUnit, quotient = parseInt(diff / timeGapForTimezoneUnit), 
                    parseInt(diff % timeGapForTimezoneUnit);
                    adjustedDatetimeUnit = beginTimezoneUnit + (quotient + 0) * timeGapForTimezoneUnit;
                }
                return adjustedDatetimeUnit;
            }, _ChartUtils.dateTime = {}, _ChartUtils.dateTime.timeType = [ "tick", "minute", "hour", "day", "week", "month" ], 
            _ChartUtils.dateTime.weekDays = {
                sunday: 0,
                monday: 1,
                tuesday: 2,
                wednesday: 3,
                thursday: 4,
                friday: 5,
                saterday: 6
            }, _ChartUtils.dateTime.dateTimeFormat1 = "YYYYMMDDhhmmss", _ChartUtils.dateTime.dateFormat1 = "YYYY/MM/DD", 
            _ChartUtils.dateTime.timeFormat1 = "hh:mm", _ChartUtils.dateTime.formatDateString = function(strDate, format) {
                var formatStr = new String(format);
                return formatStr || (formatStr = "YYYY-MM-DD"), formatStr = formatStr.replace(/YYYY/g, strDate.slice(0, 4)), 
                formatStr = formatStr.replace(/MM/g, strDate.slice(4, 6)), formatStr = formatStr.replace(/DD/g, strDate.slice(6, 8));
            }, _ChartUtils.dateTime.formatTimeString = function(strTime, format) {
                var formatStr = new String(format);
                return formatStr || (formatStr = "hh:mm:ss"), formatStr = formatStr.replace(/hh/g, strTime.slice(0, 2)), 
                formatStr = formatStr.replace(/mm/g, strTime.slice(2, 4)), formatStr = formatStr.replace(/ss/g, strTime.slice(4, 6));
            }, _ChartUtils.dateTime.convertNumberToTimeString = function(argTime, format) {
                var hour = parseInt(argTime / 1e4), minute = parseInt(argTime / 100) % 100, second = parseInt(argTime % 100), time_str = _ChartUtils.number.formatAsfillSize(hour, "0", 2) + _ChartUtils.number.formatAsfillSize(minute, "0", 2) + _ChartUtils.number.formatAsfillSize(second, "0", 2);
                return format && (time_str = _ChartUtils.dateTime.formatTimeString(time_str, format)), 
                time_str;
            }, _ChartUtils.dateTime.convertNumberToDateString = function(argTime, format) {
                var year = parseInt(argTime / 1e4), month = parseInt(argTime / 100) % 100, day = parseInt(argTime % 100), date_str = _ChartUtils.number.formatAsfillSize(year, "0", 4) + _ChartUtils.number.formatAsfillSize(month, "0", 2) + _ChartUtils.number.formatAsfillSize(day, "0", 2);
                return format && (date_str = _ChartUtils.dateTime.formatDateString(date_str, format)), 
                date_str;
            }, _ChartUtils.dateTime.convertNumberToDate = function(argDate, argTime) {
                var hour = null, minute = null, second = null, year = parseInt(argDate / 1e4), month = parseInt(argDate / 100) % 100 - 1, day = parseInt(argDate % 100);
                return void 0 !== argTime && null != argTime && (hour = parseInt(argTime / 1e4), 
                minute = parseInt(argTime / 100) % 100, second = parseInt(argTime % 100)), new Date(year, month, day, hour, minute, second);
            }, _ChartUtils.dateTime.convertNumberToDatetime = function(argDate, argTime) {
                var dateTime = {
                    year: 0,
                    month: 0,
                    day: 0,
                    hour: 0,
                    minute: 0,
                    second: 0
                };
                return dateTime.year = parseInt(argDate / 1e4), dateTime.month = parseInt(argDate / 100) % 100 - 1, 
                dateTime.day = parseInt(argDate % 100), void 0 !== argTime && null != argTime && (dateTime.hour = parseInt(argTime / 1e4), 
                dateTime.minute = parseInt(argTime / 100) % 100, dateTime.second = parseInt(argTime % 100)), 
                dateTime;
            }, _ChartUtils.dateTime.convertDateToNumber = function(argDate) {
                if ("object" == typeof argDate) {
                    return 1e4 * argDate.getFullYear() + 100 * (argDate.getMonth() + 1) + argDate.getDate();
                }
            }, _ChartUtils.dateTime.convertTimeToNumber = function(argDate) {
                if ("object" == typeof argDate) {
                    return 1e4 * argDate.getHours() + 100 * argDate.getMinutes() + argDate.getSeconds();
                }
            }, _ChartUtils.dateTime.convertStringToDate = function(strDate, format) {
                try {
                    if (void 0 === strDate || void 0 == strDate) return;
                    var time, dateData = strDate.slice(0, 8), timeData = strDate.slice(8), date = parseInt(dateData);
                    return timeData.length < 6 ? timeData = null : time = parseInt(timeData), _ChartUtils.dateTime.convertNumberToDate(date, time);
                } catch (e) {
                    console.error(e);
                }
            }, _ChartUtils.dateTime.convertNumberDatetimeToTimelineData = function(argDate, argTime) {
                return _ChartUtils.dateTime.convertNumberToDateString(argDate) + _ChartUtils.dateTime.convertNumberToTimeString(argTime);
            }, _ChartUtils.dateTime.formatDate = function(date, format) {
                if (format || (format = "YYYY-MM-DD hh:mm:ss.SSS"), format = format.replace(/YYYY/g, date.getFullYear()), 
                format = format.replace(/MM/g, ("0" + (date.getMonth() + 1)).slice(-2)), format = format.replace(/DD/g, ("0" + date.getDate()).slice(-2)), 
                format = format.replace(/hh/g, ("0" + date.getHours()).slice(-2)), format = format.replace(/mm/g, ("0" + date.getMinutes()).slice(-2)), 
                format = format.replace(/ss/g, ("0" + date.getSeconds()).slice(-2)), format.match(/S/g)) for (var milliSeconds = ("00" + date.getMilliseconds()).slice(-3), length = format.match(/S/g).length, i = 0; i < length; i++) format = format.replace(/S/, milliSeconds.substring(i, i + 1));
                return format;
            }, _ChartUtils.dateTime.addDate = function(date, num, interval) {
                switch (interval) {
                  case "year":
                    date.setFullYear(date.getFullYear() + num);
                    break;

                  case "month":
                    date.setMonth(date.getMonth() + num);
                    break;

                  case "hour":
                    date.setHours(date.getHours() + num);
                    break;

                  case "minute":
                    date.setMinutes(date.getMinutes() + num);
                    break;

                  case "second":
                    date.setSeconds(date.getSeconds() + num);
                    break;

                  case "week":
                    date.setDate(date.getDate() + 7 * num);
                    break;

                  default:
                    date.setDate(date.getDate() + num);
                }
                return date;
            }, _ChartUtils.dateTime.addDatetime = function(dateTime, num, interval) {
                var xDatetime;
                return xDatetime = "string" == typeof dateTime ? _ChartUtils.dateTime.convertStringToDate(dateTime) : _ChartUtils.dateTime.convertStringToDate(String(dateTime)), 
                _ChartUtils.dateTime.addDate(xDatetime, num, interval);
            }, _ChartUtils.dateTime.getDateOfTheWeekAtDate = function(date, week) {
                void 0 !== week && null != week || (week = _ChartUtils.dateTime.weekDays.saterday);
                var week = Math.min(_ChartUtils.dateTime.weekDays.saterday, Math.max(_ChartUtils.dateTime.weekDays.sunday, week)), weekOfDate = date.getDay(), diff = week - weekOfDate;
                return _ChartUtils.dateTime.addDate(date, diff);
            }, _ChartUtils.dateTime.getDateOfTheMonthAtDate = function(date) {
                var year = date.getFullYear(), month = date.getMonth();
                return new Date(year, month, 1);
            }, _ChartUtils.dateTime.dateDiff = function(date1, date2, interval, round) {
                var diff = date2.getTime() - date1.getTime();
                switch (interval) {
                  case "year":
                    var d1 = new Date(date1.getTime()), d2 = new Date(date2.getTime()), i = 0;
                    return !0 === round && (d1.setYear(0), d2.setYear(0), i = diff >= 0 ? d2.getTime() < d1.getTime() ? -1 : 0 : d2.getTime() <= d1.getTime() ? 0 : 1), 
                    date2.getFullYear() - date1.getFullYear() + i;

                  case "month":
                    var d1 = new Date(date1.getTime()), d2 = new Date(date2.getTime()), i = 0;
                    return !0 === round && (d1.setYear(0), d1.setMonth(0), d2.setYear(0), d2.setMonth(0), 
                    i = diff >= 0 ? d2.getTime() < d1.getTime() ? -1 : 0 : d2.getTime() <= d1.getTime() ? 0 : 1), 
                    12 * date2.getFullYear() + date2.getMonth() - (12 * date1.getFullYear() + date1.getMonth()) + i;

                  case "hour":
                    return parseInt(diff / 36e5);

                  case "minute":
                    return parseInt(diff / 6e4);

                  case "second":
                    return parseInt(diff / 1e3);

                  case "week":
                    return parseInt(diff / 6048e5);

                  default:
                    return parseInt(diff / 864e5);
                }
            }, _ChartUtils.scale = {}, _ChartUtils.scale.constants = {
                NGC_SCALE_FULL: -1,
                NGC_SCALE_SCREEN: 0,
                NGC_SCALE_USER: 1
            }, _ChartUtils.scale.unit = {
                minMaxScreen: {
                    minValue: _ChartUtils.constants.default.DEFAULT_WRONG_VALUE,
                    minIndex: -1,
                    maxValue: -1 * _ChartUtils.constants.default.DEFAULT_WRONG_VALUE,
                    maxIndex: -1,
                    diff: -1,
                    ratio: 0
                },
                minMaxTotal: {
                    minValue: _ChartUtils.constants.default.DEFAULT_WRONG_VALUE,
                    minIndex: -1,
                    maxValue: -1 * _ChartUtils.constants.default.DEFAULT_WRONG_VALUE,
                    maxIndex: -1,
                    diff: -1,
                    ratio: 0
                }
            }, _ChartUtils.scale.info = {
                previous: _ChartUtils.didClone(_ChartUtils.scale.unit),
                current: _ChartUtils.didClone(_ChartUtils.scale.unit)
            }, _ChartUtils.scale.didAdjustReverseMinMax = function(scaleUnit) {
                void 0 !== scaleUnit && null != scaleUnit && (_ChartUtils.scale.didResetMinMax(scaleUnit.minMaxScreen, !0, 1e4), 
                _ChartUtils.scale.didResetMinMax(scaleUnit.minMaxTotal, !0, 1e4));
            }, _ChartUtils.scale.didCreateScaleInfo = function() {
                return _ChartUtils.didClone(_ChartUtils.scale.info);
            }, _ChartUtils.scale.didCreateScaleUnit = function() {
                return _ChartUtils.didClone(_ChartUtils.scale.unit);
            }, _ChartUtils.scale.didResetMinMax = function(argMinMax, toZero, toLimit) {
                void 0 !== argMinMax && null != argMinMax && (!0 === toZero ? (argMinMax.minValue = 0, 
                argMinMax.minIndex = -1, argMinMax.maxValue = 0, argMinMax.maxIndex = -1, argMinMax.diff = 0, 
                argMinMax.ratio = 0, "number" == typeof toLimit && toLimit > 0 && (argMinMax.diff = argMinMax.maxValue = Math.min(1e4, toLimit))) : (argMinMax.minValue = _ChartUtils.constants.default.DEFAULT_WRONG_VALUE, 
                argMinMax.minIndex = -1, argMinMax.maxValue = -1 * _ChartUtils.constants.default.DEFAULT_WRONG_VALUE, 
                argMinMax.maxIndex = -1, argMinMax.diff = -1, argMinMax.ratio = 0));
            }, _ChartUtils.scale.didResetScaleUnit = function(scaleUnit, toZero) {
                void 0 !== scaleUnit && null != scaleUnit && (_ChartUtils.scale.didResetMinMax(scaleUnit.minMaxScreen), 
                _ChartUtils.scale.didResetMinMax(scaleUnit.minMaxTotal));
            }, _ChartUtils.scale.didBackupScaleInfo = function(argScaleInfo) {
                void 0 !== argScaleInfo && null != argScaleInfo && void 0 !== argScaleInfo.previous && null != argScaleInfo.previous && (argScaleInfo.previous = _ChartUtils.didClone(argScaleInfo.current));
            }, _ChartUtils.scale.didCalcDiff = function(argMax, argMin, isOpt) {
                return !0 !== isOpt ? argMax + 1 - argMin : argMax - argMin;
            }, _ChartUtils.scale.didCalcScaleUnit = function(argScaleUnit) {
                void 0 !== argScaleUnit && null != argScaleUnit && (argScaleUnit.minMaxScreen.diff = _ChartUtils.scale.didCalcDiff(argScaleUnit.minMaxScreen.maxValue, argScaleUnit.minMaxScreen.minValue), 
                argScaleUnit.minMaxTotal.diff = _ChartUtils.scale.didCalcDiff(argScaleUnit.minMaxTotal.maxValue, argScaleUnit.minMaxTotal.minValue));
            }, _ChartUtils.dataType = {}, _ChartUtils.dataType.range = {
                location: 0,
                length: 0
            }, _ChartUtils.dataType.didGetRangeObject = function() {
                _ChartUtils.didClone(_ChartUtils.dataType.range);
            }, _ChartUtils.dataType._ST_MINMAX_DATA = {
                nMaxIdx: 0,
                nMinIdx: 0,
                dMax: 0,
                dMin: 0
            }, _ChartUtils;
        };
        global.WGC_CHART ? global.WGC_CHART.chartUtil = loadModule(global.WGC_CHART.canvas2DUtil) : module.exports = loadModule(__webpack_require__(1));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function() {
            var exports = {};
            exports.penstyle = {
                solid: 0,
                dash: 1,
                dot: 2,
                dashdot: 3,
                dashdotdot: 4
            };
            var __didAdjustScale = function(context) {
                var devicePixelRatio = window.devicePixelRatio || 1, backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1, ratio = devicePixelRatio / backingStoreRatio;
                context.scale(ratio, ratio);
            }, __measuretext_cache__ = [], _MeasureText = function(text, bold, font, size) {
                var str = text + ":" + bold + ":" + font + ":" + size;
                if (void 0 !== __measuretext_cache__ && null != __measuretext_cache__ && "object" == typeof __measuretext_cache__ && __measuretext_cache__[str]) return __measuretext_cache__[str];
                var div = document.createElement("DIV");
                div.innerHTML = text, div.style.position = "absolute", div.style.top = "-100px", 
                div.style.left = "-100px", div.style.fontFamily = font, div.style.fontWeight = bold ? "bold" : "normal", 
                div.style.fontSize = "string" == typeof size ? size : size + "pt", document.body.appendChild(div);
                var size = [ div.offsetWidth, div.offsetHeight ];
                return document.body.removeChild(div), "object" != typeof __measuretext_cache__ && (__measuretext_cache__ = []), 
                __measuretext_cache__[str] = size, size;
            }, _didSetPenStyle = function(context, lineColor, lineWidth, lineStyle) {
                if (void 0 !== context && null != context) {
                    if (context.lineCap = "round", void 0 !== lineStyle && null != lineStyle || (lineStyle = exports.penstyle.solid), 
                    void 0 !== lineStyle && null != lineStyle) {
                        var nPenStyle = exports.penstyle.solid;
                        if ("string" == typeof lineStyle) {
                            var strStyle = lineStyle.toLowerCase();
                            !0 === exports.penstyle.hasOwnProperty(strStyle) && (nPenStyle = exports.penstyle[strStyle]);
                        } else {
                            var style = parseInt(lineStyle);
                            style >= exports.penstyle.solid && style <= exports.penstyle.dashdotdot && (nPenStyle = style);
                        }
                        var nWeight = 1;
                        void 0 !== lineWidth && null != lineWidth && (context.lineWidth = lineWidth, nWeight = lineWidth), 
                        nWeight > 1 && (context.lineCap = "butt");
                        var nDash = 5 * nWeight, nDashSpace = nDash, nDot = nWeight, nDotSpace = nDot + 1;
                        nPenStyle === exports.penstyle.dash ? context.setLineDash([ nDash, nDashSpace ]) : nPenStyle === exports.penstyle.dot ? context.setLineDash([ nDot, nDotSpace ]) : nPenStyle === exports.penstyle.dashdot ? context.setLineDash([ nDash, nDashSpace, nDot, nDashSpace ]) : nPenStyle === exports.penstyle.dashdotdot && context.setLineDash([ nDash, nDashSpace, nDot, nDashSpace, nDot, nDashSpace ]);
                    }
                    void 0 !== lineColor && null != lineColor && (context.strokeStyle = lineColor);
                }
            };
            exports.Rectangle = function(drawParam) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context) {
                        var __rect = drawParam.rect;
                        __context.save(), __didAdjustScale(__context), __context.beginPath(), __context.rect(__rect.x, __rect.y, __rect.width, __rect.height), 
                        void 0 !== drawParam.fillAlpha && null != drawParam.fillAlpha && (__context.globalAlpha = drawParam.fillAlpha), 
                        void 0 !== drawParam.fillColor && null != drawParam.fillColor && (__context.fillStyle = drawParam.fillColor, 
                        __context.fill()), _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                        __context.stroke(), __context.restore();
                    }
                }
            }, exports.Ellipse = function(drawParam) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context) {
                        var __rect = drawParam.rect, __radiusVert = __rect.height / 2, __radiusHorz = __rect.width / 2, __rectCenter = {
                            x: __rect.x + __radiusHorz,
                            y: __rect.y + __radiusVert
                        };
                        __context.save(), __didAdjustScale(__context), __context.beginPath(), __context.ellipse(__rectCenter.x, __rectCenter.y, __radiusHorz, __radiusVert, 0, 0, 2 * Math.PI), 
                        void 0 !== drawParam.fillAlpha && null != drawParam.fillAlpha && (__context.globalAlpha = drawParam.fillAlpha), 
                        void 0 !== drawParam.fillColor && null != drawParam.fillColor && (__context.fillStyle = drawParam.fillColor, 
                        __context.fill()), _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                        __context.stroke(), __context.restore();
                    }
                }
            }, exports.Arc = function(drawParam) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context) {
                        var bFill = !1;
                        void 0 !== drawParam.fillColor && null != drawParam.fillColor && (bFill = !0), __context.save(), 
                        __didAdjustScale(__context), __context.beginPath(), __context.lineWidth = drawParam.lineWidth, 
                        __context.strokeStyle = drawParam.lineColor, !0 === bFill && __context.moveTo(drawParam.pt.x, drawParam.pt.y), 
                        "number" == typeof drawParam.degree ? __context.arc(drawParam.pt.x, drawParam.pt.y, drawParam.radius, 0, Math.PI / 180 * drawParam.degree, drawParam.anticlockwise) : __context.arc(drawParam.pt.x, drawParam.pt.y, drawParam.radius, Math.PI / 180 * drawParam.degree.from, Math.PI / 180 * drawParam.degree.to, drawParam.anticlockwise), 
                        !0 === bFill && __context.closePath(), void 0 !== drawParam.fillAlpha && null != drawParam.fillAlpha && (__context.globalAlpha = drawParam.fillAlpha), 
                        void 0 !== drawParam.fillColor && null != drawParam.fillColor && (__context.fillStyle = drawParam.fillColor, 
                        __context.fill()), _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                        __context.stroke(), __context.restore();
                    }
                }
            }, exports.Circle = function(drawParam) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    void 0 != __context && null != __context && (__context.save(), __didAdjustScale(__context), 
                    __context.beginPath(), __context.lineWidth = drawParam.lineWidth, __context.strokeStyle = drawParam.lineColor, 
                    __context.arc(drawParam.pt.x, drawParam.pt.y, drawParam.radius, 0, 2 * Math.PI, !0), 
                    void 0 !== drawParam.fillAlpha && null != drawParam.fillAlpha && (__context.globalAlpha = drawParam.fillAlpha), 
                    void 0 !== drawParam.fillColor && null != drawParam.fillColor && (__context.fillStyle = drawParam.fillColor, 
                    __context.fill()), _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                    __context.stroke(), __context.restore());
                }
            }, exports.CurvedCircle = function(drawParam) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context) {
                        __context.save(), __didAdjustScale(__context);
                        var __rect = drawParam.rect;
                        __context.rect(__rect.x, __rect.y, __rect.width, __rect.height);
                        var ox = __rect.width / 2 * .5522848, oy = __rect.height / 2 * .5522848, xe = __rect.x + __rect.width, ye = __rect.y + __rect.height, xm = __rect.x + __rect.width / 2, ym = __rect.y + __rect.height / 2;
                        __context.beginPath(), __context.moveTo(__rect.x, ym), __context.bezierCurveTo(__rect.x, ym - oy, xm - ox, __rect.y, xm, __rect.y), 
                        __context.bezierCurveTo(xm + ox, __rect.y, xe, ym - oy, xe, ym), __context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye), 
                        __context.bezierCurveTo(xm - ox, ye, __rect.x, ym + oy, __rect.x, ym), _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                        __context.stroke(), __context.restore();
                    }
                }
            }, exports.Triangle = function(drawParam) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    void 0 != __context && null != __context && (__context.save(), __didAdjustScale(__context), 
                    __context.beginPath(), __context.moveTo(drawParam.pt1.x, drawParam.pt1.y), __context.lineTo(drawParam.pt2.x, drawParam.pt2.y), 
                    __context.lineTo(drawParam.pt3.x, drawParam.pt3.y), __context.closePath(), void 0 !== drawParam.fillAlpha && null != drawParam.fillAlpha && (__context.globalAlpha = drawParam.fillAlpha), 
                    void 0 !== drawParam.fillColor && null != drawParam.fillColor && (__context.fillStyle = drawParam.fillColor, 
                    __context.fill()), _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                    __context.stroke(), __context.restore());
                }
            }, exports.Line = function(drawParam) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    void 0 != __context && null != __context && (__context.save(), __didAdjustScale(__context), 
                    __context.beginPath(), __context.moveTo(drawParam.pt1.x, drawParam.pt1.y), __context.lineTo(drawParam.pt2.x, drawParam.pt2.y), 
                    _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                    __context.stroke(), __context.restore());
                }
            }, exports.Lines = function(drawParam) {
                if (!(void 0 == drawParam || null == drawParam || void 0 === drawParam.pts || null == drawParam.pts || void 0 === drawParam.pts.length || null == drawParam.pts.length || drawParam.pts.length < 2)) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context && void 0 != __context && null != __context) {
                        __context.save(), __didAdjustScale(__context), __context.beginPath();
                        var nCount = drawParam.pts.length, pt1 = drawParam.pts[0];
                        __context.moveTo(pt1.x, pt1.y);
                        for (var ii = 1; ii < nCount; ii++) {
                            var pt2 = drawParam.pts[ii];
                            __context.lineTo(pt2.x, pt2.y);
                        }
                        _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                        __context.stroke(), __context.restore();
                    }
                }
            }, exports.MeasureTextWidth = function(drawParam) {
                if (void 0 == drawParam || null == drawParam) return 0;
                var __context = drawParam.context;
                if (void 0 == __context || null == __context) return 0;
                __context.save(), __context.font = drawParam.font;
                var width = __context.measureText(drawParam.text).width;
                return __context.restore(), width;
            }, exports.MeasureDefaultText = function(context) {
                var xResult = {
                    width: 0,
                    height: 0
                };
                return void 0 === context || null == context ? xResult : (xResult.width = context.measureText("M").width, 
                xResult.height = Math.round(1.5 * xResult.width), xResult);
            }, exports.TextOut = function(drawParam, isMeasure, outRect) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context) {
                        __context.save(), __didAdjustScale(__context), drawParam.clip && (__context.beginPath(), 
                        __context.rect(drawParam.clip.x, drawParam.clip.y, drawParam.clip.x + drawParam.clip.width - 1, drawParam.clip.y + drawParam.clip.height - 1), 
                        __context.clip()), void 0 !== drawParam.textBaseline && null != drawParam.textBaseline ? __context.textBaseline = drawParam.textBaseline : !0 === drawParam.useMultiline || !0 === drawParam.useBox || drawParam.box ? __context.textBaseline = "top" : __context.textBaseline = "middle", 
                        __context.font = drawParam.font;
                        try {
                            var x1CharInfo = exports.MeasureDefaultText(__context), n1CharH = (x1CharInfo.width, 
                            x1CharInfo.height), width = __context.measureText(drawParam.text).width, rect = {
                                x: drawParam.pt.x,
                                y: drawParam.pt.y,
                                width: width,
                                height: n1CharH
                            };
                            __context.fillStyle = drawParam.fillStyle;
                            var arrText = drawParam.text.split("\n"), nMargin = (arrText.length, 3);
                            void 0 !== drawParam.margin && null != drawParam.margin && (nMargin = drawParam.margin);
                            var ptText = {
                                x: drawParam.pt.x + nMargin,
                                y: drawParam.pt.y + nMargin
                            };
                            if (!0 === drawParam.useMultiline) {
                                width = 0;
                                for (var arrText = drawParam.text.split("\n"), nCount = arrText.length, ii = 0; ii < nCount; ii++) {
                                    var text = arrText[ii], textWidth = __context.measureText(text).width;
                                    width = Math.max(width, textWidth), __context.fillText(text, ptText.x, ptText.y), 
                                    ptText.y += n1CharH;
                                }
                                width += 2 * nMargin, rect.width = width, rect.height = nCount * n1CharH + 2 * nMargin;
                            } else __context.fillText(drawParam.text, drawParam.pt.x, drawParam.pt.y), width = __context.measureText(drawParam.text).width, 
                            width += 2 * nMargin, rect.width = width, rect.height = 1 * n1CharH + 2 * nMargin;
                            !0 === drawParam.useBox ? (__context.rect(rect.x, rect.y, Math.round(rect.width), Math.round(rect.height)), 
                            _didSetPenStyle(__context, drawParam.fillStyle), __context.stroke()) : drawParam.box && (__context.rect(rect.x, rect.y, Math.round(rect.width), Math.round(rect.height)), 
                            void 0 !== drawParam.box.color && null != drawParam.box.color ? (__context.globalAlpha = .5, 
                            __context.fillStyle = drawParam.box.color, __context.fill(), __context.globalAlpha = 1) : (_didSetPenStyle(__context, drawParam.fillStyle), 
                            __context.stroke())), void 0 !== outRect && null != outRect && (outRect.x = rect.x, 
                            outRect.y = rect.y, outRect.width = Math.round(rect.width), outRect.height = Math.round(rect.height));
                        } catch (e) {
                            console.error(e);
                        }
                        return __context.restore(), !0 === isMeasure ? Math.round(width) : void 0;
                    }
                }
            }, exports.DrawText = function(drawParam, isMeasure, outRect) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context) {
                        __context.save(), __didAdjustScale(__context), drawParam.clip && (__context.beginPath(), 
                        __context.rect(drawParam.clip.x, drawParam.clip.y, drawParam.clip.x + drawParam.clip.width - 1, drawParam.clip.y + drawParam.clip.height - 1), 
                        __context.clip()), __context.textBaseline = "top", __context.font = drawParam.font;
                        try {
                            var x1CharInfo = exports.MeasureDefaultText(__context), n1CharH = (x1CharInfo.width, 
                            x1CharInfo.height), width = __context.measureText(drawParam.text).width, rect = {
                                x: 0,
                                y: 0,
                                width: width,
                                height: n1CharH
                            }, arrText = drawParam.text.split("\n"), nMargin = (arrText.length, 3);
                            void 0 !== drawParam.margin && null != drawParam.margin && (nMargin = drawParam.margin);
                            var ptText = {
                                x: drawParam.pt.x + nMargin,
                                y: 0
                            }, textInfos = [];
                            if (!0 === drawParam.useMultiline) {
                                width = 0;
                                for (var arrText = drawParam.text.split("\n"), nCount = arrText.length, ii = 0; ii < nCount; ii++) {
                                    var text = arrText[ii], textWidth = __context.measureText(text).width;
                                    width = Math.max(width, textWidth);
                                    var textInfo = {
                                        text: text,
                                        width: textWidth,
                                        no: ii
                                    };
                                    textInfos.push(textInfo), ptText.y += n1CharH;
                                }
                                width += 2 * nMargin, rect.width = width, rect.height = nCount * n1CharH + 2 * nMargin;
                            } else {
                                width = __context.measureText(drawParam.text).width;
                                var textInfo = {
                                    text: drawParam.text,
                                    width: width,
                                    y: 0
                                };
                                textInfos.push(textInfo), width += 2 * nMargin, rect.width = width, rect.height = 1 * n1CharH + 2 * nMargin;
                            }
                            if (!0 !== isMeasure) {
                                __context.fillStyle = drawParam.fillStyle;
                                for (var ptCenter = {
                                    x: Math.round(drawParam.rect.x + drawParam.rect.width / 2),
                                    y: Math.round(drawParam.rect.y + drawParam.rect.height / 2)
                                }, yPos = Math.round(ptCenter.y - rect.height / 2 + nMargin), textInfoCount = textInfos.length, ii = 0; ii < textInfoCount; ii++) {
                                    var textInfo = textInfos[ii], textWidth = textInfo.width, textPt = {
                                        x: Math.round(ptCenter.x - textWidth / 2),
                                        y: yPos + ii * n1CharH
                                    };
                                    __context.fillText(textInfo.text, textPt.x, textPt.y);
                                }
                                !0 === drawParam.useBox ? (__context.rect(rect.x, rect.y, rect.width, rect.height), 
                                _didSetPenStyle(__context, drawParam.fillStyle), __context.stroke()) : drawParam.box && (__context.rect(rect.x, rect.y, rect.width, rect.height), 
                                void 0 !== drawParam.box.color && null != drawParam.box.color ? (__context.globalAlpha = .5, 
                                __context.fillStyle = drawParam.box.color, __context.fill(), __context.globalAlpha = 1) : (_didSetPenStyle(__context, drawParam.fillStyle), 
                                __context.stroke()));
                            }
                            void 0 !== outRect && null != outRect && (outRect.x = rect.x, outRect.y = rect.y, 
                            outRect.width = rect.width, outRect.height = rect.height);
                        } catch (e) {
                            console.error(e);
                        }
                        return __context.restore(), !0 === isMeasure ? width : void 0;
                    }
                }
            };
            return exports.DrawSingleLineText = function(drawParam, isMeasure) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context) {
                        __context.save(), __didAdjustScale(__context), void 0 !== drawParam.textBaseline && null != drawParam.textBaseline ? __context.textBaseline = drawParam.textBaseline : __context.textBaseline = "middle", 
                        __context.font = drawParam.font;
                        var x1CharInfo = exports.MeasureDefaultText(__context), n1CharH = (x1CharInfo.width, 
                        x1CharInfo.height), nHeight = n1CharH + 6, width = __context.measureText(drawParam.text).width + 6, rect = {
                            x: drawParam.pt.x - 3,
                            y: drawParam.pt.y - parseInt(.5 * nHeight),
                            width: width,
                            height: nHeight
                        };
                        return drawParam.boxStyle && (__context.save(), __context.beginPath(), __context.rect(rect.x, rect.y, rect.width, rect.height), 
                        void 0 !== drawParam.fillAlpha && null != drawParam.fillAlpha && (__context.globalAlpha = drawParam.fillAlpha), 
                        __context.fillStyle = drawParam.boxStyle, __context.fill(), __context.restore()), 
                        __context.fillStyle = drawParam.fillStyle, __context.fillText(drawParam.text, drawParam.pt.x, drawParam.pt.y), 
                        __context.restore(), !0 === isMeasure ? width : void 0;
                    }
                }
            }, exports.Polygon = function(drawParam) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context) {
                        var nCount1 = 0, nCount2 = 0;
                        if (nCount1 = drawParam.pt1s.length, nCount2 = drawParam.pt2s.length, !(nCount1 < 1 && nCount2 < 1)) {
                            __context.save(), __didAdjustScale(__context), __context.beginPath();
                            var pt0;
                            if (nCount1 > 0) {
                                pt0 = drawParam.pt1s[0], __context.moveTo(pt0.x, pt0.y);
                                for (var ii = 1; ii < nCount1; ii++) {
                                    var pt = drawParam.pt1s[ii];
                                    __context.lineTo(pt.x, pt.y);
                                }
                            }
                            if (nCount2 > 1) if (void 0 === pt0 || null == pt0) {
                                pt0 = drawParam.pt2s[0], __context.moveTo(pt0.x, pt0.y);
                                for (var ii = 1; ii < nCount2; ii++) {
                                    var pt = drawParam.pt2s[ii];
                                    __context.lineTo(pt.x, pt.y);
                                }
                            } else for (var ii = nCount2 - 1; ii >= 0; ii--) {
                                var pt = drawParam.pt2s[ii];
                                __context.lineTo(pt.x, pt.y);
                            }
                            pt0 && __context.lineTo(pt0.x, pt0.y), __context.closePath(), void 0 !== drawParam.fillAlpha && null != drawParam.fillAlpha && (__context.globalAlpha = drawParam.fillAlpha), 
                            void 0 !== drawParam.fillColor && null != drawParam.fillColor && (__context.fillStyle = drawParam.fillColor, 
                            __context.fill()), _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                            __context.stroke(), __context.restore();
                        }
                    }
                }
            }, exports.PolygonGradient = function(drawParam) {
                if (void 0 != drawParam && null != drawParam) {
                    var __context = drawParam.context;
                    if (void 0 != __context && null != __context) {
                        var nCount1 = 0, nCount2 = 0;
                        if (nCount1 = drawParam.pt1s.length, nCount2 = drawParam.pt2s.length, !(nCount1 < 1 && nCount2 < 1)) {
                            __context.save(), __didAdjustScale(__context), __context.beginPath();
                            var pt0;
                            if (nCount1 > 0) {
                                pt0 = drawParam.pt1s[0], __context.moveTo(pt0.x, pt0.y);
                                for (var ii = 1; ii < nCount1; ii++) {
                                    var pt = drawParam.pt1s[ii];
                                    __context.lineTo(pt.x, pt.y);
                                }
                            }
                            if (nCount2 > 1) if (void 0 === pt0 || null == pt0) {
                                pt0 = drawParam.pt2s[0], __context.moveTo(pt0.x, pt0.y);
                                for (var ii = 1; ii < nCount2; ii++) {
                                    var pt = drawParam.pt2s[ii];
                                    __context.lineTo(pt.x, pt.y);
                                }
                            } else for (var ii = nCount2 - 1; ii >= 0; ii--) {
                                var pt = drawParam.pt2s[ii];
                                __context.lineTo(pt.x, pt.y);
                            }
                            if (pt0 && __context.lineTo(pt0.x, pt0.y), __context.closePath(), drawParam.grad) try {
                                for (var __grad = __context.createLinearGradient(drawParam.grad.pt1.x, drawParam.grad.pt1.y, drawParam.grad.pt2.x, drawParam.grad.pt2.y), ii = 0; ii < drawParam.grad.colors.length; ii++) __grad.addColorStop(ii, drawParam.grad.colors[ii]);
                                __context.fillStyle = __grad, __context.fill(), drawParam.grad.useStroke && (_didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                                __context.stroke());
                            } catch (e) {} else void 0 !== drawParam.fillAlpha && null != drawParam.fillAlpha && (__context.globalAlpha = drawParam.fillAlpha), 
                            void 0 !== drawParam.fillColor && null != drawParam.fillColor && (__context.fillStyle = drawParam.fillColor, 
                            __context.fill()), _didSetPenStyle(__context, drawParam.lineColor, drawParam.lineWidth, drawParam.lineStyle), 
                            __context.stroke();
                            __context.restore();
                        }
                    }
                }
            }, exports.CalcRect2 = function(str, argFont) {
                var resRect = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }, fonts = argFont.split(" "), fontSize = fonts[0], fontFamily = fonts[1], res = _MeasureText(str, !1, fontFamily, fontSize);
                return resRect.width = res[0], resRect.height = res[1], resRect;
            }, exports.CalcRect = function(context, str, font) {
                var resRect = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                return void 0 === context || null == context ? resRect : (context.save(), context.font = font, 
                resRect.width = context.measureText(str).width, context.restore(), resRect);
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART.canvas2DUtil = loadModule() : module.exports = loadModule();
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, doPriceBar, doSeriesFactory) {
            var exports = {};
            return exports.createDrawObject = function(objectName, isprice, objectInfo) {
                return void 0 !== objectName && null != objectName || (isprice = !0), !0 === isprice ? new doPriceBar() : doSeriesFactory.didCreateSeriesInstance(objectName, objectInfo);
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOFactory = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.chartDOPriceBarCFD, global.WGC_CHART.chartDOSeriesCFD) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(22), __webpack_require__(28));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils) {
            var exports = {}, _AxisUnit = function() {
                var _self = this;
                this.m_stScaleInfo = xUtils.scale.didCreateScaleUnit(), this.m_dMaxD = -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, 
                this.m_dMinD = xUtils.constants.default.DEFAULT_WRONG_VALUE, this.m_dRatioD = 0, 
                this.m_nDiffSize = 0, this.m_nDispPoint = 0, this.m_nRecalCnt = 0, this.m_nDOIdx = -1, 
                this.m_arrDOIdx = [], this.m_bBase = !1, this.m_dMinBase = 0, this.m_nBarPlus = 0, 
                this.m_arrAxisLabel = [], this.m_dZoom = 0, this.m_dZoomStore = 0, this.m_bRevMM = !1, 
                this.SetMinMax = function(argScaleUnit) {
                    return !1;
                }, this.ResetAxis = function() {
                    xUtils.scale.didResetScaleUnit(_self.m_stScaleInfo);
                }, this.CalcDrawInfo = function(argBaseCoordinate) {
                    return !0;
                }, this.GetZoom = function() {
                    return _self.m_dZoomStore + _self.m_dZoom;
                }, this.IsDrawObj = function(argDo) {
                    return !1;
                }, this.GetDO = function(argIdx) {
                    return null;
                }, this.AddDO = function(argDo) {}, this.GetDiffSize = function(lpGate, nSize) {
                    return _self.m_nDiffSize;
                }, this.SetBaseMode = function(bBase, dBase) {
                    _self.m_bBase = bBase, !0 === _self.m_bBase && (_self.m_dMinBase = dBase);
                }, this.GetPixel2Data = function(lpGate, nPixel, bOrgin) {
                    return 0;
                }, this.GetData2Pixel = function(lpGate, dData) {
                    return 0;
                }, this.GetOffset2Pixel = function(lpGate, nOffset) {
                    return 0;
                }, this.CalcAxisInfo = function(lpGate, nScrSize, nBarSize, nGap, nDataSize) {
                    return 0;
                }, this.CalcAxisInfoEx = function(lpGate, nScrSize, nBarSize, nGap, nDataSize, nOffSize) {
                    return 0;
                }, this.CalcAxisInfoByScrollInfo = function(lpGate, nScrSize, xScrollInfo, nDataSize, nOffSize) {
                    return 0;
                }, this.didDestroyRest = function() {}, this.didDestroy = function() {
                    _self.m_arrDOIdx = [], _self.didDestroyRest();
                };
            }, _AxisUnitX = function() {
                var _self = this;
                this.prototype = new _AxisUnit(), _AxisUnit.apply(this, arguments), this.m_nGap = 0, 
                this.m_nSize = 0, this.m_nDOff = 0, this.m_nBar = 0, this.m_nCalcSize = 0, this.CalculateScrollInfo = function(xScrollInfo, xEnv, nDelta, barSizeLimit) {
                    try {
                        if (!xScrollInfo) return;
                        var levelList = xScrollInfo.levelList;
                        if (levelList && levelList.length && levelList.length > 0) {
                            var nCount = levelList.length, level = xScrollInfo.level || 0;
                            nDelta > 0 ? level++ : nDelta < 0 && level--, level = Math.max(0, Math.min(level, nCount - 1));
                            var levelInfo = levelList[level], barGap = levelInfo.gap, barSize = Math.round((levelInfo.bar - 1) / 2);
                            return xScrollInfo.barSize = barSize, xScrollInfo.barGap = barGap, void (xScrollInfo.level = level);
                        }
                        var barGap = xScrollInfo.barGap, barSize = xScrollInfo.barSize + nDelta;
                        barSize < 0 ? barSize = 0 : barSize > barSizeLimit && (barSize = parseInt(barSizeLimit)), 
                        barGap = barSize > 7 ? 3 : barSize > 5 ? 2 : barSize > 0 ? 1 : 0, xScrollInfo.barSize = barSize, 
                        xScrollInfo.barGap = barGap;
                    } catch (e) {
                        console.error(e);
                    }
                }, this.GetPos2Index = function(lpGate, nSIdx, nSPos, nCPos, bLimit, nLimit, extraOuput) {
                    var nLLimit = 0, nRLimit = 0, nDiffPos = nCPos - (nSPos + _self.GetDiffSize(lpGate, 0)), nMoveIdx = _self.GetMovePx2Idx(lpGate, nDiffPos, !1);
                    if (nMoveIdx <= -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE) return !1;
                    var nIdx = 0, nCheck = 0, xLRInfo = {};
                    return bLimit ? (nIdx = nSIdx + nMoveIdx, nCheck = _self.GetIndex2Pixel(lpGate, nSIdx, nSPos, nIdx, xLRInfo), 
                    nLLimit = nCheck - nLimit, nRLimit = nCheck + nLimit, nLLimit <= nCPos && nCPos <= nRLimit && ("object" == typeof extraOuput && (extraOuput.nRIdx = nIdx), 
                    !0)) : (nIdx = nSIdx + nMoveIdx, "object" == typeof extraOuput && (extraOuput.nRIdx = nIdx), 
                    !0);
                }, this.GetMovePx2Idx = function(lpGate, nPxData, bMove) {
                    return 0 == _self.m_nDOff ? 0 : parseInt(nPxData / _self.m_nDOff);
                }, this.GetOffset2Pixel = function(lpGate, nOffset) {
                    return parseInt(_self.m_nDOff * nOffset);
                }, this.GetIndex2Pixel = function(lpGate, nScrSIdx, nScrSPos, nScrCIdx, extraOuput) {
                    var nDiff = nScrCIdx - nScrSIdx, nCLCnt = 0, nRet = 0, nPDiff = 0;
                    nCLCnt = nDiff + 1, nPDiff = (nDiff + 1) * _self.m_nGap + (2 * nDiff + 1) * _self.m_nSize + nCLCnt, 
                    nRet = nScrSPos + nPDiff;
                    var nLeft = 0, nRight = 0;
                    return _self.m_nSize <= 0 ? nLeft = nRight = nRet : (nLeft = nRet - _self.m_nSize, 
                    nRight = nRet + _self.m_nSize + 1), void 0 !== extraOuput && null != extraOuput && (extraOuput.nLeft = nLeft, 
                    extraOuput.nRight = nRight, extraOuput.pos = nLeft, extraOuput.width = nRight - nLeft - 1, 
                    extraOuput.width < 0 && (extraOuput.width = 0), extraOuput.center = nRet), nRet;
                }, this.CalcAxisInfo = function(lpGate, nScrSize, nBarSize, nGap, nDataSize) {
                    var nDSize = 0;
                    return _self.m_nDOff = 2 * nBarSize + 1 + nGap, 0 != _self.m_nDOff && (nDSize = parseInt((nScrSize - nGap) / _self.m_nDOff)), 
                    _self.m_nGap = nGap, _self.m_nSize = nBarSize, nDSize < 0 && (nDSize = 0), _self.m_nCalcSize = nDataSize, 
                    nDSize;
                }, this.CalcAxisInfoEx = function(lpGate, nScrSize, nBarSize, nGap, nDataSize, nOffSize) {
                    _self.m_bRevMM = nDataSize <= 0;
                    var nData = nDataSize + nOffSize + lpGate.GetSBDiff();
                    return _self.CalcAxisInfo(lpGate, nScrSize, nBarSize, nGap, nData);
                }, this.CalcAxisInfoByScrollInfo = function(lpGate, nScrSize, xScrollInfo, nDataSize, nOffSize) {
                    var result = 0;
                    try {
                        result = _self.CalcAxisInfoEx(lpGate, nScrSize, xScrollInfo.barSize, xScrollInfo.barGap, nDataSize, nOffSize), 
                        xScrollInfo.screenSize = result;
                    } catch (e) {
                        console.error(e);
                    }
                    return result;
                };
            }, _AxisUnitXv1 = function() {
                var _self = this;
                this.prototype = new _AxisUnit(), _AxisUnit.apply(this, arguments), this.m_nGap = 0, 
                this.m_nSize = 0, this.m_nBar = 0, this.m_nCalcSize = 0, this.CalculateScrollInfo = function(xScrollInfo, xEnv, nDelta, barSizeLimit) {
                    try {
                        if (!xScrollInfo) return;
                        var iInc = 1, __nCurPos = xScrollInfo.pos, __nCurSize = xScrollInfo.screenSize;
                        iInc = xUtils.scroll.getZoomFactorBy(__nCurSize);
                        var __nFactor = nDelta * iInc;
                        if (nDelta > 0) (__nCurSize -= __nFactor) < xEnv.System.Scroll.screenSize.min && (__nCurSize = xEnv.System.Scroll.screenSize.min); else {
                            __nCurSize -= __nFactor, void 0 !== xEnv.System.Scroll.screenSize.max && null != xEnv.System.Scroll.screenSize.max && __nCurSize > xEnv.System.Scroll.screenSize.max && (__nCurSize = xEnv.System.Scroll.screenSize.max);
                            var __nTemp = __nCurSize + __nCurPos, __nDiff = __nTemp - xScrollInfo.range.length;
                            if (__nDiff > 0) {
                                var __nTempPos = __nCurPos - __nDiff;
                                __nTempPos < 0 && (__nTempPos = 0), __nCurPos = __nTempPos;
                            }
                        }
                        xScrollInfo.pos = __nCurPos, xScrollInfo.screenSize = __nCurSize, xScrollInfo.range.length < xScrollInfo.screenSize && (xScrollInfo.range.length = xScrollInfo.screenSize, 
                        xScrollInfo.pos = 0);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.GetPos2Index = function(lpGate, nSIdx, nSPos, nCPos, bLimit, nLimit, extraOuput) {
                    var xLRInfo = {
                        nLeft: 0,
                        nRight: 0
                    }, nLLimit = 0, nRLimit = 0, nDiff = nCPos - nSPos, nMove = _self.GetMovePx2Idx(lpGate, nDiff, !1);
                    if (nMove <= -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE) return !1;
                    var nIdx = 0, nCheck = 0;
                    return bLimit ? (nIdx = nSIdx + nMove, nCheck = _self.GetIndex2Pixel(lpGate, nSIdx, nSPos, nIdx, xLRInfo), 
                    nLLimit = nCheck - nLimit, nRLimit = nCheck + nLimit, nLLimit <= nCPos && nCPos <= nRLimit && ("object" == typeof extraOuput && (extraOuput.nRIdx = nIdx), 
                    !0)) : (nIdx = nSIdx + nMove, "object" == typeof extraOuput && (extraOuput.nRIdx = nIdx), 
                    !0);
                }, this.GetMovePx2Idx = function(lpGate, nPxData, bMove) {
                    return 0 == _self.m_dRatioD ? 0 : parseInt(nPxData / _self.m_dRatioD);
                }, this.GetOffset2Pixel = function(lpGate, nOffset) {
                    return parseInt(_self.m_dRatioD * nOffset);
                }, this.GetIndex2Pixel = function(lpGate, nScrSIdx, nScrSPos, nScrCIdx, extraOuput) {
                    var nScrCPos = nScrSPos + Math.round((nScrCIdx - nScrSIdx) * _self.m_dRatioD) + _self.m_nGap, nCenter = Math.round(nScrCPos + _self.m_dRatioD / 2), xBarInfo = xUtils.axis.didGetAdjustedBarInfo(_self.m_dRatioD, nCenter);
                    return void 0 !== extraOuput && null != extraOuput && (extraOuput.nLeft = xBarInfo.pos, 
                    extraOuput.nRight = xBarInfo.pos + xBarInfo.width, extraOuput.pos = xBarInfo.pos, 
                    extraOuput.width = xBarInfo.width, extraOuput.center = nCenter), nCenter;
                }, this.CalcAxisInfo = function(lpGate, nScrSize, nBarSize, nGap, nDataSize) {
                    var nDSize = 0, nZoom = 1, nGM = nGap, nGFac1 = 0, nGFac2 = 0, dOffset = 0;
                    if ((nZoom = lpGate.ExGetZoomInfo()) < 1) return nDSize;
                    for (dOffset = (nScrSize + nGap) / nZoom, nGFac1 = parseInt(dOffset / 2), nGFac2 = Math.min(nGM, nGFac1), 
                    _self.m_nBar = dOffset <= 1 ? 1 : parseInt(dOffset) - nGFac2, _self.m_nBar % 2 == 0 && nGFac2 >= 1 && (_self.m_nBar = _self.m_nBar + 1); _self.m_nBar < nGFac2; ) _self.m_nBar++;
                    return _self.m_dRatioD = dOffset, _self.m_nGap = nGap, _self.m_nSize = nBarSize, 
                    nDSize < 0 && (nDSize = 0), _self.m_nCalcSize = nDataSize, nZoom;
                }, this.CalcAxisInfoEx = function(lpGate, nScrSize, nBarSize, nGap, nDataSize, nOffSize) {
                    _self.m_bRevMM = nDataSize <= 0;
                    var nData = nDataSize + nOffSize + lpGate.GetSBDiff();
                    return _self.CalcAxisInfo(lpGate, nScrSize, nBarSize, nGap, nData);
                }, this.CalcAxisInfoByScrollInfo = function(lpGate, nScrSize, xScrollInfo, nDataSize, nOffSize) {
                    var result = 0;
                    try {
                        result = _self.CalcAxisInfoEx(lpGate, nScrSize, xScrollInfo.screenSize, xScrollInfo.barGap, nDataSize, nOffSize), 
                        xScrollInfo.screenSize = result;
                    } catch (e) {
                        console.error(e);
                    }
                    return result;
                };
            }, _AxisUnitXNum = function() {
                this.prototype = new _AxisUnitX(), _AxisUnitX.apply(this, arguments);
            }, _AxisUnitXNT = function() {
                this.prototype = new _AxisUnitXNum(), _AxisUnitXNum.apply(this, arguments);
            }, _AxisUnitXKagi = function() {
                this.prototype = new _AxisUnitXNT(), _AxisUnitXNT.apply(this, arguments);
            }, _AxisUnitXRenko = function() {
                this.prototype = new _AxisUnitXNT(), _AxisUnitXNT.apply(this, arguments);
            }, _AxisUnitXPnF = function() {
                this.prototype = new _AxisUnitXNT(), _AxisUnitXNT.apply(this, arguments);
            }, _AxisUnitXVolume = function() {
                var _self = this;
                this.prototype = new _AxisUnitX(), _AxisUnitX.apply(this, arguments), this.m_arrVI = [], 
                this.m_stOutArea = xUtils.didClone(xUtils.struct.ST_VALUE_INFO), this.CalculateScrollInfo = function(xScrollInfo, xEnv, nDelta, barSizeLimit) {
                    try {
                        if (!xScrollInfo) return;
                        var iInc = 1, __nCurPos = xScrollInfo.pos, __nCurSize = xScrollInfo.screenSize;
                        iInc = xUtils.scroll.getZoomFactorBy(__nCurSize);
                        var __nFactor = nDelta * iInc;
                        if (nDelta > 0) (__nCurSize -= __nFactor) < xEnv.System.Scroll.screenSize.min && (__nCurSize = xEnv.System.Scroll.screenSize.min); else {
                            __nCurSize -= __nFactor, void 0 !== xEnv.System.Scroll.screenSize.max && null != xEnv.System.Scroll.screenSize.max && __nCurSize > xEnv.System.Scroll.screenSize.max && (__nCurSize = xEnv.System.Scroll.screenSize.max);
                            var __nTemp = __nCurSize + __nCurPos, __nDiff = __nTemp - xScrollInfo.range.length;
                            if (__nDiff > 0) {
                                var __nTempPos = __nCurPos - __nDiff;
                                __nTempPos < 0 && (__nTempPos = 0), __nCurPos = __nTempPos;
                            }
                        }
                        xScrollInfo.pos = __nCurPos, xScrollInfo.screenSize = __nCurSize, xScrollInfo.range.length < xScrollInfo.screenSize && (xScrollInfo.range.length = xScrollInfo.screenSize, 
                        xScrollInfo.pos = 0);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.CalcAxisInfoVol = function(lpGate, nScrSize, nOMinus, nGap, nDataSize, dVolume, dVolFull, nStart, nSize) {
                    _self.m_nCalcSize = nDataSize, _self.m_arrVI = [], _self.m_nGap = nGap;
                    var arrPriceDatas = (lpGate.didGetEnvInfo(), lpGate.didGetPriceDatas()), nDOCnt = xUtils.constants.ngc.macro.__GETSIZE_INT(arrPriceDatas), nf_cnt = 0, nRSize = nScrSize - 2 * _self.GetDiffSize(lpGate, nSize);
                    nSize > 0 && (nRSize -= (nSize - 1) * nGap);
                    var dRVol = dVolume, dVolAvg = nDOCnt < 1 ? 0 : dVolFull / nDOCnt, nDataIdx = 0, nScrPos = nStart, nDummyVolData = 0, nPrePos = 0;
                    if (nDataIdx = xUtils.EC_GetDataZScr(nScrPos, nOMinus, 0, !1), nDOCnt < 1 || nDataIdx + nSize <= 0 || nDataIdx >= nDOCnt || nSize <= 0 || dVolume <= 0) {
                        for (_self.m_dRatioD = nRSize / dVolFull, nDummyVolData = parseInt(dVolAvg * _self.m_dRatioD), 
                        _self.m_stOutArea.nNo = 0, _self.m_stOutArea.nData = nDummyVolData, nPrePos = 0, 
                        nf_cnt = 0; nf_cnt < nSize; nf_cnt++) {
                            var stNew = xUtils.didClone(xUtils.struct.ST_VALUE_INFO);
                            stNew.nNo = nGap + nDummyVolData + 0 + nPrePos, stNew.nData = nDummyVolData, nPrePos = stNew.nNo + stNew.nData, 
                            _self.m_arrVI.push(stNew);
                        }
                        return _self.m_nDOff = 0, 0;
                    }
                    var nSIdx = nDataIdx < 0 ? 0 : nDataIdx, nRest = nDOCnt - (nDataIdx + nSize), nLoop = 0;
                    nRest < 0 ? nDataIdx < 0 ? (nLoop = nDOCnt, dRVol += -1 * (nRest + nDataIdx) * dVolAvg) : (nLoop = nDOCnt - nDataIdx, 
                    dRVol += -1 * nRest * dVolAvg) : nDataIdx < 0 ? (nLoop = nDataIdx + nSize, dRVol += -1 * nDataIdx * dVolAvg) : nLoop = nSize, 
                    _self.m_dRatioD = nRSize / dRVol, nDummyVolData = parseInt(dVolAvg * _self.m_dRatioD), 
                    _self.m_stOutArea.nData = nDummyVolData, nPrePos = 0;
                    var didProcForDummy = function(argPrePos, argGap, argVolData, argLoop, arrVI) {
                        for (var __ii = 0; __ii < argLoop; __ii++) {
                            var stNew = xUtils.didClone(xUtils.struct.ST_VALUE_INFO);
                            stNew.nNo = argGap + 0 + argPrePos, stNew.nData = argVolData, argPrePos = stNew.nNo + stNew.nData, 
                            arrVI.push(stNew);
                        }
                        return argPrePos;
                    };
                    if (nDataIdx < 0) {
                        var nRLoop = -1 * nDataIdx;
                        nPrePos = didProcForDummy(nPrePos, nGap, nDummyVolData, nRLoop, _self.m_arrVI);
                    }
                    for (nf_cnt = 0; nf_cnt < nLoop; nf_cnt++) {
                        var stRef = arrPriceDatas[nSIdx + nf_cnt], stNew = xUtils.didClone(xUtils.struct.ST_VALUE_INFO), dVolume = xUtils.didGetPriceValue(stRef, xUtils.constants.keywords.price.volume);
                        stNew.nNo = nGap + nPrePos + 0, stNew.nData = Math.round(dVolume * _self.m_dRatioD), 
                        nPrePos = stNew.nNo + stNew.nData, _self.m_arrVI.push(stNew);
                    }
                    if (nRest < 0) {
                        var nRLoop = -1 * nRest;
                        nPrePos = didProcForDummy(nPrePos, nGap, nDummyVolData, nRLoop, _self.m_arrVI);
                    }
                    return _self.m_nDOff = xUtils.constants.ngc.macro.__GETSIZE_INT(_self.m_arrVI), 
                    xUtils.constants.ngc.NGC_SUCCESS;
                }, this.GetMovePx2Idx = function(lpGate, nPxData, bMove) {
                    lpGate.didGetEnvInfo();
                    if (!0 === bMove) {
                        var frameWidth = lpGate.GetChartFrameAreaWidth(), nBCnt = lpGate.ExGetZoomInfo(), dRatio = 0 === nBCnt ? 0 : frameWidth / nBCnt;
                        return dRatio <= 0 ? 0 : parseInt(nPxData / dRatio);
                    }
                    var nCnt = xUtils.constants.ngc.macro.__GETSIZE_INT(_self.m_arrVI);
                    if (nCnt < 1) return -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE;
                    var nWDiff = _self.GetDiffSize(lpGate, 0), pstVIS = _self.m_arrVI[0], pstVIF = _self.m_arrVI[nCnt - 1];
                    if (nPxData < nWDiff + pstVIS.nNo) {
                        var nOutSize = 2 * _self.m_stOutArea.nData + _self.m_nGap, dRatio = Math.abs(nPxData) / nOutSize;
                        return dRatio += .5, -1 * parseInt(dRatio);
                    }
                    if (nPxData > nWDiff + pstVIF.nNo + pstVIF.nData + _self.m_nGap) {
                        var nOutSize = 2 * _self.m_stOutArea.nData + _self.m_nGap, dRatio = Math.abs(nPxData - (nWDiff + pstVIF.nNo + pstVIF.nData + _self.m_nGap)) / nOutSize;
                        return dRatio += .5, nCnt + parseInt(dRatio);
                    }
                    for (var ii = 0; ii < nCnt; ii++) {
                        var stRef = _self.m_arrVI[ii];
                        if (nWDiff + stRef.nNo <= nPxData && nWDiff + stRef.nNo + stRef.nData + _self.m_nGap >= nPxData) return ii;
                    }
                    return -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE;
                }, this.GetOffset2Pixel = function(lpGate, nOffset) {
                    if (0 == _self.m_nDOff) return 0;
                    var frameWidth = lpGate.GetChartFrameAreaWidth(), nWDiff = _self.GetDiffSize(lpGate, 0), dTemp = nOffset * ((frameWidth - nWDiff) / _self.m_nDOff);
                    return Math.round(dTemp);
                }, this.GetIndex2Pixel = function(lpGate, nScrSIdx, nScrSPos, nScrCIdx, extraOuput) {
                    var nDCnt = xUtils.constants.ngc.macro.__GETSIZE_INT(_self.m_arrVI), nDIdx = nScrCIdx - nScrSIdx, nWDiff = _self.GetDiffSize(lpGate, 0), nSign = nDIdx < 0 ? -1 : 1, nRet = nScrSPos;
                    if (nDCnt < 1 || nDIdx < 0 || nDIdx >= nDCnt) {
                        if (nSign < 0 || nDCnt < 1) nRet = nScrSPos + nWDiff + (2 * nDIdx + 1) * _self.m_stOutArea.nData + nSign + nSign * (nDIdx + 1) * _self.m_nGap; else {
                            var stRef = _self.m_arrVI[nDCnt - 1], nIDiff = nDIdx - (nDCnt - 1);
                            nRet = nScrSPos + nWDiff + stRef.nNo + stRef.nData + _self.m_nGap + nIDiff + (2 * nIDiff - 1) * _self.m_stOutArea.nData;
                        }
                        return void 0 !== extraOuput && null != extraOuput && (_self.m_stOutArea.nData <= 0 ? extraOuput.nLeft = extraOuput.nRight = nRet : (extraOuput.nLeft = nRet - _self.m_stOutArea.nData, 
                        extraOuput.nRight = nRet + _self.m_stOutArea.nData + 1)), nRet;
                    }
                    var stRef = _self.m_arrVI[nDIdx];
                    if (stRef) {
                        nRet = Math.round(nScrSPos + nWDiff + stRef.nNo + stRef.nData / 2);
                        var xBarInfo = xUtils.axis.didGetAdjustedBarInfo(stRef.nData, nRet);
                        void 0 !== extraOuput && null != extraOuput && (extraOuput.nLeft = xBarInfo.pos, 
                        extraOuput.nRight = xBarInfo.pos + xBarInfo.width, extraOuput.pos = xBarInfo.pos, 
                        extraOuput.width = xBarInfo.width, extraOuput.center = nRet);
                    }
                    return nRet;
                };
            }, _AxisUnitY = function() {
                var _self = this;
                this.prototype = new _AxisUnit(), _AxisUnit.apply(this, arguments), this.m_dMaxL = -1, 
                this.m_dMinL = xUtils.constants.default.DEFAULT_WRONG_VALUE, this.m_dRatioL = 0, 
                this.m_dLogRevision = 0, this.m_bLog = !1, this.m_bReverse = !1, this.m_arrDrawObj = [], 
                this.didDestroyRest = function() {
                    _self.m_arrDrawObj = [];
                }, this.GetRawData = function(dData) {
                    return !0 === _self.m_bLog ? Math.pow(xUtils.constants.ngc.define.NGC_DATA_LOG, dData) - _self.m_dLogRevision : dData;
                }, this.IsDrawObj = function(argDo) {
                    if (void 0 === argDo || null == argDo) return !1;
                    for (var nCnt = _self.m_arrDrawObj.length, ii = 0; ii < nCnt; ii++) {
                        if (_self.m_arrDrawObj[ii] === argDo) return !0;
                    }
                    return !1;
                }, this.GetDO = function(argIdx) {
                    var nCnt = _self.m_arrDrawObj.length;
                    return nCnt < 1 || argIdx < 0 || argIdx >= nCnt ? null : _self.m_arrDrawObj[argIdx];
                }, this.AddDO = function(argDo) {
                    !0 !== _self.IsDrawObj(argDo) && _self.m_arrDrawObj.push(argDo);
                }, this.CalcDrawInfo = function(argBaseCoordinate, argEnv) {
                    if (void 0 !== argBaseCoordinate && null != argBaseCoordinate) {
                        _self.m_dLogRevision = 0;
                        var nRSize = Math.max(0, argBaseCoordinate.height);
                        _self.GetZoom();
                        xUtils.scale.didCalcScaleUnit(_self.m_stScaleInfo);
                        var xMM = _self.m_stScaleInfo.minMaxScreen, dMax = xMM.maxValue, dMin = xMM.minValue;
                        dMax < dMin ? (_self.m_bRevMM = !0, dMax = dMin = 0) : _self.m_bRevMM = !1;
                        var dMaxL = 0, dMinL = 0;
                        dMin <= 0 ? (_self.m_dLogRevision = 1 - dMin, dMaxL = xUtils.math.log10(dMax + _self.m_dLogRevision), 
                        dMinL = xUtils.math.log10(1)) : (dMaxL = xUtils.math.log10(dMax), dMinL = xUtils.math.log10(dMin));
                        var dDiff = xUtils.scale.didCalcDiff(dMax, dMin), dDiffL = xUtils.scale.didCalcDiff(dMaxL, dMinL);
                        return dDiff < 0 && (dDiff = 0), dDiffL < 0 && (dDiffL = 0), 0 == dDiff ? (xMM.ratio = 0, 
                        dMax > 0 ? (_self.m_dMaxD = 3 * dMax / 2, _self.m_dMinD = 0) : dMax < 0 ? (_self.m_dMaxD = 0, 
                        _self.m_dMinD = 3 * dMax / 2) : (_self.m_dMaxD = 100, _self.m_dMinD = 0), _self.m_dRatioD = nRSize / xUtils.scale.didCalcDiff(_self.m_dMaxD, _self.m_dMinD)) : (xMM.ratio = nRSize / dDiff, 
                        _self.m_dRatioD = xMM.ratio, _self.m_dMaxD = dMax, _self.m_dMinD = dMin), 0 == dDiffL ? (dMaxL > 0 ? (_self.m_dMaxL = 3 * dMaxL / 2, 
                        _self.m_dMinL = 0) : dMaxL < 0 ? (_self.m_dMaxL = 0, _self.m_dMinL = 3 * dMaxL / 2) : (_self.m_dLogRevision = 1, 
                        _self.m_dMaxL = xUtils.math.log10(100 + _self.m_dLogRevision), _self.m_dMinL = xUtils.math.log10(1)), 
                        _self.m_dRatioL = nRSize / xUtils.scale.didCalcDiff(_self.m_dMaxL, _self.m_dMinL)) : (_self.m_dRatioL = nRSize / dDiffL, 
                        _self.m_dMaxL = dMaxL, _self.m_dMinL = dMinL), !0;
                    }
                };
            };
            return exports.constants = {
                AXISY_NORMAL: 0,
                AXISX_NORMAL: 100
            }, exports.didCreateAxisUnit = function(argAxisType) {
                if (argAxisType === exports.constants.AXISY_NORMAL) return new _AxisUnitY();
            }, exports.SF_CreateAxisX = function(argAxisType) {
                switch (argAxisType) {
                  case xUtils.constants.ngc.enum.ELS_NORMAL:
                  case xUtils.constants.ngc.enum.ELS_COMPARE:
                    return new _AxisUnitXv1();

                  case xUtils.constants.ngc.enum.ELS_VOLUME:
                    return new _AxisUnitXVolume();

                  case xUtils.constants.ngc.enum.ELS_PNF:
                    return new _AxisUnitXPnF();

                  case xUtils.constants.ngc.enum.ELS_RENKO:
                    return new _AxisUnitXRenko();

                  case xUtils.constants.ngc.enum.ELS_KAGI:
                    return new _AxisUnitXKagi();
                }
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartAxisUnit = loadModule(global.WGC_CHART.chartUtil) : module.exports = loadModule(__webpack_require__(0));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function() {
            return function() {
                var _self = this;
                this.name = "", this.arrScr = [], this.push = function(obj) {
                    _self.arrScr.push(obj);
                }, this.pop = function() {
                    return _self.arrScr.pop();
                }, this.remove = function(ele) {
                    for (var i in scrMng.arrScr) if (_self.arrScr[i] == ele) return void _self.arrScr.splice(i, 1);
                }, this.find = function(ele) {
                    for (var i in _self.arrScr) if (_self.arrScr[i].getElement() == ele) return _self.arrScr[i];
                    return null;
                }, this.count = function() {
                    return _self.arrScr.length;
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.screenManager = loadModule() : module.exports = loadModule();
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(sm) {
            return function(id) {
                var _scrMng = sm;
                this._scrMng = _scrMng, this._id = id, this._parent = null, this._$object = null, 
                this._arrDatLoader = [], this._onLoad = null;
                var _classRef = this;
                this.method = {
                    classObj: this
                }, this.method.create = function(parent, url, option, onLoad) {
                    var ref = this.classObj;
                    if (_classRef = ref, ref._object = document.createElement("div"), ref._$object = $(ref._object), 
                    ref._$object.addClass("Screen"), ref._object.id = ref._id, null !== parent ? ref._$object.appendTo($(parent)) : document.body.appendChild(ref._object), 
                    ref._$object.css(option), ref._parent = parent, ref._onLoad = onLoad, url && url.length > 0) {
                        new ScrLoader(ref._object, url).loadScreen(ref.method.onLoad);
                    } else onLoad();
                    return ref._object;
                }, this.method.attach = function(url, onLoad) {
                    var ref = this.classObj;
                    if (_classRef = ref, this._classRef = ref, ref._object = document.getElementById(ref._id), 
                    ref._object) {
                        ref._$object = $(ref._object), ref._parent = ref._object.offsetParent, ref._onLoad = onLoad, 
                        ref._$object.addClass("Screen");
                        return new ScrLoader(ref._object, url).loadScreen(ref.method.onLoad), ref._object;
                    }
                    return null;
                }, this.method.attachToTarget = function(jqElemTarget) {
                    var ref = this.classObj;
                    return _classRef = ref, this._classRef = ref, ref._object = jqElemTarget.get(0), 
                    ref._$object = jqElemTarget, ref._object ? (ref._parent = ref._object.offsetParent, 
                    ref._$object.addClass("Screen"), ref._object) : null;
                }, this.method.onLoad = function() {
                    void 0 !== _classRef._onLoad && null !== _classRef._onLoad && _classRef._onLoad(_classRef);
                }, this.method.destroy = function() {
                    this.classObj.clearDataLoader();
                }, this.method.onClose = function() {
                    var ref = this.classObj;
                    $(ref.getElement()).remove();
                }, this.getElement = function() {
                    return this._object;
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.screen = loadModule(global.WGC_CHART.screenManager) : module.exports = loadModule(__webpack_require__(4));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils) {
            return function() {
                var _self = this;
                this.onMouseMove = null, this.onMouseUp = null, this.onTouchMove = null, this.onTouchEnd = null, 
                this.m_capturedObj = null, this.m_capturedObjForTouch = null;
                var _onMouseMove = function(event) {
                    var __event = event || window.event;
                    void 0 !== _self.onMouseMove && null != _self.onMouseMove && _self.onMouseMove.call(null, __event, _self.m_capturedObj), 
                    xUtils.didStopPropagation(__event);
                }, _onMouseUp = function(event) {
                    var __event = event || window.event;
                    void 0 !== _self.onMouseUp && null != _self.onMouseUp && _self.onMouseUp.call(null, __event, _self.m_capturedObj), 
                    _self.didStopCapture();
                };
                this.didStartCapture = function(domElem, mm, mu) {
                    _self.m_capturedObj = domElem, _self.onMouseMove = mm, _self.onMouseUp = mu;
                    var __targetElement = document;
                    __targetElement.addEventListener ? (__targetElement.addEventListener("mousemove", _onMouseMove, !1), 
                    __targetElement.addEventListener("mouseup", _onMouseUp, !1)) : __targetElement.attachEvent && (__targetElement.attachEvent("mousemove", _onMouseMove, !1), 
                    __targetElement.attachEvent("mouseup", _onMouseUp, !1));
                }, this.didStopCapture = function() {
                    var __targetElement = document;
                    __targetElement.removeEventListener ? (__targetElement.removeEventListener("mousemove", _onMouseMove, !1), 
                    __targetElement.removeEventListener("mouseup", _onMouseUp, !1)) : __targetElement.detachEvent && (__targetElement.detachEvent("mousemove", _onMouseMove, !1), 
                    __targetElement.detachEvent("mouseup", _onMouseUp, !1)), _self.m_capturedObj = null, 
                    _self.onMouseMove = null, _self.onMouseUp = null;
                };
                var _onTouchEnd = function(event) {
                    var __event = event || window.event;
                    void 0 !== _self.onTouchEnd && null != _self.onTouchEnd && _self.onTouchEnd.call(null, __event, _self.m_capturedObjForTouch), 
                    _self.didStopTouchCapture();
                }, _onTouchMove = function(event) {
                    var __event = event || window.event;
                    void 0 !== _self.onTouchMove && null != _self.onTouchMove && _self.onTouchMove.call(null, __event, _self.m_capturedObjForTouch), 
                    xUtils.didStopPropagation(__event);
                };
                this.didStartTouchCapture = function(domElem, mm, mu) {
                    _self.m_capturedObjForTouch = domElem, _self.onTouchMove = mm, _self.onTouchEnd = mu;
                    var __targetElement = document;
                    __targetElement.addEventListener ? (__targetElement.addEventListener("touchmove", _onTouchMove, !1), 
                    __targetElement.addEventListener("touchend", _onTouchEnd, !1)) : __targetElement.attachEvent && (__targetElement.attachEvent("touchmove", _onMouseMove, !1), 
                    __targetElement.attachEvent("touchend", _onMouseUp, !1));
                }, this.didStopTouchCapture = function() {
                    var __targetElement = document;
                    __targetElement.removeEventListener ? (__targetElement.removeEventListener("touchmove", _onTouchMove, !1), 
                    __targetElement.removeEventListener("touchend", _onTouchEnd, !1)) : __targetElement.detachEvent && (__targetElement.detachEvent("touchmove", _onTouchMove, !1), 
                    __targetElement.detachEvent("touchend", _onTouchEnd, !1)), _self.m_capturedObjForTouch = null, 
                    _self.onTouchMove = null, _self.onTouchEnd = null;
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.mouseCapture = loadModule(global.WGC_CHART.chartUtil) : module.exports = loadModule(__webpack_require__(0));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(parentPanel, doFactory, gxDc, xUtils) {
            var exports = {};
            return exports.panelNormal = function(chartWrapper, drawWrapper) {
                var _self = this;
                this.prototype = new parentPanel.panelBase(chartWrapper, drawWrapper), parentPanel.panelBase.apply(this, arguments), 
                this.OBJECT_NAME = "NORMAL_FRAME", this.isNontime = !1, this.CreateTrendlineObj = function(strTrendLine, posval, trendLineInfo, skipStore) {
                    var __xDo = _self.didGetPriceBar();
                    if (void 0 !== __xDo && null != __xDo) return _self.m_currTrendlineObj = __xDo.CreateTrendlineObj(strTrendLine, posval, trendLineInfo, skipStore), 
                    _self.m_currTrendlineObj;
                }, this.didConvertLocalIndexToDataIndex = function(argLocalIdx) {
                    return this.m_drawWrapper.didConvertLocalIndexToDataIndex(argLocalIdx);
                }, this.didConvertDataIndexToLocalIndex = function(argDataIdx) {
                    return this.m_drawWrapper.didConvertDataIndexToLocalIndex(argDataIdx);
                }, this.didGetTimedataAt = function(at, bScreen, ignoreLimit) {
                    return this.m_drawWrapper.didGetTimedataAt(at, bScreen, ignoreLimit);
                }, this.didChangeIndicatorSettingByKey = function(argKey, argSettings, outputChanged) {
                    var xDo = _self.didFindObjectByKey(argKey);
                    if (void 0 !== xDo && null != xDo) return xDo.didApplySetting ? xDo.didApplySetting(argSettings, outputChanged) : void 0;
                }, this.didDeleteIndicator = function(argTypeId) {
                    var xTargetInfo, xResult = {
                        typeId: argTypeId,
                        isDeleted: !1
                    };
                    if (void 0 !== (xTargetInfo = void 0 === argTypeId || null == argTypeId ? _self.didFindSelectedObject() : _self.didFindFirstIndicatorObjectByTypeId(argTypeId)) && null != xTargetInfo && void 0 !== xTargetInfo.indicator && null !== xTargetInfo.indicator && (xResult.typeId = xTargetInfo.indicator.m_strIndicator, 
                    !0 === _self.didClearDrawObjectAt(xTargetInfo.index))) return xResult.isDeleted = !0, 
                    xResult;
                }, this.didChangeIndicatorSettingByTypeId = function(argTypeId, argSettings, outputChanged) {
                    var arrResult = _self.didFindIndicatorObjectsByTypeId(argTypeId);
                    if (void 0 === arrResult || null == arrResult || void 0 === arrResult.length || null == arrResult.length || arrResult.length < 1) return !1;
                    var bResult = !1;
                    if (!0 === _self.didGetEnvInfo().System.MultipleSeries) for (var nCount = arrResult.length, ii = 0; ii < nCount; ii++) {
                        var xResult = arrResult[ii];
                        if (void 0 !== xResult && null != xResult) {
                            var xDo = xResult.indicator;
                            xDo && xDo.didApplySetting && (bResult |= xDo.didApplySetting(argSettings, outputChanged));
                        }
                    } else {
                        var xResult = arrResult[0];
                        if (void 0 !== xResult && null != xResult) {
                            var xDo = xResult.indicator;
                            xDo && xDo.didApplySetting && (bResult = xDo.didApplySetting(argSettings, outputChanged));
                        }
                    }
                    return bResult;
                }, this.didGetCurrentLiveIndicatorInformationAll = function(isReferenced, isPriceType) {
                    for (var arrOutput = [], __nObjectCount = _self.m_arrChartObjlist.length, ii = 0; ii < __nObjectCount; ii++) {
                        var xDo = _self.m_arrChartObjlist[ii];
                        xDo && xDo.m_xSeriesInfo && (!0 === isPriceType && !0 === xDo.m_xSeriesInfo.priceType ? arrOutput.push({
                            key: xDo.uniqueKey,
                            info: xDo.m_xSeriesInfo
                        }) : !0 !== isPriceType && !0 !== xDo.m_xSeriesInfo.priceType && arrOutput.push({
                            key: xDo.uniqueKey,
                            info: xDo.m_xSeriesInfo
                        }));
                    }
                    return arrOutput;
                }, this.DrawTitleLabel = function() {
                    var xEnv = _self.didGetEnvInfo();
                    if (!0 !== xEnv.System.UseForMiniChart && !0 === xEnv.ShowTitleLabel && !0 === _self.m_initParam.showLegend) {
                        var __nObjectCount = _self.m_arrChartObjlist.length;
                        if (__nObjectCount > 0) {
                            var lineSpace = xEnv.System.LineSpace, textSpace = xEnv.System.TextSpace, font = (_self.m_context, 
                            xEnv.Font), fontColor = xEnv.FontColor, textSpace = xEnv.System.TextSpace, drawParam = {
                                context: _self.m_context,
                                ptBase: {
                                    x: xEnv.TitleLeft || 60,
                                    y: xEnv.TitleTop || 20
                                },
                                frameWidth: _self.didGetDrawingWidth(!0),
                                font: font,
                                fillStyle: fontColor,
                                lineSpace: lineSpace,
                                textSpace: textSpace,
                                lineNo: 0,
                                pt: {
                                    x: 0,
                                    y: 0
                                }
                            };
                            drawParam.pt.x = drawParam.ptBase.x, drawParam.pt.y = drawParam.ptBase.y;
                            for (var idx = __nObjectCount - 1; idx >= 0; idx--) {
                                var doChartObj = _self.m_arrChartObjlist[idx];
                                doChartObj && doChartObj.didDrawTitleLabel && doChartObj.didDrawTitleLabel(drawParam);
                            }
                        }
                    }
                };
            }, exports.createPanel = function(chartWrapper, drawWrapper) {
                return new this.panelNormal(chartWrapper, drawWrapper);
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDrawFrameNormal = loadModule(global.WGC_CHART.chartDrawFrameBase, global.WGC_CHART.chartDOFactory, global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartUtil) : module.exports = loadModule(__webpack_require__(21), __webpack_require__(2), __webpack_require__(1), __webpack_require__(0));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc, doLsFactory, axisUnitFactory) {
            return function() {
                var _self = this;
                this.m_chartFrame = {}, this.m_strChartName = "", this.m_chartdraw = {}, this.m_arrTrendlineObjlist = [], 
                this.m_bMainChart = !1, this.m_bPriceType = !1, this.m_iBaseWidth = 0, this.m_iBaseHeight = 0, 
                this.m_iBaseOriginY = 0, this.m_iGridWidth = 0, this.m_iGridHeight = 0, this.m_point = 2, 
                this.m_canvas = {}, this.m_canvasLY = {}, this.m_canvasRY = {}, this.m_context = {}, 
                this.m_contextLY = {}, this.m_contextRY = {}, this.m_memcanvas = {}, this.m_memcontext = {}, 
                this.m_bSelect = !1, this.m_drawWrapper = {}, this.uniqueKey = null, this.m_nShift = 0, 
                this.WIDTH = 0, this.HEIGHT = 0, this.m_nMaxPriceSave = xUtils.constants.default.DEFAULT_WRONG_VALUE, 
                this.m_nMinPriceSave = xUtils.constants.default.DEFAULT_WRONG_VALUE, this.m_nPriceSize = 0, 
                this.m_xScaleInfo = xUtils.scale.didCreateScaleInfo(), this.m_xAxisY = null, this.didInitParams = function() {}, 
                this.didInitSubObjects = function(chartFrame, drawWrapper) {}, this.didInitAxis = function() {
                    _self.m_xAxisY = axisUnitFactory.didCreateAxisUnit(axisUnitFactory.constants.AXISY_NORMAL), 
                    _self.m_xAxisY.AddDO(_self);
                }, this.didInitVariables = function(strChartName) {
                    _self.m_bMainChart = !0, _self.m_bPriceType = !0, _self.m_strChartName = strChartName;
                }, this.Init = function(chartFrame, strChartName, drawWrapper) {
                    _self.uniqueKey = xUtils.createGuid(), _self.m_drawWrapper = drawWrapper, _self.m_arrTrendlineObjlist = [], 
                    _self.didInitSubObjects(chartFrame, drawWrapper), _self.didInitAxis(), _self.didInitVariables(strChartName), 
                    _self.ReSetFrame(chartFrame), _self.didInitParams();
                }, this.didGetEnvInfo = function() {
                    return _self.m_drawWrapper.m_stEnv;
                }, this.DeslectAllTrendlines = function() {
                    for (var nCount = _self.m_arrTrendlineObjlist.length, ii = 0; ii < nCount; ii++) _self.m_arrTrendlineObjlist[ii].m_bSelect = !1;
                }, this.DeslectAllRest = function() {}, this.DeselectAllObject = function() {
                    _self.m_bSelect = !1, _self.DeslectAllTrendlines(), _self.DeslectAllRest();
                }, this.ReSetFrame = function(chartFrame) {
                    _self.m_chartFrame = chartFrame, _self.m_canvas = chartFrame.m_canvas, _self.m_canvasLY = chartFrame.m_canvasLY, 
                    _self.m_canvasRY = chartFrame.m_canvasRY, _self.HEIGHT = chartFrame.m_canvas.height, 
                    _self.WIDTH = chartFrame.m_canvas.width, _self.m_context = chartFrame.m_context, 
                    _self.m_contextLY = chartFrame.m_contextLY, _self.m_contextRY = chartFrame.m_contextRY, 
                    _self.m_memcanvas = chartFrame.m_memcanvas, _self.m_memcontext = chartFrame.m_memcontext, 
                    _self.didResetMinMax();
                    for (var __ii = 0; __ii < _self.m_arrTrendlineObjlist.length; __ii++) _self.m_arrTrendlineObjlist[__ii].ReSetFrame(chartFrame);
                }, this.didClearSelfDatas = function() {}, this.didGetScaleUnit = function(isCopy) {
                    return !0 === isCopy ? xUtils.didClone(_self.m_xScaleInfo.current) : _self.m_xScaleInfo.current;
                }, this.GetScaleInfo = function(argScaleUnit) {
                    if (void 0 !== argScaleUnit && null != argScaleUnit) {
                        var xScaleUnit = _self.didGetScaleUnit(!0);
                        argScaleUnit.minMaxScreen = xUtils.didClone(xScaleUnit.minMaxScreen), argScaleUnit.minMaxTotal = xUtils.didClone(xScaleUnit.minMaxTotal);
                    }
                }, this.didApplyScaleUnit = function(argScaleUnit) {
                    void 0 !== argScaleUnit && null != argScaleUnit && (_self.m_xScaleInfo.current.minMaxScreen.maxValue = argScaleUnit.minMaxScreen.maxValue, 
                    _self.m_xScaleInfo.current.minMaxScreen.minValue = argScaleUnit.minMaxScreen.minValue);
                }, this.didClearDatas = function() {
                    _self.didClearSelfDatas(), _self.didResetMinMax();
                }, this.didResetMinMax = function() {
                    xUtils.scale.didResetScaleUnit(_self.m_xScaleInfo.current);
                }, this.didRemoveAllLineTools = function() {
                    _self.didClearLineStudyObject();
                }, this.didFindSelectedLineTool = function() {
                    for (var nObjectCount = _self.m_arrTrendlineObjlist.length, ii = 0; ii < nObjectCount; ii++) {
                        var xDoLs = _self.m_arrTrendlineObjlist[ii];
                        if (void 0 !== xDoLs && null != xDoLs && !0 === xDoLs.m_bSelect) return {
                            index: ii,
                            ls: xDoLs
                        };
                    }
                }, this.didGetCountForAllTrenslines = function() {
                    return _self.m_arrTrendlineObjlist.length;
                }, this.didRemoveTargetLineTool = function(argDoLs) {
                    for (var nObjectCount = _self.m_arrTrendlineObjlist.length, ii = 0; ii < nObjectCount; ii++) if (!0 === function(argObj) {
                        return void 0 !== argObj && null != argObj && argDoLs === argObj && (argObj.didDestroy(), 
                        !0);
                    }(_self.m_arrTrendlineObjlist[ii])) return delete _self.m_arrTrendlineObjlist[ii], 
                    _self.m_arrTrendlineObjlist.splice(ii, 1), !0;
                    return !1;
                }, this.didRemoveSelectedLineTool = function() {
                    for (var nObjectCount = _self.m_arrTrendlineObjlist.length, ii = 0; ii < nObjectCount; ii++) if (!0 === function(argObj) {
                        return void 0 !== argObj && null != argObj && !0 === argObj.m_bSelect && (argObj.didDestroy(), 
                        !0);
                    }(_self.m_arrTrendlineObjlist[ii])) return delete _self.m_arrTrendlineObjlist[ii], 
                    _self.m_arrTrendlineObjlist.splice(ii, 1), !0;
                    return !1;
                }, this.didClearLineStudyObject = function() {
                    for (var nObjectCount = _self.m_arrTrendlineObjlist.length, ii = 0; ii < nObjectCount; ii++) !function(argObj) {
                        void 0 !== argObj && null != argObj && argObj.didDestroy();
                    }(_self.m_arrTrendlineObjlist[ii]), delete _self.m_arrTrendlineObjlist[ii];
                    _self.m_arrTrendlineObjlist = [];
                }, this.didClearSubObjects = function() {}, this.didDestroy = function() {
                    _self.didClearLineStudyObject(), _self.didClearSubObjects();
                }, this.didDrawSelectedMark = function(argLocalPosX, argLocalPosY) {
                    var __radius = _self.m_chartFrame.didGetSelectionMarkRadius(), __drawCircleParam = {
                        context: _self.m_context,
                        pt: {
                            x: argLocalPosX,
                            y: argLocalPosY
                        },
                        radius: __radius,
                        lineWeight: 1,
                        lineColor: _self.m_drawWrapper.m_stEnv.System.SelectedMark.lineColor,
                        fillColor: _self.m_drawWrapper.m_stEnv.System.SelectedMark.fillColor
                    };
                    gxDc.Circle(__drawCircleParam);
                }, this.didGetShifRightCount = function() {
                    return 0;
                }, this.didGetShifLeftCount = function() {
                    return 0;
                }, this.didGetShiftValue = function() {
                    return _self.m_nShift;
                }, this.didGetPlotShiftValueAt = function(argNo) {
                    return 0;
                }, this.didGetPointValue = function() {
                    return this.m_point;
                }, this.didGetPointFactor = function() {
                    var nPointValue = _self.didGetPointValue();
                    return Math.pow(10, nPointValue);
                }, this.didDrawDataView = function(argDtp, argDataIndex) {
                    return argDtp;
                }, this.didDrawDataViewForSubItems = function(argDtp, argDataIndex) {
                    return argDtp;
                }, this.DrawDataView = function(argLineSeq, argLocalXPos) {
                    var lineSpace = _self.m_drawWrapper.m_stEnv.System.LineSpace, textSpace = _self.m_drawWrapper.m_stEnv.System.TextSpace, dataIndex = _self.GetXIndex(argLocalXPos), context = _self.m_context, startXPos = textSpace, ptDraw = {
                        x: startXPos,
                        y: (argLineSeq + 1) * lineSpace
                    }, font = _self.m_drawWrapper.m_stEnv.Font, fontColor = _self.m_drawWrapper.m_stEnv.FontColor, textSpace = _self.m_drawWrapper.m_stEnv.System.TextSpace, drawTextParam = {
                        context: context,
                        pt: {
                            x: ptDraw.x,
                            y: ptDraw.y
                        },
                        text: "",
                        font: font,
                        fillStyle: fontColor,
                        textSpace: textSpace
                    };
                    _self.didDrawDataView(drawTextParam, dataIndex);
                }, this.didDrawExtraObjects = function() {
                    _self.didDrawTrendLines();
                }, this.didDrawTrendLines = function() {}, this.didDrawSelf = function(posval) {}, 
                this.DrawObj = function(bResize, bFirst, bLast, posval) {
                    _self.didDrawSelf(posval), _self.didDrawExtraObjects();
                }, this.DrawSelectObj = function(posval) {
                    return _self.didDrawSelf(posval), !0 === _self.m_drawWrapper.didHitTest(_self.m_memcontext, posval) && (_self.m_bSelect = !0, 
                    !0);
                }, this.didHitTest = function(posval, hitTestTool) {
                    if (void 0 === hitTestTool || null == hitTestTool) return _self.DrawSelectObj(posval);
                    hitTestTool.willBeHitTest(), _self.didDrawSelf(posval);
                    var result = hitTestTool.didHitTest();
                    return hitTestTool.closeHitTest(), !0 === result && (!0 !== posval.__onmove__ && (_self.m_bSelect = !0), 
                    !0);
                }, this.ReceiveData = function() {}, this.ReceiveBlankData = function(iMarginGap) {}, 
                this.ReceiveDataExt = function() {}, this.didReceiveDataExt = function() {}, this.willBeReceivedRealData = function(receivedData) {}, 
                this.didReceiveRealData = function(receivedData) {}, this.willBeReceivedData = function(symbolInfo, receivedDatas) {
                    return !0;
                }, this.didReceiveData = function(symbolInfo, receivedDatas) {}, this.didCalculateData = function() {
                    return !0;
                }, this.didCalculateRealData = function(nStart, nDSize, nSSize) {
                    return !0;
                }, this.didCalculateDataForExtraObject = function(nStart, nDSize, nSSize) {
                    return !0;
                }, this.didReceiveDataExt = function() {}, this.didCalcMinMax = function(argScrSIdx, argScrSize, argFlag) {}, 
                this.didCalcRatioFactor = function() {
                    if (void 0 !== _self.m_xAxisY && null != _self.m_xAxisY) {
                        _self.m_xAxisY.SetMinMax(_self);
                        var base = _self.m_chartFrame.didGetBaseCoordinate(), xEnv = _self.didGetEnvInfo();
                        _self.m_xAxisY.CalcDrawInfo(base, xEnv);
                    }
                    var xScaleUnit = _self.m_xScaleInfo.current;
                    if (xUtils.scale.didCalcScaleUnit(xScaleUnit), xScaleUnit.minMaxScreen.diff <= 0) return !1;
                    var __base = _self.m_chartFrame.didGetBaseCoordinate();
                    return _self.m_iGridHeight = __base.height / xScaleUnit.minMaxScreen.diff, !0;
                }, this.didGetBaseCoordinate = function() {
                    var __result = this.m_chartFrame.didGetBaseCoordinate();
                    return __result.rv = this.m_iGridHeight, __result;
                }, this.GetXPos = function(argLocalIdx) {
                    return _self.m_chartFrame.GetXPos(argLocalIdx);
                }, this.GetXPosAtDataIndex = function(dataIndex) {
                    return _self.m_drawWrapper.GetXPosAtDataIndex(dataIndex);
                }, this.GetYValToPos = function(strPrice) {
                    return _self.GetYPos(strPrice);
                }, this.GetYPos = function(strPrice) {
                    var xScaleUnit = _self.m_xScaleInfo.current, __base = _self.didGetBaseCoordinate(), __nPriceDiff = xUtils.didConvertToPrice(strPrice) - xScaleUnit.minMaxScreen.minValue;
                    return xUtils.axis.didGetLocalYPos(__base, __nPriceDiff);
                }, this.GetYPosToVal = function(argLocalPosY) {
                    var __xVci = _self.didGetVerticalConvertInfo(argLocalPosY);
                    return xUtils.didRoundPrice(__xVci.min + __xVci.offset * __xVci.ratioPv);
                }, this.GetYPixelToVal = function(argOffset) {
                    var __xVci = _self.didGetVerticalConvertInfo(0);
                    return xUtils.didRoundPrice(argOffset * __xVci.ratioPv);
                }, this.GetXIndex = function(iXPos) {
                    return _self.m_drawWrapper.GetXIndex(iXPos);
                }, this.didGetVerticalConvertInfo = function(argLocalPosY) {
                    var xScaleUnit = _self.m_xScaleInfo.current, __result = {
                        min: xScaleUnit.minMaxScreen.minValue,
                        max: xScaleUnit.minMaxScreen.maxValue,
                        size: xUtils.scale.didCalcDiff(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue),
                        offset: 0,
                        ratioPv: 0,
                        ratioVp: 0
                    }, __base = _self.m_chartFrame.didGetBaseCoordinate();
                    return void 0 !== argLocalPosY && (__result.offset = __base.height + __base.y - argLocalPosY), 
                    __result.ratioPv = 0 !== __base.height ? __result.size / __base.height : 0, __result.ratioVp = 0 !== __result.size ? __base.height / __result.size : 0, 
                    __result;
                }, this.didGetPanelWidth = function() {
                    return _self.m_chartFrame.didGetPanelRect().width;
                }, this.didGetPanelHeight = function() {
                    return _self.m_chartFrame.didGetPanelRect().height;
                }, this.didGetPanelHalfWidth = function() {
                    return Math.round(_self.m_chartFrame.didGetPanelRect().width / 2);
                }, this.didGetPanelHalfHeight = function() {
                    return Math.round(_self.m_chartFrame.didGetPanelRect().height / 2);
                }, this.didGetPanelRect = function() {
                    return _self.m_chartFrame.didGetPanelRect();
                }, this.CreateTrendlineObj = function(lsName, posval) {
                    return null;
                }, this.didCreateTrendlineObj = function(lsName, posval, argLoadINfo, skipStore) {
                    if (!0 === _self.m_drawWrapper.hasTimeDatas()) {
                        var __doLs = doLsFactory.didCreateLineStudyInstance(lsName, argLoadINfo);
                        if (void 0 !== __doLs && null != __doLs) {
                            var xScaleUnit = _self.m_xScaleInfo.current;
                            return !0 !== __doLs.didInitObject(_self.m_chartFrame, lsName, posval, xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue, _self.m_drawWrapper, _self, argLoadINfo) ? (__doLs.didDestroy(), 
                            void (__doLs = null)) : (!0 !== skipStore && _self.m_arrTrendlineObjlist.push(__doLs), 
                            __doLs);
                        }
                    }
                }, this.didGetDataSize = function() {
                    return 0;
                }, this.didGetMinMaxAtRange = function(range) {}, this.didGetReferencedPriceObject = function() {
                    return _self.m_drawWrapper.didGetReferencedPriceObject();
                }, this.DrawLine = function(stStyle) {
                    stStyle.context.beginPath(), stStyle.context.moveTo(stStyle.startX, stStyle.startY), 
                    stStyle.context.lineTo(stStyle.endX, stStyle.endY), stStyle.context.lineWidth = stStyle.lineWidth, 
                    stStyle.context.strokeStyle = stStyle.lineColor, stStyle.context.stroke();
                }, this.DrawRectangle = function(stStyle) {
                    stStyle.context.beginPath(), stStyle.context.rect(stStyle.rectX, stStyle.rectY, stStyle.rectW, stStyle.rectH), 
                    stStyle.context.fillStyle = stStyle.fillColor, stStyle.context.fill(), stStyle.context.lineWidth = stStyle.lineWidth, 
                    stStyle.context.strokeStyle = stStyle.lineColor, stStyle.context.stroke();
                }, this.DrawCurveCircle = function(stStyle) {
                    var ox = stStyle.rectW / 2 * .5522848, oy = stStyle.rectH / 2 * .5522848, xe = stStyle.rectX + stStyle.rectW, ye = stStyle.rectY + stStyle.rectH, xm = stStyle.rectX + stStyle.rectW / 2, ym = stStyle.rectY + stStyle.rectH / 2;
                    stStyle.context.beginPath(), stStyle.context.moveTo(stStyle.rectX, ym), stStyle.context.bezierCurveTo(stStyle.rectX, ym - oy, xm - ox, stStyle.rectY, xm, stStyle.rectY), 
                    stStyle.context.bezierCurveTo(xm + ox, stStyle.rectY, xe, ym - oy, xe, ym), stStyle.context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye), 
                    stStyle.context.bezierCurveTo(xm - ox, ye, stStyle.rectX, ym + oy, stStyle.rectX, ym), 
                    stStyle.context.lineWidth = stStyle.lineWidth, stStyle.context.strokeStyle = stStyle.lineColor, 
                    stStyle.context.stroke();
                }, this.DrawSelectCircle = function(stStyle) {
                    stStyle.context.beginPath(), stStyle.context.arc(stStyle.iLeft, stStyle.iTop, stStyle.iRadius, 0, 2 * Math.PI, !0), 
                    stStyle.context.fillStyle = stStyle.fillColor, stStyle.context.fill(), stStyle.context.lineWidth = stStyle.lineWidth, 
                    stStyle.context.strokeStyle = stStyle.lineColor, stStyle.context.stroke();
                }, this.DrawText = function(stStyle) {
                    stStyle.context.save(), void 0 !== stStyle.fillColor && null != stStyle.fillColor && (stStyle.context.fillStyle = stStyle.fillColor), 
                    stStyle.context.fillText(stStyle.text, stStyle.left, stStyle.top), stStyle.context.restore();
                }, this.DrawPolyGon = function(stStyle) {
                    stStyle.context.beginPath(), stStyle.context.globalAlpha = .5, stStyle.context.moveTo(stStyle.iXPos0, stStyle.iYPos0), 
                    stStyle.context.lineTo(stStyle.iXPos1, stStyle.iYPos1), stStyle.context.lineTo(stStyle.iXPos2, stStyle.iYPos2), 
                    stStyle.context.lineTo(stStyle.iXPos3, stStyle.iYPos3), stStyle.context.fillStyle = stStyle.fillColor, 
                    stStyle.context.fill(), stStyle.context.strokeStyle = stStyle.lineColor, stStyle.context.stroke(), 
                    stStyle.context.globalAlpha = 1;
                }, this.didGetPropMinMaxVal = function() {}, this.didApplySetting = function(argSettings) {}, 
                this.didSetLoadInfoForTheLineTools = function(argLoadInfo) {
                    return !1;
                }, this.didGetSaveInfoOfTheLineTools = function() {}, this.didGetDisplayTitle = function(isSimple) {
                    return _self.m_strChartName;
                }, this.didGetDataViewDataAtPos = function(argLocalXPos) {}, this.GetAxisInfo = function() {};
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOContainerBase = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartDOLineStudies, global.WGC_CHART.chartAxisUnit) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1), __webpack_require__(24), __webpack_require__(3));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(gxDc, xUtils) {
            return function() {
                var _self = this;
                this.m_doParent = void 0, this.m_chartFrame = {}, this.m_strTrendlineName = "", 
                this.m_chartdraw = {}, this.m_arrData = [], this.m_posSelectVal = {}, this.m_xData1 = {
                    curPos: {
                        x: 0,
                        y: 0
                    },
                    prePos: {
                        x: 0,
                        y: 0
                    },
                    curValue: {
                        x: 0,
                        t: 0,
                        y: 0
                    }
                }, this.m_xData2 = {
                    curPos: {
                        x: 0,
                        y: 0
                    },
                    prePos: {
                        x: 0,
                        y: 0
                    },
                    curValue: {
                        x: 0,
                        t: 0,
                        y: 0
                    }
                }, this.m_xData3 = {
                    curPos: {
                        x: 0,
                        y: 0
                    },
                    prePos: {
                        x: 0,
                        y: 0
                    },
                    curValue: {
                        x: 0,
                        t: 0,
                        y: 0
                    }
                }, this.m_iSelectGubun = 0, this.m_iBaseWidth = 0, this.m_iBaseHeight = 0, this.m_iBaseOriginY = 0, 
                this.m_canvas = {}, this.m_context = {}, this.m_memcanvas = {}, this.m_memcontext = {}, 
                this.m_bSelect = !1, this.WIDTH = 0, this.HEIGHT = 0, this.m_nLineStyle = xUtils.constants.trendLineDefault.lineStyle, 
                this.m_nLineWeight = xUtils.constants.trendLineDefault.lineWeight, this.m_clrLineColor = xUtils.constants.trendLineDefault.lineColor, 
                this.m_clrFillColor = xUtils.constants.trendLineDefault.fillColor, this.m_clrFontColor = xUtils.constants.trendLineDefault.lineColor, 
                this.m_clrHitTestColor = xUtils.hitTest.config.color, this.m_bCreating = !0, this.m_bExtraPoint = !1, 
                this.m_drawWrapper = null, this.uniqueKey = null, this.m_nRemainCount = 0, this.didInitRemainCount = function() {
                    _self.m_nRemainCount = 2;
                }, this.didProcForRemainCount = function(isSet) {
                    !0 === isSet && --_self.m_nRemainCount < 0 && (_self.m_nRemainCount = 0);
                }, this.didInitExtraPoint = function() {
                    _self.m_bExtraPoint = !1;
                }, this.m_bHide = !1, this.m_bNonTouch = !1, this.didSetState = function(state) {}, 
                this.didInitObject = function(chartFrame, strTrendline, posval, iMaxPrice, iMinPrice, drawWrapper, doParent, argLoadInfo) {
                    if (_self.uniqueKey = xUtils.createGuid(), _self.m_drawWrapper = drawWrapper, _self.m_doParent = doParent, 
                    _self.ReSetFrame(chartFrame), _self.m_strTrendlineName = strTrendline, _self.didInitRemainCount(), 
                    _self.didInitExtraPoint(), _self.ReceiveData(), _self.SetBaseSize(), argLoadInfo) {
                        if (!0 !== argLoadInfo.isAdd) return !0 === _self.didSetLoadInfo(argLoadInfo);
                        _self.didSetLoadInfo(argLoadInfo);
                    }
                    return _self.SetStartPoint(posval, !0), _self.SetLastPoint(posval, !0), !0;
                }, this.didDestroy = function() {
                    _self.m_doParent = {}, _self.m_chartFrame = {}, _self.m_chartdraw = {}, _self.m_arrData = [], 
                    _self.m_posSelectVal = {}, _self.m_canvas = {}, _self.m_context = {}, _self.m_memcanvas = {}, 
                    _self.m_memcontext = {}, _self.m_drawWrapper = null;
                }, this.didGetEnvInfo = function() {
                    return _self.m_doParent.didGetEnvInfo();
                }, this.ReSetFrame = function(chartFrame) {
                    _self.m_chartFrame = chartFrame, _self.m_canvas = chartFrame.m_canvas, _self.HEIGHT = chartFrame.m_canvas.height, 
                    _self.WIDTH = chartFrame.m_canvas.width, _self.m_context = chartFrame.m_context, 
                    _self.m_memcanvas = chartFrame.m_memcanvas, _self.m_memcontext = chartFrame.m_memcontext;
                };
                var _didHitTest = function(posval) {
                    for (var imageData, xPosMargined = _self.m_chartFrame.GetRelativePostionX(posval.XPos), yPosMargined = _self.m_chartFrame.GetRelativePostionY(posval.YPos, posval.YPosAdjusted), i = -2; i <= 2; i++) for (var j = -3; j <= 2; j++) if (imageData = _self.m_memcontext.getImageData(xPosMargined + i, yPosMargined + j, 1, 1), 
                    imageData.data[3] > 0) return xPosMargined > _self.m_xData1.curPos.x - 3 && xPosMargined < _self.m_xData1.curPos.x + 3 && yPosMargined > _self.m_xData1.curPos.y - 3 && yPosMargined < _self.m_xData1.curPos.y + 3 ? _self.m_iSelectGubun = 1 : xPosMargined > _self.m_xData2.curPos.x - 3 && xPosMargined < _self.m_xData2.curPos.x + 3 && yPosMargined > _self.m_xData2.curPos.y - 3 && yPosMargined < _self.m_xData2.curPos.y + 3 ? _self.m_iSelectGubun = 2 : _self.m_bExtraPoint && xPosMargined > _self.m_xData3.curPos.x - 3 && xPosMargined < _self.m_xData3.curPos.x + 3 && yPosMargined > _self.m_xData3.curPos.y - 3 && yPosMargined < _self.m_xData3.curPos.y + 3 ? _self.m_iSelectGubun = 3 : _self.m_iSelectGubun = 0, 
                    _self.m_posSelectVal = posval, _self.m_xData1.prePos.x = _self.m_xData1.curPos.x, 
                    _self.m_xData1.prePos.y = _self.m_xData1.curPos.y, _self.m_xData2.prePos.x = _self.m_xData2.curPos.x, 
                    _self.m_xData2.prePos.y = _self.m_xData2.curPos.y, _self.m_xData3.prePos.x = _self.m_xData3.curPos.x, 
                    _self.m_xData3.prePos.y = _self.m_xData3.curPos.y, !0 !== posval.__onmove__ && (_self.m_bSelect = !0), 
                    _self;
                };
                this.didDrawObj = function(posval, extraDrawParam) {
                    var bHitTest = !1;
                    if (void 0 !== posval && null != posval && (bHitTest = !0), !0 !== _self.m_bHide && _self.didDrawSelf(bHitTest, extraDrawParam), 
                    !0 === bHitTest) {
                        if (_self.m_bNonTouch) return;
                        return _didHitTest(posval);
                    }
                };
                var _didCheckVertexPoint = function(posval, posvalAdjusted) {
                    var hitBoxSize = 3;
                    try {
                        hitBoxSize = Math.max(hitBoxSize, xUtils.hitTest.config.size);
                    } catch (e) {
                        console.warn(e);
                    }
                    var xPosMargined = posvalAdjusted.XPos, yPosMargined = posvalAdjusted.YPos;
                    xPosMargined > _self.m_xData1.curPos.x - hitBoxSize && xPosMargined < _self.m_xData1.curPos.x + hitBoxSize && yPosMargined > _self.m_xData1.curPos.y - hitBoxSize && yPosMargined < _self.m_xData1.curPos.y + hitBoxSize ? _self.m_iSelectGubun = 1 : xPosMargined > _self.m_xData2.curPos.x - hitBoxSize && xPosMargined < _self.m_xData2.curPos.x + hitBoxSize && yPosMargined > _self.m_xData2.curPos.y - hitBoxSize && yPosMargined < _self.m_xData2.curPos.y + hitBoxSize ? _self.m_iSelectGubun = 2 : _self.m_bExtraPoint && xPosMargined > _self.m_xData3.curPos.x - hitBoxSize && xPosMargined < _self.m_xData3.curPos.x + hitBoxSize && yPosMargined > _self.m_xData3.curPos.y - hitBoxSize && yPosMargined < _self.m_xData3.curPos.y + hitBoxSize ? _self.m_iSelectGubun = 3 : _self.m_iSelectGubun = 0, 
                    _self.m_posSelectVal = posval, _self.m_xData1.prePos.x = _self.m_xData1.curPos.x, 
                    _self.m_xData1.prePos.y = _self.m_xData1.curPos.y, _self.m_xData2.prePos.x = _self.m_xData2.curPos.x, 
                    _self.m_xData2.prePos.y = _self.m_xData2.curPos.y, _self.m_xData3.prePos.x = _self.m_xData3.curPos.x, 
                    _self.m_xData3.prePos.y = _self.m_xData3.curPos.y;
                };
                this.didHitTest = function(posval, hitTestTool, extraDrawParam) {
                    hitTestTool.willBeHitTest(), _self.didDrawSelf(!0, extraDrawParam);
                    var result, isHit = hitTestTool.didHitTest();
                    return !0 === isHit && (_didCheckVertexPoint(posval, hitTestTool.m_posvalHit), !0 !== posval.__onmove__ && (_self.m_bSelect = !0), 
                    result = _self), hitTestTool.closeHitTest(), result;
                }, this.didDrawSelectedMark = function(bHitTest, onepointInfo) {
                    if (!0 !== bHitTest) {
                        var pts = [];
                        if (void 0 === onepointInfo || null == onepointInfo) pts.push({
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        }), pts.push({
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        }); else if (onepointInfo.targets) for (var nCount = onepointInfo.targets.length, ii = 0; ii < nCount; ii++) pts.push(xUtils.didClone(onepointInfo.targets[ii])); else !0 === onepointInfo.isVert ? pts.push({
                            x: _self.m_xData1.curPos.x,
                            y: _self.didGetPanelHalfHeight()
                        }) : !0 === onepointInfo.isHorz ? pts.push({
                            x: _self.didGetPanelHalfWidth(),
                            y: _self.m_xData1.curPos.y
                        }) : !0 === onepointInfo.isVertex ? pts.push({
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        }) : pts.push({
                            x: _self.didGetPanelHalfWidth(),
                            y: _self.didGetPanelHalfHeight()
                        });
                        !0 === _self.m_bExtraPoint && pts.push({
                            x: _self.m_xData3.curPos.x,
                            y: _self.m_xData3.curPos.y
                        }), _self.DrawSelectionMark(pts);
                    }
                }, this.didDrawSelf = function(bHitTest) {}, this.DrawSelectObj = function(posval) {
                    return _self.didDrawObj(posval);
                }, this.DrawObj = function(iMaxPrice, iMinPrice, posval) {
                    _self.SetBaseSize(), _self.didDrawObj(posval);
                }, this.ReceiveData = function() {}, this.SetBaseSize = function() {
                    return !0;
                }, this.GetXPos = function(iIndex) {
                    return _self.m_drawWrapper.GetXPos(iIndex);
                }, this.GetYPos = function(strPrice) {
                    return _self.m_doParent.GetYPos(strPrice);
                }, this.GetXValToPos = function(strXVal, tickNo) {
                    var __scrIdx = _self.m_drawWrapper.didGetIndexOfTime(strXVal, tickNo, !0, !0);
                    return _self.GetXPos(__scrIdx);
                }, this.GetXPosToVal = function(argLocalXPos) {
                    return _self.m_drawWrapper.didGetTimedataAtPos(argLocalXPos, !0, !0);
                }, this.GetYValToPos = function(iPrice) {
                    return _self.GetYPos(iPrice);
                }, this.GetYPosToVal = function(iYPos, notUseRaw) {
                    var __nPrice = _self.m_doParent.GetYPosToVal(iYPos);
                    return !0 === notUseRaw && (__nPrice = xUtils.axis.didAdjustZFValue(__nPrice, !0)), 
                    __nPrice;
                }, this.DrawSelectionMark = function(pts) {
                    if (_self.m_bSelect) {
                        var xEnv = _self.didGetEnvInfo(), __radius = _self.m_chartFrame.didGetSelectionMarkRadius(), __drawCircleParam = {
                            context: _self.m_context,
                            pt: {
                                x: 0,
                                y: 0
                            },
                            radius: __radius,
                            lineWeight: 1,
                            lineColor: xEnv.System.SelectedMark.lineColor,
                            fillColor: xEnv.System.SelectedMark.fillColor
                        }, ii = 0;
                        for (ii in pts) {
                            var pt = pts[ii];
                            __drawCircleParam.pt.x = pt.x, __drawCircleParam.pt.y = pt.y, gxDc.Circle(__drawCircleParam);
                        }
                    }
                }, this.SetStartPoint = function(posval, isSet) {
                    var __posInPanel = _self.m_chartFrame.GetRelativePositionInPanel(posval.XPos, posval.YPos);
                    _self.m_xData1.curPos.x = __posInPanel.x.pos, _self.m_xData1.curPos.y = __posInPanel.y;
                    var xTimeData;
                    xTimeData = _self.GetXPosToVal(_self.m_xData1.curPos.x), void 0 !== xTimeData && null != xTimeData && (_self.m_xData1.curValue.x = xTimeData.dateTime, 
                    _self.m_xData1.curValue.t = xTimeData.tickNo), _self.m_xData1.curValue.y = _self.GetYPosToVal(_self.m_xData1.curPos.y), 
                    _self.didProcForRemainCount();
                }, this.SetLastPoint = function(posval, isSet) {
                    var __posInPanel = _self.m_chartFrame.GetRelativePositionInPanel(posval.XPos, posval.YPos);
                    _self.m_xData2.curPos.x = _self.m_chartFrame.SetXPosition(__posInPanel.x), _self.m_xData2.curPos.y = __posInPanel.y;
                    var xTimeData;
                    xTimeData = _self.GetXPosToVal(_self.m_xData2.curPos.x), void 0 !== xTimeData && null != xTimeData && (_self.m_xData2.curValue.x = xTimeData.dateTime, 
                    _self.m_xData2.curValue.t = xTimeData.tickNo), _self.m_xData2.curValue.y = _self.GetYPosToVal(_self.m_xData2.curPos.y), 
                    _self.didProcForRemainCount();
                }, this.SetMovePoint = function(posval) {
                    var xPosNew = _self.m_chartFrame.GetRelativePostionX(posval.XPos), xPosOld = _self.m_chartFrame.GetRelativePostionX(_self.m_posSelectVal.XPos), xIdx = _self.GetXIndex(xPosNew) - _self.GetXIndex(xPosOld), yIdx = posval.YPos - _self.m_posSelectVal.YPos, iSIdx = _self.GetXIndex(_self.m_xData1.prePos.x) + xIdx, iEIdx = _self.GetXIndex(_self.m_xData2.prePos.x) + xIdx, indexes = [ iSIdx, iEIdx ], iExtraIdx = 0;
                    _self.m_bExtraPoint && (iExtraIdx = _self.GetXIndex(_self.m_xData3.prePos.x) + xIdx, 
                    indexes.push(iExtraIdx));
                    var xTimeData;
                    _self.m_drawWrapper.IsOuterIndexes(indexes), _self.m_xData1.curPos.x = _self.m_drawWrapper.GetXPosAtDataIndex(iSIdx), 
                    xTimeData = _self.GetXPosToVal(_self.m_xData1.curPos.x), void 0 !== xTimeData && null != xTimeData && (_self.m_xData1.curValue.x = xTimeData.dateTime, 
                    _self.m_xData1.curValue.t = xTimeData.tickNo), _self.m_xData2.curPos.x = _self.m_drawWrapper.GetXPosAtDataIndex(iEIdx), 
                    xTimeData = _self.GetXPosToVal(_self.m_xData2.curPos.x), void 0 !== xTimeData && null != xTimeData && (_self.m_xData2.curValue.x = xTimeData.dateTime, 
                    _self.m_xData2.curValue.t = xTimeData.tickNo), _self.m_bExtraPoint && (_self.m_xData3.curPos.x = _self.m_drawWrapper.GetXPosAtDataIndex(iExtraIdx), 
                    void 0 !== (xTimeData = _self.GetXPosToVal(_self.m_xData3.curPos.x)) && null != xTimeData && (_self.m_xData3.curValue.x = xTimeData.dateTime, 
                    _self.m_xData3.curValue.t = xTimeData.tickNo));
                    var __frameArea = _self.m_chartFrame.didGetPanelRect();
                    _self.m_xData1.curPos.y = _self.m_xData1.prePos.y + yIdx - __frameArea.top, _self.m_xData1.curValue.y = _self.GetYPosToVal(_self.m_xData1.curPos.y), 
                    _self.m_xData2.curPos.y = _self.m_xData2.prePos.y + yIdx - __frameArea.top, _self.m_xData2.curValue.y = _self.GetYPosToVal(_self.m_xData2.curPos.y), 
                    _self.m_bExtraPoint && (_self.m_xData3.curPos.y = _self.m_xData3.prePos.y + yIdx - __frameArea.top, 
                    _self.m_xData3.curValue.y = _self.GetYPosToVal(_self.m_xData3.curPos.y));
                }, this.SetExtraPoint = function(posval, isSet) {
                    if (void 0 !== posval && null != posval) {
                        var __posInPanel = _self.m_chartFrame.GetRelativePositionInPanel(posval.XPos, posval.YPos);
                        _self.m_xData3.curPos.x = _self.m_chartFrame.SetXPosition(__posInPanel.x), _self.m_xData3.curPos.y = __posInPanel.y;
                        var xTimeData;
                        xTimeData = _self.GetXPosToVal(_self.m_xData3.curPos.x), void 0 !== xTimeData && null != xTimeData && (_self.m_xData3.curValue.x = xTimeData.dateTime, 
                        _self.m_xData3.curValue.t = xTimeData.tickNo), _self.m_xData3.curValue.y = _self.GetYPosToVal(_self.m_xData3.curPos.y), 
                        _self.didProcForRemainCount();
                    } else _self.m_xData3.curPos.x = _self.m_xData2.curPos.x, _self.m_xData3.curPos.y = _self.m_xData1.curPos.y, 
                    _self.m_xData3.curValue.x = _self.m_xData2.curValue.x, _self.m_xData3.curValue.y = _self.m_xData1.curValue.y;
                }, this.DrawSelectTrendLine = function(posval) {
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x), _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: _self.m_xData2.curPos.x,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#303030"
                    });
                }, this.DrawSelectHorizontalLine = function(posval) {
                    var __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = 0, _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.m_xData2.curPos.x = __xPanelRect.width, _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: _self.m_xData2.curPos.x,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                }, this.DrawSelectVerticalLine = function(posval) {
                    var __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData1.curPos.y = 0, 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = __xPanelRect.height, 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: _self.m_xData2.curPos.x,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                }, this.DrawSelectCrossLine = function() {
                    var __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData1.curPos.y = 0, 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: 0,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: 0,
                        endX: _self.m_xData2.curPos.x,
                        endY: __xPanelRect.height,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                }, this.DrawSelectTrendRectangle = function() {
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x), _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.DrawRectangle({
                        context: _self.m_memcontext,
                        rectX: _self.m_xData1.curPos.x,
                        rectY: _self.m_xData1.curPos.y,
                        rectW: _self.m_xData2.curPos.x - _self.m_xData1.curPos.x,
                        rectH: _self.m_xData2.curPos.y - _self.m_xData1.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf",
                        fillColor: "#ffffff"
                    });
                }, this.DrawSelectTrendCircle = function() {
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x), _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.DrawCircle({
                        context: _self.m_memcontext,
                        rectX: _self.m_xData1.curPos.x,
                        rectY: _self.m_xData1.curPos.y,
                        rectW: _self.m_xData2.curPos.x - _self.m_xData1.curPos.x,
                        rectH: _self.m_xData2.curPos.y - _self.m_xData1.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf",
                        fillColor: "#ffffff"
                    });
                }, this.DrawSelectTrendAngle = function() {
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x), _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: _self.m_xData2.curPos.x,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                    var iLen = Math.sqrt(Math.pow(_self.m_xData2.curPos.x - _self.m_xData1.curPos.x, 2) + Math.pow(_self.m_xData1.curPos.y - _self.m_xData2.curPos.y, 2));
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: _self.m_xData1.curPos.x + iLen,
                        endY: _self.m_xData1.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                    var iRad, iAngle, bDirection;
                    _self.m_xData1.curPos.x <= _self.m_xData2.curPos.x ? _self.m_xData1.curPos.y >= _self.m_xData2.curPos.y ? (iRad = Math.atan2(_self.m_xData1.curPos.y - _self.m_xData2.curPos.y, _self.m_xData2.curPos.x - _self.m_xData1.curPos.x), 
                    iAngle = -180 * iRad / Math.PI, bDirection = !0) : _self.m_xData1.curPos.y < _self.m_xData2.curPos.y && (iRad = Math.atan2(_self.m_xData2.curPos.y - _self.m_xData1.curPos.y, _self.m_xData2.curPos.x - _self.m_xData1.curPos.x), 
                    iAngle = 180 * iRad / Math.PI, bDirection = !1) : _self.m_xData1.curPos.y >= _self.m_xData2.curPos.y ? (iRad = Math.atan2(_self.m_xData1.curPos.y - _self.m_xData2.curPos.y, _self.m_xData1.curPos.x - _self.m_xData2.curPos.x), 
                    iAngle = -(180 - 180 * iRad / Math.PI), bDirection = !0) : _self.m_xData1.curPos.y < _self.m_xData2.curPos.y && (iRad = Math.atan2(_self.m_xData2.curPos.y - _self.m_xData1.curPos.y, _self.m_xData1.curPos.x - _self.m_xData2.curPos.x), 
                    iAngle = 180 - 180 * iRad / Math.PI, bDirection = !1);
                    var iRad = iLen / 3;
                    _self.DrawArc({
                        context: _self.m_memcontext,
                        iLeft: _self.m_xData1.curPos.x,
                        iTop: _self.m_xData1.curPos.y,
                        iDegrees: iAngle,
                        iRadius: iRad,
                        bDir: bDirection,
                        lineWidth: 1,
                        lineColor: "#599cbf",
                        fillColor: "#ffff96"
                    });
                }, this.DrawSelectFibRetracement = function() {
                    var __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x), _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var iHeight = Math.abs(_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), i618 = 61.8 * iHeight / 100, i500 = 50 * iHeight / 100, i382 = 38.2 * iHeight / 100, i236 = 23.6 * iHeight / 100;
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: _self.m_xData2.curPos.x,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.m_xData1.curPos.x <= _self.m_xData2.curPos.x && _self.m_xData1.curPos.y <= _self.m_xData2.curPos.y ? (_self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y - i618,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y - i618,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y - i500,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y - i500,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y - i382,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y - i382,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y - i236,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y - i236,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    })) : _self.m_xData1.curPos.x >= _self.m_xData2.curPos.x && _self.m_xData1.curPos.y >= _self.m_xData2.curPos.y ? (_self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y - i618,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y - i618,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y - i500,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y - i500,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y - i382,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y - i382,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y - i236,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y - i236,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    })) : _self.m_xData1.curPos.x <= _self.m_xData2.curPos.x && _self.m_xData1.curPos.y >= _self.m_xData2.curPos.y ? (_self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y - i618,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y - i618,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y - i500,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y - i500,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y - i382,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y - i382,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData2.curPos.y - i236,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y - i236,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    })) : _self.m_xData1.curPos.x >= _self.m_xData2.curPos.x && _self.m_xData1.curPos.y <= _self.m_xData2.curPos.y && (_self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y - i618,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y - i618,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y - i500,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y - i500,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y - i382,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y - i382,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData1.curPos.y - i236,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData1.curPos.y - i236,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }));
                }, this.DrawSelectFibTimeZone = function() {
                    var __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData1.curPos.y = 0, 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var iXStartIdx, iXIdx, iXPos, arrFiboTime = [ 1, 2, 3, 5, 8, 13, 21, 34, 58, 89, 144, 233, 377, 610, 987 ];
                    iXStartIdx = _self.GetXIndex(_self.m_xData2.curPos.x);
                    for (var iTotCount = _self.m_drawWrapper.GetBaseDataCount(), idx = 0; idx < arrFiboTime.length && !((iXIdx = iXStartIdx + (arrFiboTime[idx] - 1)) > iTotCount - 1); idx++) iXPos = _self.m_drawWrapper.GetXPosAtDataIndex(iXIdx), 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: iXPos,
                        startY: 0,
                        endX: iXPos,
                        endY: __xPanelRect.height,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                }, this.DrawSelectFibFan = function() {
                    var __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x), _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: _self.m_xData2.curPos.x,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                    var iYLeft, iYCenter, iYRight;
                    _self.m_xData1.curPos.x < _self.m_xData2.curPos.x ? (_self.m_xData1.curPos.y >= _self.m_xData2.curPos.y ? (iYLeft = _self.m_xData2.curPos.y + .382 * (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y), 
                    iYLeft = _self.m_xData1.curPos.y - (__xPanelRect.width - _self.m_xData1.curPos.x) / (_self.m_xData2.curPos.x - _self.m_xData1.curPos.x) * (_self.m_xData1.curPos.y - iYLeft), 
                    iYCenter = _self.m_xData2.curPos.y + .5 * (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y), 
                    iYCenter = _self.m_xData1.curPos.y - (__xPanelRect.width - _self.m_xData1.curPos.x) / (_self.m_xData2.curPos.x - _self.m_xData1.curPos.x) * (_self.m_xData1.curPos.y - iYCenter), 
                    iYRight = _self.m_xData2.curPos.y + .618 * (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y), 
                    iYRight = _self.m_xData1.curPos.y - (__xPanelRect.width - _self.m_xData1.curPos.x) / (_self.m_xData2.curPos.x - _self.m_xData1.curPos.x) * (_self.m_xData1.curPos.y - iYRight)) : _self.m_xData1.curPos.y < _self.m_xData2.curPos.y && (iYLeft = _self.m_xData2.curPos.y + .382 * (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), 
                    iYLeft = _self.m_xData1.curPos.y - (__xPanelRect.width - _self.m_xData1.curPos.x) / (_self.m_xData2.curPos.x - _self.m_xData1.curPos.x) * (iYLeft - _self.m_xData1.curPos.y), 
                    iYCenter = _self.m_xData2.curPos.y + .5 * (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), 
                    iYCenter = _self.m_xData1.curPos.y - (__xPanelRect.width - _self.m_xData1.curPos.x) / (_self.m_xData2.curPos.x - _self.m_xData1.curPos.x) * (iYCenter - _self.m_xData1.curPos.y), 
                    iYRight = _self.m_xData2.curPos.y + .618 * (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), 
                    iYRight = _self.m_xData1.curPos.y - (__xPanelRect.width - _self.m_xData1.curPos.x) / (_self.m_xData2.curPos.x - _self.m_xData1.curPos.x) * (iYRight - _self.m_xData1.curPos.y)), 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: __xPanelRect.width,
                        endY: iYLeft,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: __xPanelRect.width,
                        endY: iYCenter,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: __xPanelRect.width,
                        endY: iYRight,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    })) : _self.m_xData1.curPos.x > _self.m_xData2.curPos.x && (_self.m_xData1.curPos.y >= _self.m_xData2.curPos.y ? (iYLeft = _self.m_xData1.curPos.y + .382 * (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y), 
                    iYLeft = _self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) / (_self.m_xData1.curPos.x - _self.m_xData2.curPos.x) * (iYLeft - _self.m_xData2.curPos.y), 
                    iYCenter = _self.m_xData1.curPos.y + .5 * (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y), 
                    iYCenter = _self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) / (_self.m_xData1.curPos.x - _self.m_xData2.curPos.x) * (iYCenter - _self.m_xData2.curPos.y), 
                    iYRight = _self.m_xData1.curPos.y + .618 * (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y), 
                    iYRight = _self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) / (_self.m_xData1.curPos.x - _self.m_xData2.curPos.x) * (iYRight - _self.m_xData2.curPos.y)) : _self.m_xData1.curPos.y < _self.m_xData2.curPos.y && (iYLeft = _self.m_xData1.curPos.y + .382 * (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), 
                    iYLeft = _self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) / (_self.m_xData1.curPos.x - _self.m_xData2.curPos.x) * (_self.m_xData2.curPos.y - iYLeft), 
                    iYCenter = _self.m_xData1.curPos.y + .5 * (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), 
                    iYCenter = _self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) / (_self.m_xData1.curPos.x - _self.m_xData2.curPos.x) * (_self.m_xData2.curPos.y - iYCenter), 
                    iYRight = _self.m_xData1.curPos.y + .618 * (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), 
                    iYRight = _self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) / (_self.m_xData1.curPos.x - _self.m_xData2.curPos.x) * (_self.m_xData2.curPos.y - iYRight)), 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: iYLeft,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: iYCenter,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }), _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: iYRight,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    }));
                }, this.DrawSelectFibArc = function() {
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x), _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData1.curPos.x,
                        startY: _self.m_xData1.curPos.y,
                        endX: _self.m_xData2.curPos.x,
                        endY: _self.m_xData2.curPos.y,
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                    var iXCenter, iYCenter, iLenCenter, iLenLeft, iLenRight, iLeft, iRight;
                    if (_self.m_xData1.curPos.y >= _self.m_xData2.curPos.y) {
                        _self.m_xData1.curPos.x < _self.m_xData2.curPos.x ? (iXCenter = _self.m_xData1.curPos.x + (_self.m_xData2.curPos.x - _self.m_xData1.curPos.x) / 2, 
                        iYCenter = _self.m_xData2.curPos.y + (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y) / 2, 
                        iLenCenter = Math.sqrt(Math.pow(_self.m_xData2.curPos.x - iXCenter, 2) + Math.pow(iYCenter - _self.m_xData2.curPos.y, 2)), 
                        iLenLeft = 2 * iLenCenter * .382, iLenRight = 2 * iLenCenter * .618) : _self.m_xData1.curPos.x > _self.m_xData2.curPos.x ? (iXCenter = _self.m_xData2.curPos.x + (_self.m_xData1.curPos.x - _self.m_xData2.curPos.x) / 2, 
                        iYCenter = _self.m_xData1.curPos.y + (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y) / 2, 
                        iLenCenter = Math.sqrt(Math.pow(_self.m_xData1.curPos.x - iXCenter, 2) + Math.pow(iYCenter - _self.m_xData1.curPos.y, 2)), 
                        iLenLeft = 2 * iLenCenter * .382, iLenRight = 2 * iLenCenter * .618) : _self.m_xData1.curPos.x == _self.m_xData2.curPos.x && (iLenCenter = (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y) / 2, 
                        iLenLeft = .382 * (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y), iLenRight = .618 * (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y)), 
                        iLeft = _self.m_xData2.curPos.x - iLenLeft, iRight = _self.m_xData2.curPos.x + iLenLeft;
                        var iRad = xUtils.didCalcCenterPos(iLeft, iRight);
                        _self.DrawArc({
                            context: _self.m_memcontext,
                            iLeft: _self.m_xData1.curPos.x,
                            iTop: _self.m_xData1.curPos.y,
                            iRadius: iRad,
                            bDir: !0,
                            lineWidth: 1,
                            lineColor: "#599cbf",
                            fillColor: "#ffff96"
                        }), iLeft = _self.m_xData2.curPos.x - iLenCenter, iRight = _self.m_xData2.curPos.x + iLenCenter;
                        var iRad = xUtils.didCalcCenterPos(iLeft, iRight);
                        _self.DrawArc({
                            context: _self.m_memcontext,
                            iLeft: _self.m_xData1.curPos.x,
                            iTop: _self.m_xData1.curPos.y,
                            iRadius: iRad,
                            bDir: !0,
                            lineWidth: 1,
                            lineColor: "#599cbf",
                            fillColor: "#ffff96"
                        }), iLeft = _self.m_xData2.curPos.x - iLenRight, iRight = _self.m_xData2.curPos.x + iLenRight;
                        var iRad = xUtils.didCalcCenterPos(iLeft, iRight);
                        _self.DrawArc({
                            context: _self.m_memcontext,
                            iLeft: _self.m_xData1.curPos.x,
                            iTop: _self.m_xData1.curPos.y,
                            iRadius: iRad,
                            bDir: !0,
                            lineWidth: 1,
                            lineColor: "#599cbf",
                            fillColor: "#ffff96"
                        });
                    } else {
                        _self.m_xData1.curPos.x < _self.m_xData2.curPos.x ? (iXCenter = _self.m_xData1.curPos.x + (_self.m_xData2.curPos.x - _self.m_xData1.curPos.x) / 2, 
                        iYCenter = _self.m_xData2.curPos.y + (_self.m_xData1.curPos.y - _self.m_xData2.curPos.y) / 2, 
                        iLenCenter = Math.sqrt(Math.pow(_self.m_xData2.curPos.x - iXCenter, 2) + Math.pow(iYCenter - _self.m_xData2.curPos.y, 2)), 
                        iLenLeft = 2 * iLenCenter * .382, iLenRight = 2 * iLenCenter * .618) : _self.m_xData1.curPos.x > _self.m_xData2.curPos.x ? (iXCenter = _self.m_xData2.curPos.x + (_self.m_xData1.curPos.x - _self.m_xData2.curPos.x) / 2, 
                        iYCenter = _self.m_xData1.curPos.y + (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y) / 2, 
                        iLenCenter = Math.sqrt(Math.pow(_self.m_xData1.curPos.x - iXCenter, 2) + Math.pow(iYCenter - _self.m_xData1.curPos.y, 2)), 
                        iLenLeft = 2 * iLenCenter * .382, iLenRight = 2 * iLenCenter * .618) : _self.m_xData1.curPos.x == _self.m_xData2.curPos.x && (iLenCenter = (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y) / 2, 
                        iLenLeft = .382 * (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), iLenRight = .618 * (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y)), 
                        iLeft = _self.m_xData2.curPos.x - iLenLeft, iRight = _self.m_xData2.curPos.x + iLenLeft;
                        var iRad = xUtils.didCalcCenterPos(iLeft, iRight);
                        _self.DrawArc({
                            context: _self.m_memcontext,
                            iLeft: _self.m_xData1.curPos.x,
                            iTop: _self.m_xData1.curPos.y,
                            iRadius: iRad,
                            bDir: !1,
                            lineWidth: 1,
                            lineColor: "#599cbf",
                            fillColor: "#ffff96"
                        }), iLeft = _self.m_xData2.curPos.x - iLenCenter, iRight = _self.m_xData2.curPos.x + iLenCenter;
                        var iRad = xUtils.didCalcCenterPos(iLeft, iRight);
                        _self.DrawArc({
                            context: _self.m_memcontext,
                            iLeft: _self.m_xData1.curPos.x,
                            iTop: _self.m_xData1.curPos.y,
                            iRadius: iRad,
                            bDir: !1,
                            lineWidth: 1,
                            lineColor: "#599cbf",
                            fillColor: "#ffff96"
                        }), iLeft = _self.m_xData2.curPos.x - iLenRight, iRight = _self.m_xData2.curPos.x + iLenRight;
                        var iRad = xUtils.didCalcCenterPos(iLeft, iRight);
                        _self.DrawArc({
                            context: _self.m_memcontext,
                            iLeft: _self.m_xData1.curPos.x,
                            iTop: _self.m_xData1.curPos.y,
                            iRadius: iRad,
                            bDir: !1,
                            lineWidth: 1,
                            lineColor: "#599cbf",
                            fillColor: "#ffff96"
                        });
                    }
                }, this.DrawSelectGanFanUp = function() {
                    var __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData1.curPos.y = 0, 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var arrGannFan = [];
                    arrGannFan.push(_self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(1))), 
                    arrGannFan.push(_self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(.5))), 
                    arrGannFan.push(_self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(1 / 3))), 
                    arrGannFan.push(_self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(.25))), 
                    arrGannFan.push(_self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(1 / 8))), 
                    arrGannFan.push(_self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(2))), 
                    arrGannFan.push(_self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(3))), 
                    arrGannFan.push(_self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(4))), 
                    arrGannFan.push(_self.m_xData2.curPos.y - (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(8)));
                    for (var idx = 0; idx < arrGannFan.length; idx++) _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: parseInt(arrGannFan[idx]),
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                }, this.DrawSelectGanFanDown = function() {
                    var __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData1.curPos.y = 0, 
                    _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x), _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var arrGannFan = [];
                    arrGannFan.push(_self.m_xData2.curPos.y + (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(1))), 
                    arrGannFan.push(_self.m_xData2.curPos.y + (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(.5))), 
                    arrGannFan.push(_self.m_xData2.curPos.y + (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(1 / 3))), 
                    arrGannFan.push(_self.m_xData2.curPos.y + (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(.25))), 
                    arrGannFan.push(_self.m_xData2.curPos.y + (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(1 / 8))), 
                    arrGannFan.push(_self.m_xData2.curPos.y + (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(2))), 
                    arrGannFan.push(_self.m_xData2.curPos.y + (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(3))), 
                    arrGannFan.push(_self.m_xData2.curPos.y + (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(4))), 
                    arrGannFan.push(_self.m_xData2.curPos.y + (__xPanelRect.width - _self.m_xData2.curPos.x) * Math.tan(Math.atan(8)));
                    for (var idx = 0; idx < arrGannFan.length; idx++) _self.DrawLine({
                        context: _self.m_memcontext,
                        startX: _self.m_xData2.curPos.x,
                        startY: _self.m_xData2.curPos.y,
                        endX: __xPanelRect.width,
                        endY: parseInt(arrGannFan[idx]),
                        lineWidth: 1,
                        lineColor: "#599cbf"
                    });
                }, this.DrawLine = function(stStyle) {
                    stStyle.context.beginPath(), stStyle.context.moveTo(stStyle.startX, stStyle.startY), 
                    stStyle.context.lineTo(stStyle.endX, stStyle.endY), stStyle.context.lineWidth = stStyle.lineWidth, 
                    stStyle.context.strokeStyle = stStyle.lineColor, stStyle.context.stroke();
                }, this.DrawRectangle = function(stStyle) {
                    stStyle.context.save(), stStyle.context.beginPath(), stStyle.context.rect(stStyle.rectX, stStyle.rectY, stStyle.rectW, stStyle.rectH), 
                    stStyle.context.lineWidth = stStyle.lineWidth, stStyle.context.strokeStyle = stStyle.lineColor, 
                    stStyle.context.stroke(), void 0 != stStyle.fillAlpha && (stStyle.context.globalAlpha = stStyle.fillAlpha), 
                    stStyle.context.fillStyle = stStyle.fillColor, stStyle.context.fill(), stStyle.context.restore();
                }, this.DrawTriangle = function(stStyle) {
                    stStyle.context.save(), stStyle.context.beginPath(), stStyle.context.moveTo(stStyle.pt1.x, stStyle.pt1.y), 
                    stStyle.context.lineTo(stStyle.pt2.x, stStyle.pt2.y), stStyle.context.lineTo(stStyle.pt3.x, stStyle.pt3.y), 
                    stStyle.context.closePath(), stStyle.context.lineWidth = stStyle.lineWidth, stStyle.context.strokeStyle = stStyle.lineColor, 
                    stStyle.context.stroke(), void 0 != stStyle.fillAlpha && (stStyle.context.globalAlpha = stStyle.fillAlpha), 
                    stStyle.context.fillStyle = stStyle.fillColor, stStyle.context.fill(), stStyle.context.restore();
                }, this.DrawCircle = function(stStyle) {
                    stStyle.context.beginPath(), stStyle.context.arc(stStyle.iLeft, stStyle.iTop, stStyle.iRadius, 0, 2 * Math.PI, !0), 
                    stStyle.context.lineWidth = stStyle.lineWidth, stStyle.context.strokeStyle = stStyle.lineColor, 
                    stStyle.context.stroke(), stStyle.context.globalAlpha = 0, stStyle.context.fillStyle = stStyle.fillColor, 
                    stStyle.context.fill(), stStyle.context.globalAlpha = 1;
                }, this.DrawArc = function(stStyle) {
                    stStyle.context.beginPath(), stStyle.context.arc(stStyle.iLeft, stStyle.iTop, stStyle.iRadius, 0, Math.PI / 180 * stStyle.iDegrees, stStyle.bDir), 
                    stStyle.context.lineWidth = stStyle.lineWidth, stStyle.context.strokeStyle = stStyle.lineColor, 
                    stStyle.context.stroke(), stStyle.context.globalAlpha = 0, stStyle.context.fillStyle = stStyle.fillColor, 
                    stStyle.context.fill(), stStyle.context.globalAlpha = 1;
                }, this.DrawCircle2 = function(stStyle) {
                    ox = stStyle.rectW / 2 * .5522848, oy = stStyle.rectH / 2 * .5522848, xe = stStyle.rectX + stStyle.rectW, 
                    ye = stStyle.rectY + stStyle.rectH, xm = stStyle.rectX + stStyle.rectW / 2, ym = stStyle.rectY + stStyle.rectH / 2, 
                    stStyle.context.beginPath(), stStyle.context.moveTo(stStyle.rectX, ym), stStyle.context.bezierCurveTo(stStyle.rectX, ym - oy, xm - ox, stStyle.rectY, xm, stStyle.rectY), 
                    stStyle.context.bezierCurveTo(xm + ox, stStyle.rectY, xe, ym - oy, xe, ym), stStyle.context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye), 
                    stStyle.context.bezierCurveTo(xm - ox, ye, stStyle.rectX, ym + oy, stStyle.rectX, ym), 
                    stStyle.context.lineWidth = stStyle.lineWidth, stStyle.context.strokeStyle = stStyle.lineColor, 
                    stStyle.context.stroke();
                }, this.DrawSelectCircle = function(stStyle) {
                    stStyle.context.beginPath(), stStyle.context.arc(stStyle.iLeft, stStyle.iTop, stStyle.iRadius, 0, 2 * Math.PI, !0), 
                    stStyle.context.fillStyle = stStyle.fillColor, stStyle.context.fill(), stStyle.context.lineWidth = stStyle.lineWidth, 
                    stStyle.context.strokeStyle = stStyle.lineColor, stStyle.context.stroke();
                }, this.DrawText = function(stStyle) {
                    stStyle.context.fillText(stStyle.text, stStyle.left, stStyle.top);
                }, this.GetXIndex = function(iXPos) {
                    return _self.m_drawWrapper.GetXIndex(iXPos);
                }, this.didGetPanelWidth = function() {
                    return _self.m_chartFrame.didGetPanelRect().width;
                }, this.didGetPanelHeight = function() {
                    return _self.m_chartFrame.didGetPanelRect().height;
                }, this.didGetPanelHalfWidth = function() {
                    return Math.round(_self.m_chartFrame.didGetPanelRect().width / 2);
                }, this.didGetPanelHalfHeight = function() {
                    return Math.round(_self.m_chartFrame.didGetPanelRect().height / 2);
                }, this.didGetPanelRect = function() {
                    return _self.m_chartFrame.didGetPanelRect();
                }, this.didGetStyleInfo = function() {}, this.didSetLoadInfo = function(argLoadInfo) {
                    if (void 0 === argLoadInfo || null == argLoadInfo) return !1;
                    try {
                        var nLimit = 2;
                        !0 === _self.m_bExtraPoint && (nLimit = 3), "object" == typeof argLoadInfo.datas && void 0 !== argLoadInfo.datas.length && null != argLoadInfo.datas.length && argLoadInfo.datas.length >= nLimit ? (_self.m_xData1.curValue.x = argLoadInfo.datas[0].x, 
                        _self.m_xData1.curValue.y = argLoadInfo.datas[0].y, _self.m_xData1.curValue.t = argLoadInfo.datas[0].t, 
                        void 0 !== _self.m_xData1.curValue.t && null != _self.m_xData1.curValue.t || (_self.m_xData1.curValue.t = 0), 
                        _self.m_xData2.curValue.x = argLoadInfo.datas[1].x, _self.m_xData2.curValue.y = argLoadInfo.datas[1].y, 
                        _self.m_xData2.curValue.y = argLoadInfo.datas[1].y, void 0 !== _self.m_xData2.curValue.t && null != _self.m_xData2.curValue.t || (_self.m_xData2.curValue.t = 0), 
                        argLoadInfo.datas.length > 2 && (_self.m_xData3.curValue.x = argLoadInfo.datas[2].x, 
                        _self.m_xData3.curValue.y = argLoadInfo.datas[2].y, _self.m_xData3.curValue.t = argLoadInfo.datas[2].t, 
                        void 0 !== _self.m_xData3.curValue.t && null != _self.m_xData3.curValue.t || (_self.m_xData3.curValue.t = 0))) : "object" == typeof argLoadInfo.ds && void 0 !== argLoadInfo.ds.length && null != argLoadInfo.ds.length && argLoadInfo.ds.length >= nLimit && (_self.m_xData1.curValue.x = argLoadInfo.ds[0].x, 
                        _self.m_xData1.curValue.y = argLoadInfo.ds[0].y, _self.m_xData1.curValue.t = argLoadInfo.ds[0].t, 
                        void 0 !== _self.m_xData1.curValue.t && null != _self.m_xData1.curValue.t || (_self.m_xData1.curValue.t = 0), 
                        _self.m_xData2.curValue.x = argLoadInfo.ds[1].x, _self.m_xData2.curValue.y = argLoadInfo.ds[1].y, 
                        _self.m_xData2.curValue.t = argLoadInfo.ds[1].t, void 0 !== _self.m_xData2.curValue.t && null != _self.m_xData2.curValue.t || (_self.m_xData2.curValue.t = 0), 
                        argLoadInfo.ds.length > 2 && (_self.m_xData3.curValue.x = argLoadInfo.ds[2].x, _self.m_xData3.curValue.y = argLoadInfo.ds[2].y, 
                        _self.m_xData3.curValue.t = argLoadInfo.ds[2].t, void 0 !== _self.m_xData3.curValue.t && null != _self.m_xData3.curValue.t || (_self.m_xData3.curValue.t = 0))), 
                        argLoadInfo.style ? (_self.m_clrLineColor = argLoadInfo.style.lineColor, _self.m_clrFillColor = argLoadInfo.style.fillColor) : argLoadInfo.styles ? (_self.m_clrLineColor = argLoadInfo.styles.lineColor, 
                        _self.m_clrFillColor = argLoadInfo.styles.fillColor) : argLoadInfo.s && (_self.m_clrLineColor = argLoadInfo.s.lc, 
                        _self.m_clrFillColor = argLoadInfo.s.fc), _self.didSetLoadInfoRest(argLoadInfo);
                    } catch (e) {
                        return console.error(e), !1;
                    }
                    return !0;
                }, this.didGetObjectSaveInfo = function() {
                    var xResult = {
                        is: !0,
                        c: _self.m_strTrendlineName,
                        ds: [ {
                            x: _self.m_xData1.curValue.x,
                            y: _self.m_xData1.curValue.y,
                            t: _self.m_xData1.curValue.t
                        }, {
                            x: _self.m_xData2.curValue.x,
                            y: _self.m_xData2.curValue.y,
                            t: _self.m_xData2.curValue.t
                        } ],
                        s: {
                            lc: _self.m_clrLineColor,
                            fc: _self.m_clrFillColor
                        }
                    };
                    return !0 === _self.m_bExtraPoint && xResult.ds.push({
                        x: _self.m_xData3.curValue.x,
                        y: _self.m_xData3.curValue.y,
                        t: _self.m_xData3.curValue.t
                    }), _self.didAppendRestObjectSaveInfo(xResult), xResult;
                }, this.didSetLoadInfoRest = function(argLoadInfo) {
                    return !0;
                }, this.didAppendRestObjectSaveInfo = function(argSaveInfo) {
                    return !0;
                }, this.didApplySimpleAttribute = function(color, text) {
                    return _self.m_clrLineColor = color, _self.m_clrFillColor = color, !0;
                }, this.didGetLineColor = function(xEnv) {
                    return xEnv && xEnv.System.UseGlobalTrendlineColor ? xEnv.TrendlineColor : _self.m_clrLineColor;
                }, this.didGetFillColor = function(xEnv) {
                    return _self.m_clrFillColor;
                }, this.didGetFontColor = function(xEnv) {
                    return xEnv && xEnv.System.UseGlobalTrendlineColor ? xEnv.TrendlineColor : _self.m_clrFontColor;
                }, this.didGetText = function() {}, this.didGetSimpleAttribute = function() {
                    return {
                        color: _self.didGetLineColor(),
                        text: _self.didGetText()
                    };
                }, this.didGetSelectedColor = function(isSelect, color, systemColor) {
                    return color;
                }, this.isAutoDeleteObject = function() {
                    return !1;
                }, this.didGetPointValue = function() {
                    if (_self.m_doParent) return _self.m_doParent.didGetPointValue();
                }, this.didGetPointFactor = function() {
                    if (_self.m_doParent) return _self.m_doParent.didGetPointFactor();
                }, this.didSetDatas = function(argDataInfo) {
                    if (void 0 === argDataInfo || null == argDataInfo) return !1;
                    try {
                        if ("object" == typeof argDataInfo.datas) {
                            var data;
                            data = argDataInfo.datas[0], data && (_self.m_xData1.curValue.x = data.x, _self.m_xData1.curValue.y = data.y, 
                            _self.m_xData1.curValue.t = data.t, void 0 !== _self.m_xData1.curValue.t && null != _self.m_xData1.curValue.t || (_self.m_xData1.curValue.t = 0)), 
                            data = argDataInfo.datas[1], data && (_self.m_xData2.curValue.x = data.x, _self.m_xData2.curValue.y = data.y, 
                            _self.m_xData2.curValue.y = data.y, void 0 !== _self.m_xData2.curValue.t && null != _self.m_xData2.curValue.t || (_self.m_xData2.curValue.t = 0)), 
                            !0 === _self.m_bExtraPoint && (data = argDataInfo.datas[2]) && (_self.m_xData3.curValue.x = data.x, 
                            _self.m_xData3.curValue.y = data.y, _self.m_xData3.curValue.t = data.t, void 0 !== _self.m_xData3.curValue.t && null != _self.m_xData3.curValue.t || (_self.m_xData3.curValue.t = 0));
                        }
                    } catch (e) {
                        return console.error(e), !1;
                    }
                    return !0;
                }, this.debug = {}, this.debug.toString = function() {
                    return "xData1 = > " + JSON.stringify(_self.m_xData1) + "\nxData2 = > " + JSON.stringify(_self.m_xData2) + "\nxData3 = > " + JSON.stringify(_self.m_xData3) + "\n";
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOLineStudyBase = loadModule(global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartUtil) : module.exports = loadModule(__webpack_require__(1), __webpack_require__(0));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc, doBaseClass) {
            var _doOPUnitBase = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.m_xContainer = null, 
                this.m_bOrder = !0, this.m_doContainer = {}, this.m_xObjectInfo = {}, this.m_bDummyObject = !1, 
                this.didSetObjectInfo = function(argObjectInfo) {
                    void 0 !== argObjectInfo && null != argObjectInfo && (_self.m_xObjectInfo = xUtils.didClone(argObjectInfo), 
                    _self.didSetData(_self.m_xObjectInfo.dateTime, _self.m_xObjectInfo.price));
                }, this.didSetData = function(argDatetime, argPrice) {
                    _self.m_xData1.curValue.x = argDatetime, _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x), 
                    _self.m_xData1.curValue.y = argPrice, _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_bMoving = !1, _self.m_xData2.curValue.x = argDatetime, _self.m_xData2.curPos.x = _self.m_xData1.curPos.x, 
                    _self.m_xData2.curValue.y = argPrice, _self.m_xData2.curPos.y = _self.m_xData1.curPos.y;
                }, this.didInitObject = function(chartFrame, drawWrapper, doParent, doContainer, argUnitInfo) {
                    _self.m_drawWrapper = drawWrapper, _self.m_doParent = doParent, _self.m_doContainer = doContainer, 
                    _self.ReSetFrame(chartFrame), _self.ReceiveData(), _self.SetBaseSize(), _self.didSetObjectInfo(argUnitInfo);
                }, this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    if (_self.m_xData1.curPos.x = 0, _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = __xPanelRect.width, _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_bDummyObject, !(_self.m_xData1.curPos.y < 0 || _self.m_xData1.curPos.y > __xPanelRect.height)) {
                        var context = _self.m_context, font = _self.m_drawWrapper.m_stEnv.Font, lineColor = _self.m_clrLineColor, lineWidth = _self.m_nLineWeight, lineStyle = _self.m_nLineStyle, xStyleInfo = _self.didGetStyleInfo();
                        void 0 !== xStyleInfo && null != xStyleInfo && (!0 === _self.m_bDummyObject ? (lineColor = xStyleInfo.dummy.strokeColor, 
                        lineWidth = xStyleInfo.dummy.strokeWeight, lineStyle = xStyleInfo.dummy.strokeStyle, 
                        !0 === _self.m_xObjectInfo.ask ? lineColor = xStyleInfo.ask.strokeColor : !1 === _self.m_xObjectInfo.ask && (lineColor = xStyleInfo.bid.strokeColor)) : !0 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.ask.strokeColor, 
                        lineWidth = xStyleInfo.ask.strokeWeight, lineStyle = xStyleInfo.ask.strokeStyle) : !1 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.bid.strokeColor, 
                        lineWidth = xStyleInfo.bid.strokeWeight, lineStyle = xStyleInfo.bid.strokeStyle) : (lineColor = xStyleInfo.default.strokeColor, 
                        lineWidth = xStyleInfo.default.strokeWeight, lineStyle = xStyleInfo.default.strokeStyle));
                        var xEnv = _self.didGetEnvInfo();
                        isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                        _self.m_bSelect && 1 == xEnv.UseOepSelectedColor && (lineColor = xEnv.System.SelectedFill.lineColor));
                        var fontColor = lineColor, drawLineParam = {
                            context: context,
                            pt1: {
                                x: _self.m_xData1.curPos.x,
                                y: _self.m_xData1.curPos.y
                            },
                            pt2: {
                                x: _self.m_xData2.curPos.x,
                                y: _self.m_xData2.curPos.y
                            },
                            lineWidth: lineWidth,
                            lineColor: lineColor,
                            lineStyle: lineStyle
                        }, drawTextParam = {
                            context: context,
                            pt: {
                                x: 0,
                                y: 0
                            },
                            text: "",
                            font: font,
                            fillStyle: fontColor
                        }, drawRectParam = {
                            context: context,
                            rect: {
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            },
                            lineWidth: 1,
                            lineColor: lineColor,
                            fillColor: "#ffffff"
                        };
                        gxDc.Line(drawLineParam);
                        var strDisp = _self.m_xObjectInfo.buysell, textRect = gxDc.CalcRect2(strDisp, font);
                        if (drawRectParam.rect.width = textRect.width + 5, drawRectParam.rect.height = textRect.height, 
                        drawRectParam.rect.x = 5, drawRectParam.rect.y = _self.m_xData2.curPos.y - parseInt(textRect.height / 2), 
                        gxDc.Rectangle(drawRectParam), drawTextParam.text = strDisp, drawTextParam.pt.x = 7, 
                        drawTextParam.pt.y = _self.m_xData2.curPos.y, gxDc.TextOut(drawTextParam), !0 !== isHitTest) {
                            var iXPos = _self.didGetPanelHalfWidth(), pts = [ {
                                x: iXPos,
                                y: _self.m_xData2.curPos.y
                            } ];
                            _self.DrawSelectionMark(pts);
                        }
                    }
                }, this.didGetStyleInfo = function() {}, this.didDestroySubClass = function() {}, 
                this.didGetOepObjectInfo = function() {
                    if (_self.m_doParent) {
                        return {
                            origin: xUtils.didClone(_self.m_xObjectInfo),
                            symbol: _self.m_doParent.m_symbolInfo,
                            symbolCode: _self.m_doParent.m_symbolInfo.strCode,
                            price: _self.m_xData2.curValue.y,
                            isOrder: _self.m_bOrder
                        };
                    }
                }, this.didDrawLastValue = function(argDrawParam, dataIndex) {
                    if (void 0 !== argDrawParam && null != argDrawParam) {
                        var xEnv = _self.didGetEnvInfo();
                        argDrawParam.price = {}, argDrawParam.price.verpos = _self.didGetPointValue(), argDrawParam.price.value = _self.m_xData1.curValue.y;
                        var xStyleInfo = _self.didGetStyleInfo();
                        void 0 !== xStyleInfo && null != xStyleInfo && (_self.m_bSelect && 1 == xEnv.UseOepSelectedColor ? argDrawParam.price.color = xEnv.System.SelectedFill.lineColor : !0 === _self.m_xObjectInfo.ask ? argDrawParam.price.color = xStyleInfo.ask.strokeColor : !1 === _self.m_xObjectInfo.ask ? argDrawParam.price.color = xStyleInfo.bid.strokeColor : argDrawParam.price.color = xStyleInfo.default.strokeColor), 
                        xUtils.axis.didDrawLastValueOnYAxis(argDrawParam);
                    }
                }, this.debug.toString = function() {
                    return "objectInfo => " + JSON.stringify(_self.m_xObjectInfo) + "\nxData1 => " + JSON.stringify(_self.m_xData1) + "\nxData2 => " + JSON.stringify(_self.m_xData2) + "\nxData3 => " + JSON.stringify(_self.m_xData3) + "\n";
                };
            }, _doOrderUnit = function() {
                var _self = this;
                this.prototype = new _doOPUnitBase(), _doOPUnitBase.apply(this, arguments), this.m_bOrder = !0, 
                this.didGetStyleInfo = function() {
                    return _self.m_drawWrapper.m_stEnv.OrderStyleConfig;
                };
            }, _doPositUnit = function() {
                var _self = this;
                this.prototype = new _doOPUnitBase(), _doOPUnitBase.apply(this, arguments), this.m_bOrder = !1, 
                this.didGetStyleInfo = function() {
                    return _self.m_drawWrapper.m_stEnv.PositStyleConfig;
                };
            }, _exports = {};
            return _exports.didCreateOrderPositUnit = function(bOrderOrPosit, chartFrame, drawWrapper, doParent, doContainer, argUnitInfo) {
                var doLocal = null;
                return doLocal = !0 === bOrderOrPosit ? new _doOrderUnit() : new _doPositUnit(), 
                void 0 !== doLocal.didInitObject && doLocal.didInitObject(chartFrame, drawWrapper, doParent, doContainer, argUnitInfo), 
                doLocal;
            }, _exports.didGetBaseExtraUnitClass = function() {
                return _doOPUnitBase;
            }, _exports.didGetOrderUnitClass = function() {
                return _doOPUnitBase;
            }, _exports.didGetPositUnitClass = function() {
                return _doOPUnitBase;
            }, _exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOOrderPositUnit = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartDOLineStudyBase) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1), __webpack_require__(9));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, axisBaseClass) {
            return function(chartWrapper, drawWrapper) {
                this.prototype = new axisBaseClass(chartWrapper, drawWrapper), axisBaseClass.apply(this, arguments), 
                this.OBJECT_NAME = "NORMAL_AXIS", this.isNontime = !1;
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartXAxisPanelNormal = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.chartXAxisPanelBase) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(30));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        var xUtils = __webpack_require__(0), ngcFactory = __webpack_require__(13), zsScrollScreen = __webpack_require__(35);
        try {
            new (__webpack_require__(37))().didInitSite();
        } catch (e) {
            console.error(e);
        }
        var siteTools = __webpack_require__(38);
        $ ? ($.__wgcFactory__ = ngcFactory, $.__wgcUtils__ = xUtils, $.__zsScrollScreen__ = zsScrollScreen, 
        $.__siteTools__ = siteTools) : global && (global.__wgcFactory__ = ngcFactory, global.__wgcUtils__ = xUtils, 
        global.__zsScrollScreen__ = zsScrollScreen, global.__siteTools__ = siteTools);
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(sf, chartWrap, ev_crt) {
            var screenFactory = sf, exports = {};
            return exports.getScreenFactory = function() {
                return screenFactory;
            }, exports.getChartWrap = function(scrObj) {
                return new chartWrap(scrObj);
            }, exports.getChartDataConverter = function() {
                return new ev_crt();
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART["lib/ngcFactory"] = loadModule(global.WGC_CHART.screenFactory, global.WGC_CHART.chartWrap, global.WGC_CHART.chartDataConverter) : module.exports = loadModule(__webpack_require__(14), __webpack_require__(16), __webpack_require__(33));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(sm, Chart) {
            var screenManager = sm, chartClass = Chart, exports = {}, _chartSilo = {
                items: []
            }, _didFindChartInSiloByKey = function(argKey) {
                if (void 0 !== argKey && null != argKey) for (var nCount = _chartSilo.items.length, ii = 0; ii < nCount; ii++) {
                    var xItem = _chartSilo.items[ii];
                    if (xItem && argKey === xItem.key) return {
                        index: ii,
                        item: xItem
                    };
                }
            }, _didRegisterChartInSiloByKey = function(argKey, argChart) {
                return void 0 !== argKey && null != argKey && void 0 !== argChart && null != argChart && (_chartSilo.items.push({
                    key: argKey,
                    item: argChart
                }), !0);
            }, _didUnegisterChartInSiloByKey = function(argKey) {
                var xFind = _didFindChartInSiloByKey(argKey);
                return void 0 !== xFind && null != xFind && (_chartSilo.items.splice(xFind.ii, 1), 
                !0);
            };
            return exports.getScreenPanel = function(id) {
                return new ScreenPanel(id);
            }, exports.removeChartComponent = function(argKey) {
                return _didUnegisterChartInSiloByKey(argKey);
            }, exports.createScreenChartWithRegister = function(id) {
                var xChart = new chartClass(id), uniqueId = xChart.didGetUniqueId();
                return _didRegisterChartInSiloByKey(uniqueId, xChart), xChart;
            }, exports.getScreenChart = function(id) {
                return new chartClass(id);
            }, exports.getScreenManager = function() {
                return screenManager;
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART.screenFactory = loadModule(global.WGC_CHART.screenManager, global.WGC_CHART.screenChart) : module.exports = loadModule(__webpack_require__(4), __webpack_require__(15));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, parentClass, mouseCapture) {
            return function(id) {
                var _self = this, _classRef = this, _chartWrapper = null, _uniqueId = xUtils.createGuid(), _getTagetChildDOMElementById = function(scrobj, id) {
                    var jqElem = scrobj._$object.find("#" + id);
                    return $(jqElem).get(0);
                };
                this.prototype = new parentClass(), parentClass.apply(this, arguments), this.method = this.prototype.method, 
                this.method.superior = {}, this.method.classObj = this, this.method.className = "ScreenPanel", 
                this.method.id = id, this.method.mouseCapture = new mouseCapture(), this.method.m_chartWrap = null, 
                this.method.m_chartWrapChartType = null, this.method.m_chartWrapTrendline = null, 
                this.method.m_chartWrapDataConverter = null, this.method.m_chartWrapIndicator = null;
                for (var m in this.prototype.method) $.isFunction(this.prototype.method[m]) && (this.method.superior[m] = this.prototype.method[m]);
                this.m_eventTables = [];
                var _reflectMethodForOep = null, _reflectMethodForNewOrder = null, _reflectMethodForCancelOrder = null, _reflectMethodForExecutionOrder = null, _reflectMethodForNofifyingEventAboutDeletedIndicator = null, _reflectMethodForFocusing = null, _reflectMethodForDataViewInfo = null, _reflectMethodForTrendline = null, _reflectMethodForError = null, _reflectCallForRequestNextData = null, _reflectMethodForContextMenu = null, _reflectMethodForDetailView = null, _reflectMethodForDoubleClick = null;
                this.didInitScreen = function(argSettings, argPlotStyleInfos) {
                    _didInitEventTables(), void 0 !== (_chartWrapper = _self.method.m_chartWrap) && null != _chartWrapper && (_self.setChartEventHandler(), 
                    _chartWrapper.didInitChartWrapper(_self, argSettings, argPlotStyleInfos), _self.DidCallAfterDoneWithOnLoad());
                }, this.didGetUniqueId = function() {
                    return _uniqueId;
                }, this.didStartCapture = function(eventElem) {
                    _self.method.mouseCapture.didStartCapture(eventElem, _self.OnMouseMove, _self.OnMouseUp);
                }, this.setChartEventHandler = function() {
                }, this.OnResize = function() {
                    _chartWrapper.OnResize();
                }, this.OnMouseOver = function(strId) {
                    alert(_classRef.method.className + "(" + _classRef.method.id + "):" + strId);
                }, this.OnMouseDown = function(event) {
                    _self.didReflectCallForFocusing();
                    var __event = event || window.event;
                    !0 !== _self.didGetEnvInfo().UseContextMenu && 0 != __event.button || !0 !== _chartWrapper.OnMouseDown(__event) && _self.didStartCapture(__event.currentTarget);
                }, this.OnMouseUp = function(event, capturedObj) {
                    var __event = event || window.event;
                    _chartWrapper.OnMouseUp(__event, capturedObj);
                }, this.OnMouseMove = function(event, capturedObj) {
                    var __event = event || window.event;
                    _chartWrapper.OnMouseMove(__event, capturedObj);
                }, this.OnDragOver = function(event) {
                    var __event = event || window.event;
                    _chartWrapper.OnDragOver(__event);
                }, this.OnMouseWheel = function(event) {
                    var __event = event || window.event;
                    _chartWrapper.OnMouseWheel(__event);
                }, this.OnKeyDown = function(event) {
                    var __event = event || window.event;
                    _chartWrapper.OnKeyDown(__event);
                }, this.OnDoubleClick = function(event) {
                    var __event = event || window.event;
                    _chartWrapper.OnDoubleClick(__event);
                }, this.OnSwipe = function(event) {
                    return;
                }, this.OnUnload = function() {
                    _self.method.m_chartWrap.OnDestroy(), delete _self.method.m_chartWrap, _self.method.m_chartWrap = null, 
                    _chartWrapper = null, delete _self.method.m_chartWrapTrendline, _self.method.m_chartWrapTrendline = null, 
                    delete _self.method.m_chartWrapChartType, _self.method.m_chartWrapChartType = null, 
                    delete _self.method.m_chartWrapDataConverter, _self.method.m_chartWrapDataConverter = null, 
                    delete _self.method.m_chartWrapIndicator, _self.method.m_chartWrapIndicator = null, 
                    delete _self.method.mouseCapture, _self.mouseCapture = null;
                }, this.OnContextMenu = function(event) {
                    _self.didReflectCallForFocusing();
                    var __event = event || window.event;
                    _chartWrapper.OnContextMenu(__event), event.preventDefault();
                }, this.didRegisterEventForDomElemResize = function() {
                    if (window.addEventListener) try {
                        window.addEventListener("resize", _self.OnWindowResized, !1);
                    } catch (e) {
                        console.error(e);
                    } else if (window.attachEvent) try {
                        window.attachEvent("resize", _self.OnWindowResized, !1);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didUnregisterEventForDomElemResize = function() {
                    if (window.removeListener) try {
                        window.removeListener("resize", _self.OnWindowResized, !1);
                    } catch (e) {
                        console.error(e);
                    } else if (window.detachEvent) try {
                        window.detachEvent("resize", _self.OnWindowResized, !1);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.OnWindowResized = function() {
                    var devicePixelRatio = window.devicePixelRatio || 1;
                    _self.__devicePixelRatio__ != devicePixelRatio && (_self.__devicePixelRatio__ = devicePixelRatio, 
                    _self.OnResize());
                }, this.DidCallAfterDoneWithOnLoad = function() {
                    this.addEventOfChartDraw(), this.didRegisterEventForDomElemResize(), _chartWrapper.didCallAfterDoneWithOnLoad();
                }, this.clearEventOfChartDraw = function() {
                    var targetElement = _getTagetChildDOMElementById(_self, "idChartWrap");
                    if (targetElement.removeListener) for (var __ii in _eventTables) {
                        var __eventItem = _eventTables[__ii];
                        if (void 0 === __eventItem || null == __eventItem || void 0 === __eventItem.handler) break;
                        targetElement.removeListener(__eventItem.eventNane, __eventItem.handler, !1);
                    } else if (targetElement.detachEvent) for (var __ii in _self.m_eventTables) {
                        var __eventItem = _self.m_eventTables[__ii];
                        if (void 0 === __eventItem || null == __eventItem || void 0 === __eventItem.handler) break;
                        targetElement.detachEvent(__eventItem.eventNane, __eventItem.handler, !1);
                    }
                }, this.addEventOfChartDraw = function() {
                    var targetElement = _getTagetChildDOMElementById(_self, "idChartWrap");
                    if (targetElement.addEventListener) for (var __ii in _self.m_eventTables) {
                        var __eventItem = _self.m_eventTables[__ii];
                        if (void 0 === __eventItem || null == __eventItem || void 0 === __eventItem.handler) break;
                        targetElement.addEventListener(__eventItem.eventNane, __eventItem.handler, !1);
                    } else if (targetElement.attachEvent) for (var __ii in _self.m_eventTables) {
                        var __eventItem = _self.m_eventTables[__ii];
                        if (void 0 === __eventItem || null == __eventItem || void 0 === __eventItem.handler) break;
                        targetElement.attachEvent(__eventItem.eventNane, __eventItem.handler, !1);
                    }
                };
                var _didInitEventTables = function() {
                    _self.m_eventTables.push({
                        eventNane: "unload",
                        handler: _self.OnUnload
                    }), _self.m_eventTables.push({
                        eventNane: "resize",
                        handler: _self.OnResize
                    }), _self.m_eventTables.push({
                        eventNane: "mousedown",
                        handler: _self.OnMouseDown
                    }), _self.m_eventTables.push({
                        eventNane: "mouseup",
                        handler: _self.OnMouseUp
                    }), _self.m_eventTables.push({
                        eventNane: "mousemove",
                        handler: _self.OnMouseMove
                    }), _self.m_eventTables.push({
                        eventNane: "keydown",
                        handler: _self.OnKeyDown
                    }), _self.m_eventTables.push({
                        eventNane: "dblclick",
                        handler: _self.OnDoubleClick
                    }), _self.m_eventTables.push({
                        eventNane: "mousewheel",
                        handler: _self.OnMouseWheel
                    }), _self.m_eventTables.push({
                        eventNane: "DOMMouseScroll",
                        handler: _self.OnMouseWheel
                    }), _self.m_eventTables.push({
                        eventNane: "contextmenu",
                        handler: _self.OnContextMenu
                    }), _self.m_eventTables.push({
                        eventNane: "__end__",
                        handler: void 0
                    }), _self.m_eventTables.push({
                        eventNane: "dragover",
                        handler: _self.OnDragOver
                    }), _self.m_eventTables.push({
                        eventNane: "keypress",
                        handler: _self.OnKeyDown
                    }), _self.m_eventTables.push({
                        eventNane: "storage",
                        handler: _self.OnStorageChange
                    });
                };
                this.didApplyZoomInOut = function(isIn, step) {
                    return _chartWrapper.didApplyZoomInOut(isIn, step);
                }, this.didApplyGoToEndPos = function(bEndPos, isNotFix) {
                    return _chartWrapper.didApplyGoToEndPos(bEndPos, isNotFix);
                }, this.didAddIndicator = function(code, info) {
                    return _chartWrapper.didAddIndicator(code, info);
                }, this.didChangeIndicatorSettingByTypeId = function(argTypeId, argSettings) {
                    return _chartWrapper.didChangeIndicatorSettingByTypeId(argTypeId, argSettings, !0);
                }, this.didChangeBasicChartType = function(argName) {
                    return _chartWrapper.didChangeBasicChartType(argName);
                }, this.didGetCurrentIndicatorInformationAll = function(isSave, toString) {
                    var xResult = _chartWrapper.didGetCurrentIndicatorInformationAll(isSave);
                    return toString ? JSON.stringify(xResult) : xResult;
                }, this.didSetCurrentIndicatorInformationAll = function(argInfo) {
                    var info = argInfo;
                    _chartWrapper.didSetCurrentIndicatorInformationAll(info);
                    return !0;
                }, this.didGetCurrentIndicatorInformationByTypeId = function(argTypeId) {
                    var xResult = _chartWrapper.didGetCurrentIndicatorInformationByTypeId(argTypeId);
                    return JSON.stringify(xResult);
                }, this.didDeleteIndicatorByTypeId = function(argTypeId) {
                    return _chartWrapper.didDeleteIndicatorByTypeId(argTypeId);
                }, this.didDeleteAllIndicators = function() {
                    return _chartWrapper.didDeleteAllIndicators();
                }, this.didDeleteSelectedIndicator = function() {
                    return _chartWrapper.didDeleteSelectedIndicator();
                }, this.didSetFocusingFlag = function(argFocusing, argRefresh) {
                    return _chartWrapper.didSetFocusingFlag(argFocusing, argRefresh);
                }, this.didReflectCallForContextMenu = function(argData) {
                    if (void 0 !== argData && null != argData) return console.debug(argData), void 0 !== _reflectMethodForContextMenu && null != _reflectMethodForContextMenu ? _reflectMethodForContextMenu(_self, argData) : void 0;
                }, this.didReflectCallForCancelOrder = function(argData) {
                    if (void 0 !== argData && null != argData) return void 0 !== _reflectMethodForCancelOrder && null != _reflectMethodForCancelOrder ? _reflectMethodForCancelOrder(_self, argData) : void 0;
                }, this.didReflectCallForExecutionOrder = function(argData) {
                    if (void 0 !== argData && null != argData) return void 0 !== _reflectMethodForExecutionOrder && null != _reflectMethodForExecutionOrder ? _reflectMethodForExecutionOrder(_self, argData) : void 0;
                }, this.didReflectCallForFocusing = function() {
                    if (_self.didSetFocusingFlag(!0, !1), void 0 !== _reflectMethodForFocusing && null != _reflectMethodForFocusing) return _reflectMethodForFocusing(_self);
                }, this.didReflectCallForIndicatorIsDeleted = function(argInfo) {
                    if (void 0 !== argInfo && null != argInfo) return void 0 !== _reflectMethodForNofifyingEventAboutDeletedIndicator && null != _reflectMethodForNofifyingEventAboutDeletedIndicator ? _reflectMethodForNofifyingEventAboutDeletedIndicator(_self, argInfo) : void 0;
                }, this.didReflectCallForNewOrder = function(argOrder) {
                    void 0 !== argOrder && null != argOrder && void 0 !== _reflectMethodForNewOrder && null != _reflectMethodForNewOrder && _reflectMethodForNewOrder(_self, argOrder);
                }, this.didReflectCallForDetailView = function(argData) {
                    console.debug(argData), void 0 !== _reflectMethodForDetailView && null != _reflectMethodForDetailView && _reflectMethodForDetailView(argData);
                }, this.didReflectCallForOepValueIsChanged = function(argOepValue) {
                    void 0 !== argOepValue && null != argOepValue && void 0 !== _reflectMethodForOep && null != _reflectMethodForOep && _reflectMethodForOep(_self, argOepValue);
                }, this.didReflectCallForDataViewInfo = function(argData) {
                    void 0 !== argData && null != argData && void 0 !== _reflectMethodForDataViewInfo && null != _reflectMethodForDataViewInfo && _reflectMethodForDataViewInfo(_self, argData);
                }, this.didReflectCallForError = function(argErrorCode) {
                    void 0 !== _reflectMethodForError && null != _reflectMethodForError && _reflectMethodForError(_self, argErrorCode);
                }, this.didReflectCallForTrendline = function(argInfo) {
                    void 0 !== _reflectMethodForTrendline && null != _reflectMethodForTrendline && _reflectMethodForTrendline(_self, argInfo);
                }, this.didReflectCallForRequestNextData = function() {
                    void 0 !== _reflectCallForRequestNextData && null != _reflectCallForRequestNextData && _reflectCallForRequestNextData(_self);
                }, this.didReflectCallForDoubleClick = function(argInfo) {
                    void 0 !== _reflectMethodForDoubleClick && null != _reflectMethodForDoubleClick && _reflectMethodForDoubleClick(_self, argInfo);
                }, this.didSetLoadInfoForTheLineTools = function(argLoadInfos) {
                    return _chartWrapper.didSetLoadInfoForTheLineTools(argLoadInfos);
                }, this.didGetSaveInfoOfTheLineTools = function(toString) {
                    var xResult = _chartWrapper.didGetSaveInfoOfTheLineTools();
                    return !0 === toString ? JSON.stringify(xResult) : xResult;
                }, this.didRegisterReflector = function(argType, argMethod) {
                    "oep" === argType ? _reflectMethodForOep = argMethod : "contextMenu" === argType ? _reflectMethodForContextMenu = argMethod : "newOrder" === argType ? _reflectMethodForNewOrder = argMethod : "cancelOrder" === argType ? _reflectMethodForCancelOrder = argMethod : "executionOrder" === argType ? _reflectMethodForExecutionOrder = argMethod : "focus" === argType ? _reflectMethodForFocusing = argMethod : "indicator" === argType ? _reflectMethodForNofifyingEventAboutDeletedIndicator = argMethod : "dataview" === argType ? _reflectMethodForDataViewInfo = argMethod : "error" === argType ? _reflectMethodForError = argMethod : "trendline" === argType ? _reflectMethodForTrendline = argMethod : "nextData" === argType ? _reflectCallForRequestNextData = argMethod : "detailView" === argType ? _reflectMethodForDetailView = argMethod : "doubleClick" === argType && (_reflectMethodForDoubleClick = argMethod);
                }, this.didSetChartConfig = function(argConfig) {
                    return _chartWrapper.didSetChartConfig(argConfig);
                }, this.didUpdateBusinessDate = function(businessDate, bDraw, timeZoneInfo) {
                    _self.method.m_chartWrapDataConverter && _self.method.m_chartWrapDataConverter.OnReceiveBusinessDate && _self.method.m_chartWrapDataConverter.OnReceiveBusinessDate(businessDate, bDraw, timeZoneInfo);
                }, this.didRecvChartDataFromServer = function(receiveRawDatas, receiveInfo, timeZoneInfo) {
                    if (void 0 !== _self.method.m_chartWrapDataConverter && null != _self.method.m_chartWrapDataConverter) {
                        var requestInfo = xUtils.dataConverter.didGetDefaultRequestInfo();
                        requestInfo.receiveInfo = receiveInfo, requestInfo.strCode = receiveInfo.code, requestInfo.strName = receiveInfo.name, 
                        requestInfo.nTType = receiveInfo.timeType, requestInfo.nTGap = receiveInfo.timeGap, 
                        requestInfo.nPValCrt = receiveInfo.pointValue, requestInfo.strDispTab = receiveInfo.display, 
                        _self.method.m_chartWrapDataConverter.OnReceiveData(receiveRawDatas, requestInfo, timeZoneInfo);
                    }
                }, this.didRecvChartNextDataFromServer = function(receiveRawDatas) {
                    void 0 !== _self.method.m_chartWrapDataConverter && null != _self.method.m_chartWrapDataConverter && _self.method.m_chartWrapDataConverter.OnReceiveNextData(receiveRawDatas);
                }, this.didRecvChartRealDataFromServer = function(receiveRawDatas) {
                    void 0 !== _self.method.m_chartWrapDataConverter && null != _self.method.m_chartWrapDataConverter && _self.method.m_chartWrapDataConverter.OnReceiveRealDatas(receiveRawDatas);
                }, this.didClearDatas = function() {
                    return void 0 !== _self.method.m_chartWrapDataConverter && null != _self.method.m_chartWrapDataConverter && _self.method.m_chartWrapDataConverter.didClearDatas(), 
                    _chartWrapper.didClearDatas();
                }, this.didClearOrderPositObjects = function(isOrder, isPosit) {
                    return _chartWrapper.didClearOrderPositObjects(isOrder, isPosit);
                }, this.didRecvChartDataFromServerAt = function(receiveRawDatas, receiveInfo, timeZoneInfo, id) {
                    if (void 0 !== _self.method.m_chartWrapDataConverter && null != _self.method.m_chartWrapDataConverter) {
                        var requestInfo = xUtils.dataConverter.didGetDefaultRequestInfo();
                        requestInfo.receiveInfo = receiveInfo, requestInfo.strCode = receiveInfo.code, requestInfo.strName = receiveInfo.name, 
                        requestInfo.nTType = receiveInfo.timeType, requestInfo.nTGap = receiveInfo.timeGap, 
                        requestInfo.nPValCrt = receiveInfo.pointValue, requestInfo.strDispTab = receiveInfo.display, 
                        _self.method.m_chartWrapDataConverter.OnReceiveData(receiveRawDatas, requestInfo, timeZoneInfo, id);
                    }
                }, this.didRecvChartRealDataFromServerAt = function(receiveRawDatas, id) {
                    void 0 !== _self.method.m_chartWrapDataConverter && null != _self.method.m_chartWrapDataConverter && _self.method.m_chartWrapDataConverter.OnReceiveRealDatas(receiveRawDatas, id);
                }, this.didAddLineStudy = function(trendLineCode) {
                    try {
                        return _chartWrapper.didApplyTrendline(trendLineCode);
                    } catch (e) {}
                }, this.didApplyTrendline = function(trendLineCode, isSelect, color, text) {
                    try {
                        return _chartWrapper.didApplyTrendline(trendLineCode, isSelect, color, text);
                    } catch (e) {}
                }, this.didReceiveOepDataFromServer = function(receiveRawDatas, isOrder) {
                    void 0 !== _self.method.m_chartWrapDataConverter && null != _self.method.m_chartWrapDataConverter && (!0 === isOrder ? _self.method.m_chartWrapDataConverter.OnReceiveOrderData(receiveRawDatas) : _self.method.m_chartWrapDataConverter.OnReceivePositData(receiveRawDatas));
                }, this.didReceiveAlertDataFromServer = function(receiveRawDatas) {
                    void 0 !== _self.method.m_chartWrapDataConverter && null != _self.method.m_chartWrapDataConverter && _self.method.m_chartWrapDataConverter.OnReceiveAlertData(receiveRawDatas);
                }, this.didReceiveExecutionDataFromServer = function(receiveRawDatas) {
                    void 0 !== _self.method.m_chartWrapDataConverter && null != _self.method.m_chartWrapDataConverter && _self.method.m_chartWrapDataConverter.OnReceiveExecutionData(receiveRawDatas);
                }, this.didClearExecutionObjects = function() {
                    return _chartWrapper.didClearExecutionObjects();
                }, this.didClearAlertObjects = function() {
                    return _chartWrapper.didClearAlertObjects();
                }, this.didApplyLocalSetting = function(key, isOn) {
                    try {
                        return _chartWrapper.didApplyLocalSetting(key, isOn);
                    } catch (e) {}
                }, this.didApplyChartSetting = function(argSettings) {
                    try {
                        return _chartWrapper.didApplyChartSetting(argSettings);
                    } catch (e) {}
                }, this.didApplyChartIndicatorPlotColorSetting = function(argSettings) {
                    try {
                        return _chartWrapper.didApplyChartIndicatorPlotColorSetting(argSettings);
                    } catch (e) {}
                }, this.didUpdateTrendlinesStyle = function(color, text) {
                    try {
                        return _chartWrapper.didUpdateTrendlinesStyle(color, text);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didGetCurrentSymbolInfo = function() {
                    try {
                        return _chartWrapper.didGetCurrentSymbolInfo();
                    } catch (e) {}
                }, this.didSetPointValueForCurrentSymbol = function(argPoint) {
                    try {
                        return _chartWrapper.didSetPointValueForCurrentSymbol(argPoint);
                    } catch (e) {}
                }, this.didSetZSBHandle = function(zsbHandle) {
                    try {
                        return _chartWrapper.didSetZSBHandle(zsbHandle);
                    } catch (e) {}
                }, this.didGetEnvInfo = function() {
                    return _chartWrapper.didGetEnvInfo();
                }, this.didUpdateAskBidData = function(hide, ask, bid, validFlag) {
                    try {
                        return _chartWrapper.didUpdateAskBidData(hide, ask, bid, validFlag);
                    } catch (e) {
                        console.error(e);
                    }
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.screenChart = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.screen, global.WGC_CHART.mouseCapture) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(5), __webpack_require__(6));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, drawWrapClass) {
            return function(scrObj) {
                var _ownerObj = scrObj, _self = this, _drawWrapper = null;
                this.m_jobjScreen = null, this.m_drawWrapper = null, this.m_ChartDrawObj = null, 
                this.m_EtcFolder = "./view/images/etcBtn/", this.m_arrThemes = [ "White", "Gray", "Sky" ], 
                this.m_arrYAxisStyles = [ "Both", "Left", "Right" ], this.m_objL = 0, this.m_objT = 0, 
                this.m_targetObj = null, this.m_iColorButton = -1, this.m_iChartWrapWidth = 0, this.m_iChartWrapHeight = 0, 
                this.iMousedownTimeout = 0, this.m_callbackTrendline = null, this.m_bTouchMode = !1, 
                this.m_xTouchPosvalLast = null, this.m_ptMouse = {
                    x: -1,
                    y: -1
                };
                var _findDomElementById = function(scrobj, id) {
                    var jqElem = scrobj._$object.find("#" + id);
                    return $(jqElem).get(0);
                }, _findDomElementsByClassName = function(scrobj, clsName) {
                    var jqElem = scrobj._$object.find("." + clsName);
                    return $(jqElem);
                }, _didGetAdjustedMouseEventPosition = function(event, capturedObj) {
                    var jidChartWrap;
                    jidChartWrap = void 0 !== capturedObj && null != capturedObj ? $(capturedObj).offset() : $(event.currentTarget).offset();
                    var scrollX = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft, scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop, posValueClient = {
                        XPos: event.clientX - jidChartWrap.left + scrollX,
                        YPos: event.clientY - jidChartWrap.top + scrollY
                    };
                    void 0 == event.offsetX ? event.layerX : event.offsetX, void 0 == event.offsetY ? event.layerY : event.offsetY;
                    return posValueClient;
                }, _initDOMElements = function(jobjScreen) {
                    _self.m_jobjScreen = jobjScreen;
                    var domElemChartWrap = _findDomElementById(jobjScreen, "idChartWrap");
                    if (void 0 !== domElemChartWrap && null != domElemChartWrap) {
                        domElemChartWrap.setAttributeNS(null, "tabindex", 1), _self.m_iChartWrapWidth = domElemChartWrap.offsetWidth, 
                        _self.m_iChartWrapHeight = domElemChartWrap.offsetHeight;
                        _findDomElementById(jobjScreen, "idChartArea").style.width = _self.m_iChartWrapWidth + "px";
                    }
                }, _didInitCtrlLayout = function(jobjScreen, argSettings, argPlotStyleInfos) {
                    _drawWrapper = new drawWrapClass(_self), _self.m_drawWrapper = _drawWrapper, _self.m_drawWrapper.didInitCtrlLayout(argSettings, argPlotStyleInfos);
                };
                this.didInitChartWrapper = function(scrObj, argSettings, argPlotStyleInfos) {
                    _initDOMElements(scrObj), _didInitCtrlLayout(0, argSettings, argPlotStyleInfos);
                }, this.didCallAfterDoneWithOnLoad = function() {}, this.didFindDomElementById = function(id) {
                    if (void 0 !== _self.m_jobjScreen && null != _self.m_jobjScreen) return _findDomElementById(_self.m_jobjScreen, id);
                }, this.didFindDomElementsByClassName = function(clsName) {
                    if (void 0 !== _self.m_jobjScreen && null != _self.m_jobjScreen) return _findDomElementsByClassName(_self.m_jobjScreen, clsName);
                }, this.didAddIndicator = function(code, info) {
                    return _self.m_drawWrapper.didAddIndicator(code, info);
                }, this.didChangeBasicChartType = function(argName) {
                    return _self.m_drawWrapper.didChangeBasicChartType(argName);
                }, this.willBeReceivedAlertExecutionData = function(isAlertOrExecution, receivedDatas) {
                    _self.m_drawWrapper.willBeReceivedAlertExecutionData(isAlertOrExecution, receivedDatas);
                }, this.didReceiveAlertExecutionData = function(isAlertOrExecution, receivedDatas) {
                    _self.m_drawWrapper.didReceiveAlertExecutionData(isAlertOrExecution, receivedDatas);
                }, this.willBeReceivedOrderPositData = function(isOrderOrPosit, receivedDatas) {
                    _self.m_drawWrapper.willBeReceivedOrderPositData(isOrderOrPosit, receivedDatas);
                }, this.didReceiveOrderPositData = function(isOrderOrPosit, receivedDatas) {
                    _self.m_drawWrapper.didReceiveOrderPositData(isOrderOrPosit, receivedDatas);
                }, this.willBeReceivedData = function(symbolInfo, receivedDatas, nextCount, multiTargetId) {
                    _self.m_drawWrapper.willBeReceivedData(symbolInfo, receivedDatas, nextCount, multiTargetId);
                }, this.didReceiveData = function(symbolInfo, receivedDatas, nextCount, multiTargetId) {
                    _self.m_drawWrapper.didReceiveData(symbolInfo, receivedDatas, nextCount, multiTargetId);
                }, this.willBeReceivedRealData = function(receivedData, multiTargetId) {
                    _self.m_drawWrapper.willBeReceivedRealData(receivedData, multiTargetId);
                }, this.didReceiveRealData = function(receivedData, multiTargetId) {
                    _self.m_drawWrapper.didReceiveRealData(receivedData, multiTargetId);
                }, this.didGetBasePriceDataInfo = function(id) {
                    return _self.m_drawWrapper.didGetBasePriceDataInfo(id);
                }, this.DrawingChartDrawFrame = function(bResize) {
                    _self.m_drawWrapper.DrawingChartDrawFrame(bResize);
                }, this.Init = function() {}, this.HideAllMenu = function(bIndiSetting) {};
                var _didEventProcForDown = function(targetId, posval, argEvent, capturedObj, someObject) {
                    if (void 0 === targetId || null == targetId) return !0;
                    if ("idCanvasX" === String(targetId).substring(0, 9) || "idCanvasL" === String(targetId).substring(0, 9) || "idCrosslineLY" === String(targetId).substring(0, 13) || "idCanvasR" === String(targetId).substring(0, 9) || "idCrosslineRY" === String(targetId).substring(0, 13) || "idIndi" === String(targetId).substring(0, 6) || "idBasicChart" === String(targetId).substring(0, 12) || "idChartPeriod" === String(targetId).substring(0, 13) || "idSetting" === String(targetId).substring(0, 9) || "idLogout" === String(targetId).substring(0, 8) || "idCompareChart" === String(targetId).substring(0, 14) || "idList" === String(targetId).substring(0, 6) || "idTrendLine" === String(targetId).substring(0, 11) || "idPeriodList" === String(targetId).substring(0, 12) || "idCodeList" === String(targetId).substring(0, 10) || "idTLine" === String(targetId).substring(0, 7) || "idTheme" === String(targetId).substring(0, 7) || "idCandle" === String(targetId).substring(0, 8) || "idSet" === String(targetId).substring(0, 5) || "idYAxis" === String(targetId).substring(0, 7) || "" === String(targetId).substring(0, 6).trim() || "idChartWrap" === String(targetId).substring(0, 11) || "idCloseBtn" === String(targetId).substring(0, 10) || "idTrendArea" === String(targetId).substring(0, 11) || "idCodeEdit" === String(targetId).substring(0, 10) || "idCompareCodeList" === String(targetId).substring(0, 17) || "idCompare" === String(targetId).substring(0, 9) || "idRefreshBtn" === String(targetId).substring(0, 12) || "idMinusBtn" === String(targetId).substring(0, 10) || "idPlusBtn" === String(targetId).substring(0, 9) || "idShiftLeftBtn" === String(targetId).substring(0, 14) || "idShiftRightBtn" === String(targetId).substring(0, 15)) return !0;
                    var isAxisArea = !1;
                    "idCanvasR" !== String(targetId).substring(0, 9) && "idCrosslineRY" !== String(targetId).substring(0, 13) || (isAxisArea = !0);
                    var actionArea = {
                        isDetail: !1,
                        isLegend: !1,
                        isExtraArea: !1
                    };
                    return String(targetId).indexOf("eidDetailInfoButton") >= 0 ? (actionArea.targetId = targetId, 
                    actionArea.isDetail = !0) : String(targetId).indexOf("eidLegendInfoButton") >= 0 ? (actionArea.targetId = targetId, 
                    actionArea.isLegend = !0) : String(targetId).indexOf("eidExtraPanelItem") >= 0 ? (actionArea.targetId = targetId, 
                    actionArea.isExtraArea = !0) : actionArea = null, _self.HideAllMenu(!0), void 0 !== _self.didHideColorPicker && _self.didHideColorPicker.apply(!0), 
                    _self.m_drawWrapper.OnMouseDown(posval, argEvent, isAxisArea, actionArea);
                }, _didEventProcForMove = function(targetId, posval, capturedObj, someObject) {
                    if (void 0 === targetId || null == targetId) return !0;
                    if (!(void 0 !== capturedObj && null != capturedObj || "idCanvasX" != String(targetId).substring(0, 9) && "idIndi" != String(targetId).substring(0, 6) && "idBasicChart" != String(targetId).substring(0, 12) && "idChartPeriod" != String(targetId).substring(0, 13) && "idSetting" != String(targetId).substring(0, 9) && "idLogout" != String(targetId).substring(0, 8) && "idCompareChart" != String(targetId).substring(0, 14) && "idList" != String(targetId).substring(0, 6) && "idTrendLine" != String(targetId).substring(0, 11) && "idPeriodList" != String(targetId).substring(0, 12) && "idCodeList" != String(targetId).substring(0, 10) && "idTLine" != String(targetId).substring(0, 7) && "idTheme" != String(targetId).substring(0, 7) && "idCandle" != String(targetId).substring(0, 8) && "idSet" != String(targetId).substring(0, 5) && "idYAxis" != String(targetId).substring(0, 7) && "idCompare" != String(targetId).substring(0, 9) && "" != String(targetId).substring(0, 6).trim())) return !0;
                    var isAxisArea = !1;
                    "idCanvasR" !== String(targetId).substring(0, 9) && "idCrosslineRY" !== String(targetId).substring(0, 13) || (isAxisArea = !0);
                    var actionArea = {
                        isDetail: !1,
                        isLegend: !1,
                        isExtraArea: !1
                    };
                    String(targetId).indexOf("eidDetailInfoButton") >= 0 ? (actionArea.targetId = targetId, 
                    actionArea.isDetail = !0) : String(targetId).indexOf("eidLegendInfoButton") >= 0 ? (actionArea.targetId = targetId, 
                    actionArea.isLegend = !0) : String(targetId).indexOf("eidExtraPanelItem") >= 0 ? (actionArea.targetId = targetId, 
                    actionArea.isExtraArea = !0) : actionArea = null, _self.m_drawWrapper.OnMouseMove(posval, isAxisArea, actionArea);
                }, _didEventProcForUp = function(targetId, posval, argEvent, capturedObj, someObject) {
                    window.clearInterval(_self.iMousedownTimeout);
                    var isAxisArea = !1;
                    "idCanvasR" !== String(targetId).substring(0, 9) && "idCrosslineRY" !== String(targetId).substring(0, 13) || (isAxisArea = !0), 
                    (void 0 !== capturedObj && null != capturedObj || "idCanvas" == String(targetId).substring(0, 8)) && _self.m_drawWrapper.OnMouseUp(posval, argEvent, isAxisArea);
                }, _didEventProcForContextMenu = function(targetId, posval, contextMenu) {
                    if (void 0 === targetId || null == targetId) return !0;
                    if ("idCanvasX" == String(targetId).substring(0, 9) || "idIndi" == String(targetId).substring(0, 6) || "idBasicChart" == String(targetId).substring(0, 12) || "idChartPeriod" == String(targetId).substring(0, 13) || "idSetting" == String(targetId).substring(0, 9) || "idLogout" == String(targetId).substring(0, 8) || "idCompareChart" == String(targetId).substring(0, 14) || "idList" == String(targetId).substring(0, 6) || "idTrendLine" == String(targetId).substring(0, 11) || "idPeriodList" == String(targetId).substring(0, 12) || "idCodeList" == String(targetId).substring(0, 10) || "idTLine" == String(targetId).substring(0, 7) || "idTheme" == String(targetId).substring(0, 7) || "idCandle" == String(targetId).substring(0, 8) || "idSet" == String(targetId).substring(0, 5) || "idYAxis" == String(targetId).substring(0, 7) || "idCompare" == String(targetId).substring(0, 9) || "" == String(targetId).substring(0, 6).trim()) return !0;
                    _self.HideAllMenu(!0), void 0 !== _self.didHideColorPicker && _self.didHideColorPicker.apply(!0);
                    var isAxisArea = !1;
                    "idCanvasR" !== String(targetId).substring(0, 9) && "idCrosslineRY" !== String(targetId).substring(0, 13) || (isAxisArea = !0);
                    var actionArea = {
                        isDetail: !1,
                        isLegend: !1,
                        isExtraArea: !1
                    };
                    String(targetId).indexOf("eidDetailInfoButton") >= 0 ? (actionArea.targetId = targetId, 
                    actionArea.isDetail = !0) : String(targetId).indexOf("eidLegendInfoButton") >= 0 ? (actionArea.targetId = targetId, 
                    actionArea.isLegend = !0) : String(targetId).indexOf("eidExtraPanelItem") >= 0 ? (actionArea.targetId = targetId, 
                    actionArea.isExtraArea = !0) : actionArea = null, _self.m_drawWrapper.OnContextMenu(posval, contextMenu, isAxisArea, actionArea);
                }, _didEventProcForDoubleClick = function(targetId, posval, argEvent) {
                    if (void 0 === targetId || null == targetId) return !0;
                    if ("idCanvasX" === String(targetId).substring(0, 9) || "idCanvasL" === String(targetId).substring(0, 9) || "idCrosslineLY" === String(targetId).substring(0, 13) || "idIndi" === String(targetId).substring(0, 6) || "idBasicChart" === String(targetId).substring(0, 12) || "idChartPeriod" === String(targetId).substring(0, 13) || "idSetting" === String(targetId).substring(0, 9) || "idLogout" === String(targetId).substring(0, 8) || "idCompareChart" === String(targetId).substring(0, 14) || "idList" === String(targetId).substring(0, 6) || "idTrendLine" === String(targetId).substring(0, 11) || "idPeriodList" === String(targetId).substring(0, 12) || "idCodeList" === String(targetId).substring(0, 10) || "idTLine" === String(targetId).substring(0, 7) || "idTheme" === String(targetId).substring(0, 7) || "idCandle" === String(targetId).substring(0, 8) || "idSet" === String(targetId).substring(0, 5) || "idYAxis" === String(targetId).substring(0, 7) || "" === String(targetId).substring(0, 6).trim() || "idChartWrap" === String(targetId).substring(0, 11) || "idCloseBtn" === String(targetId).substring(0, 10) || "idTrendArea" === String(targetId).substring(0, 11) || "idCodeEdit" === String(targetId).substring(0, 10) || "idCompareCodeList" === String(targetId).substring(0, 17) || "idCompare" === String(targetId).substring(0, 9) || "idRefreshBtn" === String(targetId).substring(0, 12) || "idMinusBtn" === String(targetId).substring(0, 10) || "idPlusBtn" === String(targetId).substring(0, 9) || "idShiftLeftBtn" === String(targetId).substring(0, 14) || "idShiftRightBtn" === String(targetId).substring(0, 15)) return !0;
                    var isAxisArea = !1;
                    return "idCanvasR" !== String(targetId).substring(0, 9) && "idCrosslineRY" !== String(targetId).substring(0, 13) || (isAxisArea = !0), 
                    _self.HideAllMenu(!0), void 0 !== _self.didHideColorPicker && _self.didHideColorPicker.apply(!0), 
                    _self.m_drawWrapper.OnDoubleClick(posval, argEvent, isAxisArea);
                };
                this.OnMouseDown = function(event) {
                    var __event = event || window.event;
                    if (!0 === _self.m_bTouchMode) return !0;
                    var posval = _didGetAdjustedMouseEventPosition(__event);
                    return !0 === _didEventProcForDown(__event.target.id, posval, __event) || void 0;
                }, this.OnMouseUp = function(event, capturedObj) {
                    var __event = event || window.event;
                    if (!0 === _self.m_bTouchMode) return !0;
                    var posval = _didGetAdjustedMouseEventPosition(event, capturedObj);
                    return !0 === _didEventProcForUp(event.target.id, posval, __event, capturedObj) || void 0;
                }, this.OnMouseMove = function(event, capturedObj) {
                    var __event = event || window.event;
                    if (_self.m_ptMouse.x === event.clientX && _self.m_ptMouse.y === event.clientY) return !0;
                    if (_self.m_ptMouse.x = event.clientX, _self.m_ptMouse.y = event.clientY, !0 === _self.m_bTouchMode) return !0;
                    var posval = _didGetAdjustedMouseEventPosition(__event, capturedObj);
                    return !0 === _didEventProcForMove(event.target.id, posval, capturedObj) || void 0;
                }, this.OnDragOver = function(event) {}, this.OnMouseWheel = function(event) {
                    var iXPos, __event = event || window.event, iDelta = 0;
                    (__event.ctrlKey || __event.metaKey) && __event.preventDefault(), iXPos = __event.clientX;
                    var __wheelDelta, __div = 120;
                    if ("wheelDelta" in __event ? (__wheelDelta = __event.wheelDelta, __div = 120) : (__wheelDelta = __event.detail, 
                    __div = -3), void 0 !== __wheelDelta && null != __wheelDelta) {
                        if ("string" == typeof __wheelDelta) iDelta = parseInt(__wheelDelta) / __div; else {
                            if ("object" == typeof __wheelDelta) return;
                            iDelta = __wheelDelta / __div;
                        }
                        !0 !== isNaN(iDelta) && (iDelta = Math.round(iDelta), _self.m_drawWrapper.OnMouseWheel({
                            XPos: iXPos,
                            Delta: iDelta
                        }));
                    }
                }, this.OnKeyDown = function(event) {
                    var __event = event || window.event;
                    _self.m_drawWrapper.OnKeyDown(__event.which);
                }, this.OnDoubleClick = function(event) {
                    var __event = event || window.event;
                    if (!0 === _self.m_bTouchMode) return !0;
                    var posval = _didGetAdjustedMouseEventPosition(__event);
                    _didEventProcForDoubleClick(__event.target.id, posval, __event);
                }, this.OnSwipe = function(event) {
                    var __event = event || window.event;
                    _self.m_drawWrapper.OnSwipe(__event);
                }, this.OnUnload = function() {
                    _self.m_drawWrapper.OnDestroy(), delete _self.m_drawWrapper, _self.m_drawWrapper = null;
                }, this.OnContextMenu = function(event) {
                    var __event = event || window.event;
                    if (!0 === _self.m_bTouchMode) return !0;
                    var posval = _didGetAdjustedMouseEventPosition(__event), contextMenu = {
                        event: xUtils.didClone(__event)
                    };
                    return !0 === _didEventProcForContextMenu(__event.target.id, posval, contextMenu) || void 0;
                }, this.OnReceive_RequestData = function(argRecv) {
                    if (void 0 !== _self.m_drawWrapper && null != _self.m_drawWrapper) return _self.m_drawWrapper.OnReceive_RequestData(argRecv);
                }, this.OnResize = function() {
                    var chartWrapObj = _self.didFindDomElementById("idChartWrap");
                    _self.m_iChartWrapWidth = chartWrapObj.offsetWidth, _self.m_iChartWrapHeight = chartWrapObj.offsetHeight;
                    var ObjChartDraw = _self.didFindDomElementById("idChartArea");
                    ObjChartDraw.style.width = _self.m_iChartWrapWidth + "px", ObjChartDraw.style.height = _self.m_iChartWrapHeight + "px", 
                    _self.m_drawWrapper.ResizeChart(!0);
                }, this.OnBottomBtnClick = function(strId) {
                    _self.m_drawWrapper.didClick_ActionButton(strId);
                }, this.OnBottomBtnUp = function() {
                    window.clearInterval(_self.iMousedownTimeout);
                }, this.didClick_ActionButton = function(strId) {
                    "idRefreshBtn" == strId || ("idMinusBtn" == strId ? _self.OnMouseWheel({
                        Delta: -1
                    }) : "idPlusBtn" == strId ? _self.OnMouseWheel({
                        Delta: 1
                    }) : "idShiftLeftBtn" == strId ? (_self.m_drawWrapper.didScrollScreen(-1), window.clearInterval(_self.iMousedownTimeout), 
                    _self.iMousedownTimeout = window.setInterval(function() {
                        _self.m_drawWrapper.didScrollScreen(-1);
                    }, 150)) : "idShiftRightBtn" == strId && (_self.m_drawWrapper.didScrollScreen(1), 
                    window.clearInterval(_self.iMousedownTimeout), _self.iMousedownTimeout = window.setInterval(function() {
                        _self.m_drawWrapper.didScrollScreen(1);
                    }, 150)));
                }, this.didScrollScreen = function(delta, bDraw) {
                    _self.m_drawWrapper.didScrollScreen(delta, bDraw);
                }, this.didDeleteAllIndicators = function() {
                    return _self.m_drawWrapper.didDeleteAllIndicators();
                }, this.didDeleteIndicatorByTypeId = function(argTypeId) {
                    return _self.m_drawWrapper.didDeleteIndicatorByTypeId(argTypeId);
                }, this.didDeleteSelectedIndicator = function() {
                    return _self.m_drawWrapper.didDeleteSelectedIndicator();
                }, this.didChangeIndicatorSettingByKey = function(argKey, argSettings) {
                    return _self.m_drawWrapper.didChangeIndicatorSettingByKey(argKey, argSettings);
                }, this.didChangeIndicatorSettingByTypeId = function(argTypeId, argSettings, argIsApplyInfo) {
                    return _self.m_drawWrapper.didChangeIndicatorSettingByTypeId(argTypeId, argSettings, argIsApplyInfo);
                }, this.didGetCurrentIndicatorInformationAll = function(isSave) {
                    return _self.m_drawWrapper.didGetCurrentIndicatorInformationAll(isSave);
                }, this.didSetCurrentIndicatorInformationAll = function(argInfo) {
                    return _self.m_drawWrapper.didSetCurrentIndicatorInformationAll(argInfo);
                }, this.didGetCurrentIndicatorInformationByTypeId = function(argTypeId) {
                    return _self.m_drawWrapper.didGetCurrentIndicatorInformationByTypeId(argTypeId);
                }, this.didReflectCallForIndicatorIsDeleted = function(argInfo) {
                    if (void 0 !== _ownerObj && null != _ownerObj) return _ownerObj.didReflectCallForIndicatorIsDeleted(argInfo);
                }, this.didReflectCallForError = function(argErrorCode) {
                    if (void 0 !== _ownerObj && null != _ownerObj) return _ownerObj.didReflectCallForError(argErrorCode);
                }, this.didReflectCallForTrendline = function(argInfo) {
                    if (void 0 !== _ownerObj && null != _ownerObj) return _ownerObj.didReflectCallForTrendline(argInfo);
                }, this.didReflectCallForDoubleClick = function(argInfo) {
                    if (void 0 !== _ownerObj && null != _ownerObj) return _ownerObj.didReflectCallForDoubleClick(argInfo);
                }, this.didReflectCallForDataViewInfo = function(argData) {
                    void 0 !== _ownerObj && null != _ownerObj && _ownerObj.didReflectCallForDataViewInfo(JSON.stringify(argData));
                }, this.didReflectCallForNewOrder = function(argOrder) {
                    void 0 !== _ownerObj && null != _ownerObj && _ownerObj.didReflectCallForNewOrder(argOrder);
                }, this.didReflectCallForCancelOrder = function(argOrder) {
                    void 0 !== _ownerObj && null != _ownerObj && _ownerObj.didReflectCallForCancelOrder(argOrder);
                }, this.didReflectCallForExecutionOrder = function(argOrder) {
                    void 0 !== _ownerObj && null != _ownerObj && _ownerObj.didReflectCallForExecutionOrder(argOrder);
                }, this.didReflectCallForOepValueIsChanged = function(argOepValue) {
                    void 0 !== _ownerObj && null != _ownerObj && _ownerObj.didReflectCallForOepValueIsChanged(argOepValue);
                }, this.didReflectCallForRequestNextData = function(argInfo) {
                    if (void 0 !== _ownerObj && null != _ownerObj) return _ownerObj.didReflectCallForRequestNextData(argInfo);
                }, this.didReflectCallForDetailView = function(argData) {
                    void 0 !== _ownerObj && null != _ownerObj && _ownerObj.didReflectCallForDetailView(argData);
                }, this.didReflectCallForContextMenu = function(argData) {
                    void 0 !== _ownerObj && null != _ownerObj && _ownerObj.didReflectCallForContextMenu(argData);
                }, this.didSetLoadInfoForTheLineTools = function(argLoadInfos) {
                    return _self.m_drawWrapper.didSetLoadInfoForTheLineTools(argLoadInfos);
                }, this.didGetSaveInfoOfTheLineTools = function() {
                    return _self.m_drawWrapper.didGetSaveInfoOfTheLineTools();
                }, this.didSetFocusingFlag = function(argFocusing, argRefresh) {
                    return _self.m_drawWrapper.didSetFocusingFlag(argFocusing, argRefresh);
                }, this.didSetChartConfig = function(argConfig) {
                    return _self.m_drawWrapper.didSetChartConfig(argConfig);
                }, this.didClearDatas = function() {
                    _self.m_drawWrapper.didClearDatas(), _self.DrawingChartDrawFrame();
                }, this.didClearOrderPositObjects = function(isOrder, isPosit) {
                    _self.m_drawWrapper.didClearOrderPositObjects(isOrder, isPosit), _self.DrawingChartDrawFrame();
                }, this.didClearExecutionObjects = function() {
                    _self.m_drawWrapper.didClearExecutionObjects(), _self.DrawingChartDrawFrame();
                }, this.didClearAlertObjects = function() {
                    _self.m_drawWrapper.didClearAlertObjects(), _self.DrawingChartDrawFrame();
                }, this.didApplyZoomInOut = function(isIn, step) {
                    _self.m_drawWrapper.didApplyZoomInOut(isIn, step);
                }, this.didApplyGoToEndPos = function(bEndPos, isNotFix) {
                    return _self.m_drawWrapper.didApplyGoToEndPos(bEndPos, isNotFix);
                }, this.didAddLineStudy = function(trendLineCode) {
                    return _self.m_drawWrapper.didApplyTrendline(trendLineCode);
                }, this.didApplyTrendline = function(trendLineCode, isSelect, color, text) {
                    return _self.m_drawWrapper.didApplyTrendline(trendLineCode, isSelect, color, text);
                }, this.didApplyLocalSetting = function(key, isOn) {
                    return _self.m_drawWrapper.didApplyLocalSetting(key, isOn);
                }, this.didApplyChartSetting = function(argSettings) {
                    return _self.m_drawWrapper.didApplyChartSetting(argSettings);
                }, this.didApplyChartIndicatorPlotColorSetting = function(argSettings) {
                    return _self.m_drawWrapper.didApplyChartIndicatorPlotColorSetting(argSettings);
                }, this.dummy = function() {}, this.didGetCurrentSymbolInfo = function() {
                    return _self.m_drawWrapper.GetCurrentSymbolInfo();
                }, this.didGetEnvInfo = function() {
                    return _self.m_drawWrapper.didGetEnvInfo();
                }, this.didSetPointValueForCurrentSymbol = function(argPoint) {
                    try {
                        return _self.m_drawWrapper.didSetPointValueForCurrentSymbol(argPoint);
                    } catch (e) {}
                }, this.didSetZSBHandle = function(zsbHandle) {
                    try {
                        return _self.m_drawWrapper.didSetZSBHandle(zsbHandle);
                    } catch (e) {}
                }, this.didUpdateTrendlinesStyle = function(color, text) {
                    try {
                        return _self.m_drawWrapper.didUpdateTrendlinesStyle(color, text);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didUpdateAskBidData = function(hide, ask, bid, validFlag) {
                    try {
                        return _self.m_drawWrapper.didUpdateAskBidData(hide, ask, bid, validFlag);
                    } catch (e) {
                        console.error(e);
                    }
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartWrap = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.chartDrawWrap) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(17));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, layoutPanelNormalClass) {
            return function(chartWrapper) {
                var _self = this, _chartWrapper = chartWrapper, _layoutPanelNormalClass = layoutPanelNormalClass, _combineKey = null;
                this.m_xDoBasePrice = null, this.m_xNormalLayout = null, this.m_xNontimeLayout = null, 
                this.m_xCurrentLayout = null, this.m_classNormalLayout = layoutPanelNormalClass, 
                this.m_stEnv = xUtils.constants.didGetClonedDefaultChartConfig(), this.m_xSeriesInfos = xUtils.indicator.didGetDefaultSeriesInfos(), 
                this.m_xTrendlineInfos = xUtils.trendLine.didGetDefaultTrendlineInfos(), this.didGetEnvInfo = function() {
                    return _self.m_stEnv;
                }, this.didSetFocusingFlag = function(argFocusing, argRefresh) {
                    _self.m_stEnv.Focusing = argFocusing, !0 === argRefresh && _self.DrawingChartDrawFrame(!1);
                }, this.DrawingChartDrawFrame = function(bResize) {
                    _self.m_xCurrentLayout.DrawingChartDrawFrame(bResize);
                }, this.hasExtraLayout = function() {
                    return !1;
                }, this.ResizeChart = function(bResize) {
                    _self.m_xNormalLayout.ResizeChart(bResize), !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.ResizeChart(bResize);
                }, this.didSetDefaultEnv = function(argSettings) {
                    var xEnv = _self.didGetEnvInfo();
                    if (void 0 !== argSettings && null != argSettings) {
                        if ("string" == typeof argSettings) try {
                            argSettings = JSON.parse(argSettings);
                        } catch (e) {
                            console.error(e), argSettings = void 0;
                        }
                        if ("object" == typeof argSettings && argSettings.System && "object" == typeof argSettings.System) {
                            var xSysSrc = argSettings.System, xSysDst = xEnv.System;
                            if (void 0 !== xSysSrc.UseContextMenu && null != xSysSrc.UseContextMenu && (xSysDst.UseContextMenu = xSysSrc.UseContextMenu), 
                            void 0 !== xSysSrc.UseScrollAction && null != xSysSrc.UseScrollAction && (xSysDst.UseScrollAction = xSysSrc.UseScrollAction), 
                            void 0 !== xSysSrc.ContextMenuOrderAll && null != xSysSrc.ContextMenuOrderAll && (xSysDst.ContextMenuOrderAll = xSysSrc.ContextMenuOrderAll), 
                            void 0 !== xSysSrc.UseRequestPreviousNext && null != xSysSrc.UseRequestPreviousNext && (xSysDst.UseRequestPreviousNext = xSysSrc.UseRequestPreviousNext), 
                            void 0 !== xSysSrc.UseOneClickOepMode && null != xSysSrc.UseOneClickOepMode && (xSysDst.UseOneClickOepMode = xSysSrc.UseOneClickOepMode), 
                            void 0 !== xSysSrc.DefaultPriceBar && null != xSysSrc.DefaultPriceBar && (xSysDst.DefaultPriceBar = xSysSrc.DefaultPriceBar), 
                            void 0 !== xSysSrc.UseObjectCrossline && null != xSysSrc.UseObjectCrossline && (xSysDst.UseObjectCrossline = xSysSrc.UseObjectCrossline), 
                            void 0 !== xSysSrc.Scroll && null != xSysSrc.Scroll && void 0 !== xSysSrc.Scroll.zoom && null != xSysSrc.Scroll.zoom) try {
                                void 0 !== xSysDst.Scroll.screenSize.max && null != xSysDst.Scroll.screenSize.max ? xSysDst.Scroll.screenSize.min <= xSysSrc.Scroll.zoom && xSysSrc.Scroll.zoom <= xSysDst.Scroll.screenSize.max && (xSysDst.Scroll.zoom = xSysSrc.Scroll.zoom) : xSysDst.Scroll.screenSize.min <= xSysSrc.Scroll.zoom && (xSysDst.Scroll.zoom = xSysSrc.Scroll.zoom);
                            } catch (e) {
                                console.error(e);
                            }
                            if (void 0 !== xSysSrc.UseMouseWheel && null != xSysSrc.UseMouseWheel && (xSysDst.UseMouseWheel = xSysSrc.UseMouseWheel), 
                            void 0 !== xSysSrc.OepMouseCursor && null != xSysSrc.OepMouseCursor && (xSysDst.OepMouseCursor = xSysSrc.OepMouseCursor), 
                            void 0 !== xSysSrc.AllowSmoothScroll && null != xSysSrc.AllowSmoothScroll && (xSysDst.AllowSmoothScroll = xSysSrc.AllowSmoothScroll), 
                            void 0 !== xSysSrc.ContainerSelect && null != xSysSrc.ContainerSelect && (xSysDst.ContainerSelect = xSysSrc.ContainerSelect), 
                            void 0 !== xSysSrc.IndicatorSelect && null != xSysSrc.IndicatorSelect && (xSysDst.IndicatorSelect = xSysSrc.IndicatorSelect), 
                            void 0 !== xSysSrc.UseDoubleClick && null != xSysSrc.UseDoubleClick && (xSysDst.UseDoubleClick = xSysSrc.UseDoubleClick), 
                            void 0 !== xSysSrc.UseForMiniChart && null != xSysSrc.UseForMiniChart && (xSysDst.UseForMiniChart = xSysSrc.UseForMiniChart, 
                            !0 === xSysDst.UseForMiniChart)) {
                                var xEnvDst = xEnv;
                                xSysDst.YAxisRight = 0, xSysDst.Scroll.zoom = 10, xEnvDst.ChartType = "Line", xEnvDst.MarginRight = "0", 
                                xEnvDst.MarginTopBottom = "10", xEnvDst.ExtraPanelWidth = 0, xEnvDst.ConfigAxis.ShowRight = !1, 
                                xEnvDst.CrossLine.hide = !0, xEnvDst.MinMaxTooltipShow = !1, xEnvDst.HideAskBid = !0, 
                                xEnvDst.ConfigAxis.GridShow = !1, xEnvDst.BorderColor = xEnvDst.BackgroundColor = "rgba(255, 255, 255, 0)", 
                                xEnvDst.MiniChartConfig = {
                                    LineColor: "#00e6e6",
                                    BgColor1: "#0088cc",
                                    BgColor2: "rgba(0, 77, 153, 0.6)"
                                }, xSysDst.DefaultTrendline = xUtils.constants.trendLineCodes.pointer;
                            }
                        }
                    }
                }, this.didApplyPlotStyleInfos = function(argPlotStyleInfos) {
                    if (void 0 === argPlotStyleInfos || null == argPlotStyleInfos) return !1;
                    var xPsis;
                    if (xPsis = "string" == typeof argPlotStyleInfos ? JSON.parse(argPlotStyleInfos) : argPlotStyleInfos, 
                    void 0 === xPsis.length || null == xPsis.length || xPsis.length < 1) return !1;
                    for (var nCount = xPsis.length, ii = 0; ii < nCount; ii++) {
                        var xPsi = xPsis[ii];
                        xPsi && _didApplySeriesInfo(xPsi.code, xPsi.info);
                    }
                    return !0;
                }, this.didRemoveNontimeLayout = function() {
                    !0 === _self.hasExtraLayout() && (_self.m_xCurrentLayout = _self.m_xNormalLayout, 
                    _self.m_xNontimeLayout.OnDestroy(), delete _self.m_xNontimeLayout, _self.m_xNontimeLayout = null);
                }, this.didCreateLayout = function(isNontime) {
                    _self.didRemoveNontimeLayout();
                    _self.m_xNormalLayout = new _layoutPanelNormalClass(_chartWrapper, _self), _self.m_xCurrentLayout = _self.m_xNormalLayout, 
                    _self.m_xCurrentLayout.didInitDrawPanelLayout(null);
                }, this.didInitCtrlLayout = function(argSettings, argPlotStyleInfos) {
                    _self.didSetDefaultEnv(argSettings), _self.didApplyPlotStyleInfos(argPlotStyleInfos), 
                    _self.didCreateLayout(!1);
                }, this.GetCurrentSymbolPointValue = function() {
                    var __symbolInfo = _self.m_xDoBasePrice.m_symbolInfo;
                    return void 0 === __symbolInfo || null === __symbolInfo ? 3 : void 0 === __symbolInfo.verpos || null === __symbolInfo.verpos ? 3 : __symbolInfo.verpos;
                }, this.didShowAllNormalFrame = function(bShow) {
                    void 0 !== _self.m_xNormalLayout.m_domElemChartDraw && (_self.m_xNormalLayout.m_domElemChartDraw.style.visibility = !0 === bShow ? "visible" : "hidden");
                }, this.didChangeBasicChartType = function(strBasicChart) {
                    var xEnv = _self.didGetEnvInfo();
                    if (!0 === xUtils.isAvailableToUseChartType(xEnv, strBasicChart)) {
                        strBasicChart != xUtils.constants.chartTypeCode.candle && strBasicChart != xUtils.constants.chartTypeCode.line && (strBasicChart = xUtils.constants.chartTypeCode.candle), 
                        _self.m_stEnv.ChartType = strBasicChart;
                        return _self.m_xCurrentLayout.didChangeBasicChartType(strBasicChart, !1), _self.RecalcProc(xUtils.constants.ngcl.enum.EUS_CHANGE_LAYOUT), 
                        _self.ResizeChart(!0), !0;
                    }
                }, this.didClearDatas = function() {
                    _self.m_xNormalLayout.didClearDatas(), !0 === _self.hasExtraLayout() && _self.m_xNormalLayout.didClearDatas();
                }, this.didClearOrderPositObjects = function(isOrder, isPosit) {
                    _self.m_xNormalLayout.didClearOrderPositObjects(isOrder, isPosit);
                }, this.didClearExecutionObjects = function() {
                    _self.m_xNormalLayout.didClearExecutionObjects();
                }, this.didClearAlertObjects = function() {
                    _self.m_xNormalLayout.didClearAlertObjects();
                }, this.didRemoveAllLineTools = function(bFlag) {
                    _self.m_xNormalLayout.didRemoveAllLineTools(bFlag), !0 === _self.hasExtraLayout() && _self.m_xNormalLayout.didRemoveAllLineTools(bFlag);
                }, this.willBeReceivedAlertExecutionData = function(isAlertOrExecution, receivedDatas) {
                    _self.m_xNormalLayout.willBeReceivedAlertExecutionData(isAlertOrExecution, receivedDatas);
                }, this.didReceiveAlertExecutionData = function(isAlertOrExecution, receivedDatas) {
                    _self.m_xNormalLayout.didReceiveAlertExecutionData(isAlertOrExecution, receivedDatas);
                }, this.willBeReceivedOrderPositData = function(isOrderOrPosit, receivedDatas) {
                    _self.m_xNormalLayout.willBeReceivedOrderPositData(isOrderOrPosit, receivedDatas);
                }, this.didReceiveOrderPositData = function(isOrderOrPosit, receivedDatas) {
                    _self.m_xNormalLayout.didReceiveOrderPositData(isOrderOrPosit, receivedDatas);
                }, this.willBeReceivedData = function(symbolInfo, receivedDatas, nextCount, multiTargetId) {
                    _self.m_xNormalLayout.willBeReceivedData(symbolInfo, receivedDatas, nextCount, multiTargetId), 
                    !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.willBeReceivedData(symbolInfo, receivedDatas, nextCount, multiTargetId);
                }, this.didReceiveData = function(symbolInfo, receivedDatas, nextCount, multiTargetId) {
                    _self.m_xNormalLayout.didReceiveData(symbolInfo, receivedDatas, nextCount, multiTargetId), 
                    !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.didReceiveData(symbolInfo, receivedDatas, nextCount, multiTargetId);
                }, this.willBeReceivedRealData = function(receivedData, multiTargetId) {
                    _self.m_xNormalLayout.willBeReceivedRealData(receivedData, multiTargetId), !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.willBeReceivedRealData(receivedData, multiTargetId);
                }, this.didReceiveRealData = function(receivedData, multiTargetId) {
                    _self.m_xNormalLayout.didReceiveRealData(receivedData, multiTargetId), !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.didReceiveRealData(receivedData, multiTargetId);
                }, this.didScrollScreen = function(nDelta, bDraw) {
                    _self.m_xCurrentLayout.didScrollScreen(nDelta, bDraw);
                }, this.didZoomScreen = function(nDelta, bDraw) {
                    _self.m_xCurrentLayout.didZoomScreen(nDelta, bDraw);
                }, this.didGetBasePriceDataInfo = function(id) {
                    return {
                        datas: _self.m_xNormalLayout.didGetReferencedPriceDatas(id),
                        times: _self.m_xNormalLayout.didGetTimeDatas(id)
                    };
                }, this.didGetCurrentIndicatorInformationAll = function(isSave, all) {
                    var count, indicators, xEnv = _self.didGetEnvInfo(), xResult = {
                        trend: [],
                        oscillator: []
                    };
                    indicators = _self.m_xSeriesInfos.trend, count = indicators.length;
                    for (var ii = 0; ii < count; ii++) {
                        var xSeriesInfo = indicators[ii];
                        if (!0 !== isSave || !0 === all || !0 === xSeriesInfo.show) {
                            var xInfo = xUtils.indicator.didConvertToShortSeriesInformation(xSeriesInfo.info, isSave);
                            if (xInfo) {
                                var xItem;
                                xItem = isSave ? {
                                    c: xSeriesInfo.code,
                                    s: xSeriesInfo.show,
                                    i: xInfo
                                } : {
                                    code: xSeriesInfo.code,
                                    show: xSeriesInfo.show,
                                    info: xInfo
                                }, xResult.trend.push(xItem);
                            }
                        }
                    }
                    var ocillators = [];
                    indicators = _self.m_xSeriesInfos.oscillator, count = indicators.length;
                    for (var ii = 0; ii < count; ii++) {
                        var xSeriesInfo = indicators[ii];
                        if (!0 !== isSave || !0 === all || !0 === xSeriesInfo.show) {
                            var xInfo = xUtils.indicator.didConvertToShortSeriesInformation(xSeriesInfo.info, isSave);
                            if (xInfo) {
                                var xItem;
                                xItem = isSave ? {
                                    c: xSeriesInfo.code,
                                    s: xSeriesInfo.show,
                                    i: xInfo
                                } : {
                                    code: xSeriesInfo.code,
                                    show: xSeriesInfo.show,
                                    info: xInfo
                                }, !0 === xSeriesInfo.show && ocillators.push(xSeriesInfo.code), xResult.oscillator.push(xItem);
                            }
                        }
                    }
                    return xResult.disableSetting = _self.hasExtraLayout(), xResult.chartType = xEnv.ChartType, 
                    xResult.osl = _self.didGetOrderingInfoForIndicators(ocillators), xResult.isSave = isSave, 
                    !0 === isSave && !0 === all && (xResult.isAll = !0), xResult;
                }, this.didSetCurrentIndicatorInformationAll = function(argInfo) {
                    if (void 0 === argInfo || null == argInfo) return !1;
                    _self.didDeleteAllIndicators(), "string" == typeof argInfo && (argInfo = JSON.parse(argInfo));
                    try {
                        var count, indicators, isAll = argInfo.isAll, isSave = argInfo.isSave, xResult = (_self.didGetEnvInfo(), 
                        {
                            trend: [],
                            oscillator: [],
                            osl: argInfo.osl
                        });
                        if (!0 === isSave) {
                            indicators = argInfo.trend, count = indicators.length;
                            for (var ii = 0; ii < count; ii++) {
                                var xSsi = indicators[ii];
                                if (!0 === isAll || !0 === xSsi.s) {
                                    var xSeriesInfo = _self.didGetRestoreIndicatorInformationByTypeId(xSsi.c), xInfo = xUtils.indicator.didDecodeSeriesInformation(xSeriesInfo, xSsi);
                                    if (xInfo) {
                                        var xItem;
                                        xItem = {
                                            code: xSsi.c,
                                            show: xSsi.s,
                                            info: xInfo
                                        }, xResult.trend.push(xItem);
                                    }
                                }
                            }
                            indicators = argInfo.oscillator, count = indicators.length;
                            for (var ii = 0; ii < count; ii++) {
                                var xSsi = indicators[ii];
                                if (!0 === isAll || !0 === xSsi.s) {
                                    var xSeriesInfo = _self.didGetRestoreIndicatorInformationByTypeId(xSsi.c), xInfo = xUtils.indicator.didDecodeSeriesInformation(xSeriesInfo, xSsi);
                                    if (xInfo) {
                                        var xItem;
                                        xItem = {
                                            code: xSsi.c,
                                            show: xSsi.s,
                                            info: xInfo
                                        }, xResult.oscillator.push(xItem);
                                    }
                                }
                            }
                        } else xResult.trend = argInfo.trend, xResult.oscillator = argInfo.oscillator;
                    } catch (e) {
                        console.error(e);
                    }
                    try {
                        if (xResult.trend) for (var nCount = xResult.trend.length, ii = 0; ii < nCount; ii++) {
                            var xSi = xResult.trend[ii];
                            if (xSi) if (!0 === xSi.show) {
                                var code = xSi.code;
                                _self.didAddIndicator(code, xSi.info);
                            } else if (!0 === isAll) {
                                var code = xSi.code;
                                _didApplySeriesInfo(code, xSi.info);
                            }
                        }
                        if (xResult.osl) for (var nCount = xResult.osl.length, ii = 0; ii < nCount; ii++) for (var list = xResult.osl[ii], nSCount = list.length, jj = 0; jj < nSCount; jj++) {
                            var code = list[jj], xSi = xUtils.indicator.didFindSeriesInfoWithTypeId(code, xResult, !1);
                            if (xSi) if (!0 === xSi.show) {
                                var code = xSi.code;
                                _self.didAddIndicator(code, xSi.info);
                            } else if (!0 === isAll) {
                                var code = xSi.code;
                                _didApplySeriesInfo(code, xSi.info);
                            }
                        }
                    } catch (e) {
                        console.error(e);
                    }
                    return xResult;
                };
                var _didGetAllIndicatorListIsShown = function() {
                    try {
                        var count, indicators, arrList = (_self.didGetEnvInfo(), []);
                        indicators = _self.m_xSeriesInfos.trend, count = indicators.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSeriesInfo = indicators[ii];
                            !0 === xSeriesInfo.show && arrList.push(xSeriesInfo.code);
                        }
                        indicators = _self.m_xSeriesInfos.oscillator, count = indicators.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSeriesInfo = indicators[ii];
                            !0 === xSeriesInfo.show && arrList.push(xSeriesInfo.code);
                        }
                        return arrList;
                    } catch (e) {}
                };
                this.didDeleteAllIndicators = function() {
                    var list = _didGetAllIndicatorListIsShown();
                    if (list) for (var nCount = list.length, ii = 0; ii < nCount; ii++) {
                        var code = list[ii];
                        _self.didDeleteIndicatorByTypeId(code);
                    }
                    return !0;
                }, this.didGetOrderingInfoForIndicators = function(argList) {
                    if (_self.m_xNormalLayout && _self.m_xNormalLayout.didGetOrderingInfoForIndicators) return _self.m_xNormalLayout.didGetOrderingInfoForIndicators(argList);
                }, this.didGetCurrentIndicatorInformationByTypeId = function(argTypeId, isSave) {
                    var xSeriesInfo = _didFindSeriesInfo(argTypeId);
                    if (void 0 !== xSeriesInfo && null != xSeriesInfo) {
                        var xInfo = xUtils.indicator.didConvertToShortSeriesInformation(xSeriesInfo.info, isSave);
                        if (xInfo) {
                            return {
                                code: xSeriesInfo.code,
                                show: xSeriesInfo.show,
                                info: xInfo
                            };
                        }
                    }
                }, this.didDeleteIndicatorByTypeId = function(argTypeId) {
                    var xSeriesInfo = _didFindSeriesInfo(argTypeId);
                    if (void 0 === xSeriesInfo || null == xSeriesInfo || !0 !== xSeriesInfo.show) return !1;
                    var xDeletedResult = _self.m_xNormalLayout.didDeleteIndicatorByTypeId(argTypeId);
                    return !0 === xDeletedResult.isDeleted && (xSeriesInfo.show = !1), xDeletedResult;
                };
                var _didUpdateForDeletingIndicator = function(argTargetInfo) {
                    if (void 0 !== argTargetInfo && null != argTargetInfo) {
                        var xSeriesInfo = _didFindSeriesInfo(argTargetInfo.typeId);
                        if (void 0 === xSeriesInfo || null == xSeriesInfo || !0 !== xSeriesInfo.show || !xSeriesInfo.info) return;
                        !0 === argTargetInfo.isDeleted && (xSeriesInfo.show = !1);
                        return {
                            typeId: argTargetInfo.typeId,
                            isDeleted: argTargetInfo.isDeleted,
                            trend: !0 === xSeriesInfo.info.priceType
                        };
                    }
                };
                this.didNotifyForDeletingIndicator = function(argTargetInfo) {
                    var xResult = _didUpdateForDeletingIndicator(argTargetInfo);
                    if (void 0 !== xResult && null != xResult) return _chartWrapper.didReflectCallForIndicatorIsDeleted(xResult);
                }, this.didNotifyForError = function(argErrorCode) {
                    return _chartWrapper.didReflectCallForError(argErrorCode);
                }, this.didNotifyForTrendline = function(argInfo) {
                    return _chartWrapper.didReflectCallForTrendline(argInfo);
                }, this.didNotifyForDoubleClick = function(argInfo) {
                    return _chartWrapper.didReflectCallForDoubleClick(argInfo);
                }, this.didDeleteSelectedIndicator = function() {
                    var xResult = _self.m_xNormalLayout.didDeleteSelectedIndicator();
                    return _didUpdateForDeletingIndicator(xResult);
                }, this.didChangeIndicatorSettingByKey = function(argKey, argSettings) {
                    if (_self.m_xNormalLayout && _self.m_xNormalLayout.didChangeIndicatorSettingByKey) return _self.m_xNormalLayout.didChangeIndicatorSettingByKey(argKey, argSettings);
                }, this.didChangeIndicatorSettingByTypeId = function(argTypeId, argSettings, argIsApplyInfo) {
                    var typeId, settings;
                    if (!0 === argIsApplyInfo) {
                        var xResult = _didApplySeriesInfo(argTypeId, argSettings);
                        typeId = xResult.typeId, settings = xResult.settings;
                        var xSeriesInfo = xResult.seriesInfo;
                        if (void 0 === xSeriesInfo || null == xSeriesInfo) return !1;
                    } else typeId = argTypeId, settings = argSettings;
                    if (_self.m_xNormalLayout && _self.m_xNormalLayout.didChangeIndicatorSettingByTypeId) return _self.m_xNormalLayout.didChangeIndicatorSettingByTypeId(typeId, settings);
                }, this.OnMouseDown = function(posval, argEvent, isAxisArea, actionArea) {
                    return _self.m_xCurrentLayout.OnMouseDown(posval, argEvent, isAxisArea, actionArea);
                }, this.OnMouseUp = function(posval, argEvent, isAxisArea) {
                    _self.m_xCurrentLayout.OnMouseUp(posval, argEvent, isAxisArea);
                }, this.OnMouseMove = function(posval, isAxisArea, actionArea) {
                    _self.m_xCurrentLayout.OnMouseMove(posval, isAxisArea, actionArea);
                    var arrInfos = [];
                    _self.m_xCurrentLayout.didSetDataViewInfo(arrInfos), _chartWrapper.didReflectCallForDataViewInfo && _chartWrapper.didReflectCallForDataViewInfo({
                        datas: arrInfos
                    });
                }, this.OnDragOver = function(posval) {
                    _self.m_xCurrentLayout.OnDragOver(posval);
                }, this.OnMouseWheel = function(posval) {
                    !0 === _self.didGetEnvInfo().System.UseMouseWheel && _self.m_xCurrentLayout.OnMouseWheel(posval);
                }, this.OnKeyDown = function(keyValue) {
                    if (!0 === xUtils.constants.keyEvent.isCombineKey(keyValue)) return void (_combineKey = keyValue);
                    _self.m_xCurrentLayout.OnKeyDown(keyValue, _combineKey), _combineKey = null;
                }, this.OnDoubleClick = function(posval, argEvent, isAxisArea) {
                    _self.m_xCurrentLayout.OnDoubleClick(posval, argEvent, isAxisArea);
                }, this.OnSwipe = function(event) {
                    _self.m_xCurrentLayout.OnSwipe(event);
                }, this.OnDestroy = function() {
                    _self.m_xCurrentLayout = null, _self.m_xNormalLayout.OnDestroy(), !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.OnDestroy(), 
                    delete _self.m_xNormalLayout, _self.m_xNormalLayout = null, !0 === _self.hasExtraLayout() && (delete _self.m_xNontimeLayout, 
                    _self.m_xNontimeLayout = null);
                }, this.OnContextMenu = function(posval, contextMenu, isAxisArea, actionArea) {
                    !0 === _self.didGetEnvInfo().System.UseContextMenu && !0 !== _self.hasExtraLayout() && _self.m_xNormalLayout.OnContextMenu(posval, contextMenu, isAxisArea, actionArea);
                }, this.didSetChartConfig = function(argConfig) {
                    if (void 0 === argConfig || null == argConfig) return !1;
                    "string" == typeof argConfig && (argConfig = JSON.parse(argConfig));
                    var xEnv = _self.didGetEnvInfo();
                    void 0 !== argConfig.priceColorUp && null != argConfig.priceColorUp && (xEnv.PriceStyleConfig.OHLC.strokeUpColor = xEnv.PriceStyleConfig.HLC.strokeUpColor = xEnv.PriceStyleConfig.TLB.strokeUpColor = xEnv.PriceStyleConfig.KAGI.strokeUpColor = xEnv.PriceStyleConfig.RENKO.strokeUpColor = xEnv.PriceStyleConfig.PNF.strokeUpColor = xEnv.PriceStyleConfig.RCL.strokeUpColor = xEnv.PriceStyleConfig.Candle.strokeUpColor = xEnv.PriceStyleConfig.Candle.fillUpColor = argConfig.priceColorUp), 
                    void 0 !== argConfig.priceColorDn && null != argConfig.priceColorDn && (xEnv.PriceStyleConfig.OHLC.strokeDnColor = xEnv.PriceStyleConfig.HLC.strokeDnColor = xEnv.PriceStyleConfig.TLB.strokeDnColor = xEnv.PriceStyleConfig.KAGI.strokeDnColor = xEnv.PriceStyleConfig.RENKO.strokeDnColor = xEnv.PriceStyleConfig.PNF.strokeDnColor = xEnv.PriceStyleConfig.RCL.strokeDnColor = xEnv.PriceStyleConfig.Candle.strokeDnColor = xEnv.PriceStyleConfig.Candle.fillDnColor = argConfig.priceColorDn), 
                    void 0 !== argConfig.priceColorLine && null != argConfig.priceColorLine && (xEnv.PriceStyleConfig.RCL.strokeColor = xEnv.PriceStyleConfig.Line.strokeColor = xEnv.PriceStyleConfig.Candle.strokeColor = argConfig.priceColorLine), 
                    void 0 !== argConfig.gridVert && null != argConfig.gridVert && (xEnv.ConfigAxis.GridVertColor = argConfig.gridVert), 
                    void 0 !== argConfig.gridHorz && null != argConfig.gridHorz && (xEnv.ConfigAxis.GridHorzColor = argConfig.gridHorz), 
                    void 0 !== argConfig.trendLine && null != argConfig.trendLine && (xEnv.TrendlineColor = xEnv.CrossLine.lineStyle.strokeColor = argConfig.trendLine), 
                    void 0 !== argConfig.leftAxis && null != argConfig.leftAxis && (!0 === argConfig.leftAxis ? xEnv.System.YAxisLeft = xEnv.System.YAxisWidth : xEnv.System.YAxisLeft = 0), 
                    void 0 !== argConfig.rightAxis && null != argConfig.rightAxis && (!0 === argConfig.rightAxis ? xEnv.System.YAxisRight = xEnv.System.YAxisWidth : xEnv.System.YAxisRight = 0);
                    var bExtraRecalc = !1;
                    return void 0 === argConfig.nt_tlb && null == argConfig.nt_tlb || (xEnv.PriceStyleConfig.TLB.params[0].value = argConfig.nt_tlb, 
                    bExtraRecalc = !0), void 0 === argConfig.nt_rcl && null == argConfig.nt_rcl || (xEnv.PriceStyleConfig.RCL.params[0].value = argConfig.nt_rcl, 
                    bExtraRecalc = !0), void 0 === argConfig.nt_pnf && null == argConfig.nt_pnf || (xEnv.PriceStyleConfig.PNF.params[0].value = argConfig.nt_pnf, 
                    bExtraRecalc = !0), void 0 === argConfig.nt_kagi && null == argConfig.nt_kagi || (xEnv.PriceStyleConfig.KAGI.params[0].value = argConfig.nt_kagi, 
                    bExtraRecalc = !0), void 0 === argConfig.nt_renko && null == argConfig.nt_renko || (xEnv.PriceStyleConfig.RENKO.params[0].value = argConfig.nt_renko, 
                    bExtraRecalc = !0), !0 === bExtraRecalc && !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.didReceiveDataExt(), 
                    void 0 !== argConfig.GridShow && null != argConfig.GridShow && (xEnv.ConfigAxis.GridShow = argConfig.GridShow), 
                    void 0 !== argConfig.GridVertHide && null != argConfig.GridVertHide && (xEnv.ConfigAxis.GridVertHide = argConfig.GridVertHide), 
                    void 0 !== argConfig.GridHorzHide && null != argConfig.GridHorzHide && (xEnv.ConfigAxis.GridHorzHide = argConfig.GridHorzHide), 
                    void 0 !== argConfig.ShowCurrentPrice && null != argConfig.ShowCurrentPrice && (xEnv.HideAskBid = 1 != argConfig.ShowCurrentPrice), 
                    void 0 !== argConfig.ShowHighLowPrice && null != argConfig.ShowHighLowPrice && (xEnv.MinMaxTooltipShow = argConfig.ShowHighLowPrice), 
                    _self.ResizeChart(!0), !0;
                }, this.OnIndiSettingEnv = function(stIndiEnv) {
                    _self.m_xNormalLayout.OnIndiSettingEnv(stEnv), !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.OnIndiSettingEnv(stEnv);
                };
                var _didFindSeriesInfo = function(code) {
                    if (void 0 !== code && null != code) {
                        var count, indicators;
                        indicators = _self.m_xSeriesInfos.trend, count = indicators.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSeriesInfo = indicators[ii];
                            if (xSeriesInfo && code === xSeriesInfo.code) return xSeriesInfo;
                        }
                        indicators = _self.m_xSeriesInfos.oscillator, count = indicators.length;
                        for (var ii = 0; ii < count; ii++) {
                            var xSeriesInfo = indicators[ii];
                            if (xSeriesInfo && code === xSeriesInfo.code) return xSeriesInfo;
                        }
                    }
                }, _didApplySeriesInfo = function(argTypeId, argSettings) {
                    var xResult = {
                        typeId: argTypeId,
                        settings: argSettings,
                        seriesInfo: null
                    }, xSeriesInfo = _didFindSeriesInfo(argTypeId);
                    if (void 0 === xSeriesInfo || null == xSeriesInfo) return xResult;
                    xResult.seriesInfo = xSeriesInfo;
                    var xInfo;
                    return xInfo = argSettings && "string" == typeof argSettings ? JSON.parse(argSettings) : argSettings, 
                    xInfo && xUtils.indicator.didApplySeriesInfos(xSeriesInfo.info, xInfo), xResult.settings = xSeriesInfo.info, 
                    xResult;
                };
                this.didAddIndicator = function(code, info, isAdd) {
                    var xShowLists = _didGetAllIndicatorListIsShown();
                    if (void 0 !== xShowLists && null != xShowLists && void 0 !== xShowLists.length && null != xShowLists.length && xShowLists.length >= 10) return !1;
                    if (!0 === _self.hasExtraLayout()) return !1;
                    var xResult = _didApplySeriesInfo(code, info), typeId = xResult.typeId, settings = xResult.settings;
                    if (!0 === isAdd) return _self.m_xCurrentLayout.didAddIndicator(typeId, settings), 
                    !0;
                    var xSeriesInfo = xResult.seriesInfo;
                    if (void 0 === xSeriesInfo || null == xSeriesInfo) return !1;
                    if (xSeriesInfo.show) return !settings || _self.didChangeIndicatorSettingByTypeId(xSeriesInfo.code, xSeriesInfo.info);
                    var bResult = _self.m_xCurrentLayout.didAddIndicator(xSeriesInfo.code, xSeriesInfo.info);
                    return !0 === bResult && (xSeriesInfo.show = !0), bResult;
                }, this.didFindTrendlineInfoAt = function(trendLineCode) {
                    if (void 0 !== trendLineCode && null != trendLineCode) {
                        var trendLineInfo;
                        try {
                            trendLineInfo = _self.m_xTrendlineInfos[trendLineCode];
                        } catch (e) {
                            trendLineInfo = void 0;
                        }
                        return trendLineInfo;
                    }
                }, this.didApplyTrendlineInfoAt = function(trendLineCode, color, text) {
                    var trendLineInfo = _self.didFindTrendlineInfoAt(trendLineCode);
                    if (trendLineInfo) try {
                        return void 0 !== color && null != color && (trendLineInfo.styles.lineColor = color), 
                        void 0 !== text && null != text && trendLineInfo.code === xUtils.constants.trendLineCodes.text && (void 0 !== trendLineInfo.textInfo && null != trendLineInfo.textInfo || (trendLineInfo.textInfo = {}, 
                        trendLineInfo.textInfo.text = text), trendLineInfo.textInfo.text = text), trendLineInfo;
                    } catch (e) {}
                }, this.didApplyTrendline = function(trendLineCode, isSelect, color, text) {
                    if (!0 !== isSelect && !0 !== xUtils.trendLine.isDrawableTrendline(trendLineCode)) return void _self.m_xCurrentLayout.OnTrendLineAdd(trendLineCode);
                    if (!0 !== isSelect) {
                        try {
                            var selectedTrendline = _self.m_xCurrentLayout.didGetSelectedTrendlineInfo();
                            selectedTrendline && selectedTrendline.ls && (selectedTrendline.ls.m_bSelect = !1, 
                            _self.DrawingChartDrawFrame(!1));
                        } catch (e) {
                            console.error(e);
                        }
                        _self.didApplyTrendlineInfoAt(trendLineCode, color, text);
                        _self.m_xNormalLayout.OnTrendLineAdd(trendLineCode);
                    } else {
                        var selectedTrendline = _self.m_xCurrentLayout.didGetSelectedTrendlineInfo();
                        if (void 0 === selectedTrendline || null == selectedTrendline || void 0 === selectedTrendline.ls || null == selectedTrendline.ls) return;
                        try {
                            if (!0 === selectedTrendline.ls.didApplySimpleAttribute(color, text)) return _self.DrawingChartDrawFrame(!1), 
                            !0;
                        } catch (e) {}
                    }
                }, this.didClick_ActionButton = function(strId) {
                    _self.m_xCurrentLayout.didClick_ActionButton(strId);
                }, this.RecalcProc = function(nState, bFull) {
                    var xResult, nStart = 0, nSize = 0, bExtraLO = (_self.m_xCurrentLayout.GetDataSize(), 
                    _self.hasExtraLayout());
                    switch (nState) {
                      case xUtils.constants.ngcl.enum.EUS_UPDATE_IQ:
                      case xUtils.constants.ngcl.enum.EUS_YDIR_MOVE:
                        !0 === bExtraLO && (xResult = _self.m_xNontimeLayout.CalcForDraw(nStart, nSize, nState), 
                        nStart = xResult.screenStartIndex, nSize = xResult.screenSize), xResult = _self.m_xNormalLayout.CalcForDraw(nStart, nSize, nState), 
                        nStart = xResult.screenStartIndex, nSize = xResult.screenSize;
                        break;

                      case xUtils.constants.ngcl.enum.EUS_ADD_SERIES:
                      case xUtils.constants.ngcl.enum.EUS_UPDATE_RT:
                      case xUtils.constants.ngcl.enum.EUS_ZOOM:
                      case xUtils.constants.ngcl.enum.EUS_RESIZE:
                      case xUtils.constants.ngcl.enum.EUS_OBJECT_MOVE:
                      case xUtils.constants.ngcl.enum.EUS_CHANGE_LAYOUT:
                        !0 === bExtraLO && (xResult = _self.m_xNontimeLayout.CalcForDraw(nStart, nSize, nState), 
                        nStart = xResult.screenStartIndex, nSize = xResult.screenSize), xResult = _self.m_xNormalLayout.CalcForDraw(nStart, nSize, nState), 
                        nStart = xResult.screenStartIndex, nSize = xResult.screenSize;
                        break;

                      case xUtils.constants.ngcl.enum.EUS_SCROLL:
                        xResult = _self.m_xCurrentLayout.CalcForDraw(nStart, nSize, nState), nStart = xResult.screenStartIndex, 
                        nSize = xResult.screenSize;
                    }
                    _self.m_xNormalLayout.didCalculateDataForExtraObject(), !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.didCalculateDataForExtraObject();
                }, this.didSetLoadInfoForTheLineTools = function(argLoadInfos) {
                    return !(!_self.m_xNormalLayout.m_xDoBasePrice || !_self.m_xNormalLayout.m_xDoBasePrice.didSetLoadInfoForTheLineTools || !0 !== _self.m_xNormalLayout.m_xDoBasePrice.didSetLoadInfoForTheLineTools(argLoadInfos)) && (_self.DrawingChartDrawFrame(!1), 
                    !0);
                }, this.didGetSaveInfoOfTheLineTools = function() {
                    if (_self.m_xNormalLayout.m_xDoBasePrice && _self.m_xNormalLayout.m_xDoBasePrice.didGetSaveInfoOfTheLineTools) return _self.m_xNormalLayout.m_xDoBasePrice.didGetSaveInfoOfTheLineTools();
                }, this.didGetSaveInfo = function() {
                    var xResult = {
                        seriesInfos: []
                    };
                    try {
                        _self.m_xNormalLayout.didGetSaveInfo();
                    } catch (e) {
                        console.error(e);
                    }
                    return xResult;
                }, this.didApplyZoomInOut = function(isIn, step) {
                    var nDelta = 1;
                    !0 !== isIn && (nDelta *= -1), _self.didZoomScreen(nDelta, !0);
                }, this.didApplyGoToEndPos = function(bEndPos, isNotFix) {
                    _self.m_xNormalLayout.didScrollToEndPos(bEndPos, isNotFix, !0), !0 === _self.hasExtraLayout() && _self.m_xNontimeLayout.didScrollToEndPos(bEndPos, isNotFix, !0);
                }, this.didApplyLocalSetting = function(key, isOn) {
                    var xEnv = _self.didGetEnvInfo(), bRefresh = !1;
                    return "crossLine" === key ? (xEnv.CrossLine.hide = !0 !== isOn, bRefresh = !0) : "smoothScroll" === key ? xEnv.UseSmoothScroll = !0 === isOn : "newOrderLine" === key ? xEnv.UseNewOrderLine = !0 === isOn : "trendLineSelect" === key && (xEnv.DontTouchTrendline = !0 !== isOn), 
                    !0 === bRefresh && _self.DrawingChartDrawFrame(!1), !0;
                }, this.didApplyChartSetting = function(argSettings) {
                    var xChartConfig = argSettings;
                    if (void 0 === xChartConfig || null == xChartConfig) return !1;
                    var xEnv = _self.didGetEnvInfo();
                    return void 0 !== xChartConfig.UseSmoothScroll && null !== xChartConfig.UseSmoothScroll && (xEnv.UseSmoothScroll = xChartConfig.UseSmoothScroll), 
                    void 0 !== xChartConfig.GridVertColor && null !== xChartConfig.GridVertColor && (xEnv.ConfigAxis.GridVertColor = xChartConfig.GridVertColor), 
                    void 0 !== xChartConfig.GridHorzColor && null !== xChartConfig.GridHorzColor && (xEnv.ConfigAxis.GridHorzColor = xChartConfig.GridHorzColor), 
                    void 0 !== xChartConfig.OrderBidColor && null !== xChartConfig.OrderBidColor && (xEnv.OrderStyleConfig.bid.strokeColor = xChartConfig.OrderBidColor), 
                    void 0 !== xChartConfig.OrderAskColor && null !== xChartConfig.OrderAskColor && (xEnv.OrderStyleConfig.ask.strokeColor = xChartConfig.OrderAskColor), 
                    void 0 !== xChartConfig.OrderLineStyle && null !== xChartConfig.OrderLineStyle && (xEnv.OrderStyleConfig.bid.strokeStyle = xEnv.OrderStyleConfig.ask.strokeStyle = xChartConfig.OrderLineStyle), 
                    void 0 !== xChartConfig.PositBidColor && null !== xChartConfig.PositBidColor && (xEnv.PositStyleConfig.bid.strokeColor = xChartConfig.PositBidColor), 
                    void 0 !== xChartConfig.PositAskColor && null !== xChartConfig.PositAskColor && (xEnv.PositStyleConfig.ask.strokeColor = xChartConfig.PositAskColor), 
                    void 0 !== xChartConfig.PositLineStyle && null !== xChartConfig.PositLineStyle && (xEnv.PositStyleConfig.bid.strokeStyle = xEnv.PositStyleConfig.ask.strokeStyle = xChartConfig.PositLineStyle), 
                    void 0 !== xChartConfig.CandleUpColor && null !== xChartConfig.CandleUpColor && (xEnv.PriceStyleConfig.Candle.fillUpColor = xEnv.PriceStyleConfig.Candle.strokeUpColor = xEnv.PriceStyleConfig.OHLC.strokeUpColor = xEnv.PriceStyleConfig.HLC.strokeUpColor = xEnv.PriceStyleConfig.TLB.fillUpColor = xEnv.PriceStyleConfig.TLB.strokeUpColor = xEnv.PriceStyleConfig.KAGI.strokeUpColor = xEnv.PriceStyleConfig.RENKO.strokeUpColor = xEnv.PriceStyleConfig.PNF.strokeUpColor = xChartConfig.CandleUpColor), 
                    void 0 !== xChartConfig.CandleDnColor && null !== xChartConfig.CandleDnColor && (xEnv.PriceStyleConfig.Candle.fillDnColor = xEnv.PriceStyleConfig.Candle.strokeDnColor = xEnv.PriceStyleConfig.OHLC.strokeDnColor = xEnv.PriceStyleConfig.HLC.strokeDnColor = xEnv.PriceStyleConfig.TLB.fillDnColor = xEnv.PriceStyleConfig.TLB.strokeDnColor = xEnv.PriceStyleConfig.KAGI.strokeDnColor = xEnv.PriceStyleConfig.RENKO.strokeDnColor = xEnv.PriceStyleConfig.PNF.strokeDnColor = xChartConfig.CandleDnColor), 
                    void 0 !== xChartConfig.CandleLineColor && null !== xChartConfig.CandleLineColor && (xEnv.PriceStyleConfig.Candle.strokeColor = xEnv.PriceStyleConfig.Line.strokeColor = xEnv.PriceStyleConfig.RCL.strokeColor = xChartConfig.CandleLineColor), 
                    void 0 !== xChartConfig.GridShow && null != xChartConfig.GridShow && (xEnv.ConfigAxis.GridShow = xChartConfig.GridShow), 
                    void 0 !== xChartConfig.GridVertHide && null != xChartConfig.GridVertHide && (xEnv.ConfigAxis.GridVertHide = xChartConfig.GridVertHide), 
                    void 0 !== xChartConfig.GridHorzHide && null != xChartConfig.GridHorzHide && (xEnv.ConfigAxis.GridHorzHide = xChartConfig.GridHorzHide), 
                    void 0 !== xChartConfig.ShowCurrentPrice && null != xChartConfig.ShowCurrentPrice && (xEnv.HideAskBid = 1 != xChartConfig.ShowCurrentPrice), 
                    void 0 !== xChartConfig.ShowHighLowPrice && null != xChartConfig.ShowHighLowPrice && (xEnv.MinMaxTooltipShow = xChartConfig.ShowHighLowPrice), 
                    void 0 !== xChartConfig.DetailViewStatusIsShown && null != xChartConfig.DetailViewStatusIsShown && (xEnv.DetailViewStatusIsShown = xChartConfig.DetailViewStatusIsShown), 
                    _self.DrawingChartDrawFrame(!1), !0;
                };
                var _didApplySeriesPlotColorInfo = function(argTypeId, plotColorInfos) {
                    var xResult = {
                        typeId: argTypeId,
                        settings: null,
                        seriesInfo: null
                    }, xSeriesInfo = _didFindSeriesInfo(argTypeId);
                    if (void 0 === xSeriesInfo || null == xSeriesInfo) return !1;
                    xResult.seriesInfo = xSeriesInfo;
                    var xInfo = plotColorInfos;
                    if (!xInfo) return !1;
                    if (!0 !== xUtils.indicator.didApplySeriesPlotColorInfos(xSeriesInfo.info, xInfo)) return !1;
                    xResult.settings = xSeriesInfo.info;
                    try {
                        var typeId = xResult.typeId, settings = xResult.settings, xSeriesInfo = xResult.seriesInfo;
                        if (void 0 === xSeriesInfo || null == xSeriesInfo) return !1;
                        if (_self.m_xNormalLayout && _self.m_xNormalLayout.didChangeIndicatorSettingByTypeId) return _self.m_xNormalLayout.didChangeIndicatorSettingByTypeId(typeId, settings);
                    } catch (e) {}
                    return !1;
                };
                this.didApplyChartIndicatorPlotColorSetting = function(argSettings) {
                    if (void 0 === argSettings || null == argSettings) return !1;
                    var xSetting, nCount = 0;
                    if (void 0 === argSettings.length || null == argSettings.length ? xSetting = argSettings : (nCount = argSettings.length) > 0 && (xSetting = argSettings[0]), 
                    !xSetting || !xSetting.code || !xSetting.plot) return !1;
                    if (_didApplySeriesPlotColorInfo(xSetting.code, xSetting.plot), nCount > 1) for (var ii = 1; ii < nCount; ii++) (xSetting = argSettings[ii]) && xSetting.code && xSetting.plot && _didApplySeriesPlotColorInfo(xSetting.code, xSetting.plot);
                    return _self.DrawingChartDrawFrame(!1), !0;
                }, this.didSetPointValueForCurrentSymbol = function(argPoint) {
                    _self.m_xNormalLayout.m_xDoBasePrice.m_point = argPoint, _self.RecalcProc(xUtils.constants.ngcl.enum.EUS_CHANGE_LAYOUT), 
                    _self.ResizeChart(!0);
                }, this.GetCurrentSymbolInfo = function() {
                    return _self.m_xNormalLayout.m_xDoBasePrice.m_symbolInfo;
                }, this.didGetSBHandle = function() {
                    return _self.m_zsbHandle;
                }, this.didSetZSBHandle = function(zsbHandle) {
                    try {
                        var xEnv = _self.didGetEnvInfo();
                        if (_self.m_zsbHandle = zsbHandle, _self.m_zsbHandle.didSetDelegate(_self), _self.m_zsbHandle && _self.m_zsbHandle.SetZSBInit) {
                            var xScrollInfo = _self.m_xCurrentLayout.didGetScrollInfo();
                            _self.m_zsbHandle.SetZSBInit(xScrollInfo.screenSize, xScrollInfo.range.length, xEnv.System.Scroll.screenSize.min, xEnv.System.Scroll.screenSize.max);
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }, this.DidScrollToPos = function(caller, nPos, nShows) {
                    _self.m_xCurrentLayout.DidScrollToPos(nPos, nShows);
                }, this.WillBeDrawnBackground = function(caller, notifyData) {
                    return _self.m_xCurrentLayout.WillBeDrawnBackground(notifyData), !1;
                }, this.didGetRestoreIndicatorInformationByTypeId = function(argTypeId, isSave) {
                    var xSeriesInfo = _didFindSeriesInfo(argTypeId);
                    if (void 0 !== xSeriesInfo && null != xSeriesInfo) {
                        var xInfo = xUtils.indicator.didConvertToRestoreSeriesInformation(xSeriesInfo.info, isSave);
                        if (xInfo) {
                            return {
                                code: xSeriesInfo.code,
                                show: xSeriesInfo.show,
                                info: xInfo
                            };
                        }
                    }
                }, this.didUpdateTrendlinesStyle = function(color, text) {
                    try {
                        if (_self.m_xTrendlineInfos) {
                            var xtlKeys = Object.keys(_self.m_xTrendlineInfos);
                            if (xtlKeys && xtlKeys.length && xtlKeys.length > 0) for (var nCount = xtlKeys.length, ii = 0; ii < nCount; ii++) {
                                var trendLineCode = xtlKeys[ii];
                                "TL" == trendLineCode.substring(0, 2) && (!0 === xUtils.trendLine.isDrawableTrendline(trendLineCode) && _self.didApplyTrendlineInfoAt(trendLineCode, color, text));
                            }
                        }
                    } catch (e) {
                        console.error(e);
                    }
                    return !0;
                }, this.didUpdateAskBidData = function(hide, ask, bid, validFlag) {
                    try {
                        _self.m_xNormalLayout.didUpdateAskBidData && _self.m_xNormalLayout.didUpdateAskBidData(hide, ask, bid, validFlag) && _self.DrawingChartDrawFrame(!1);
                    } catch (e) {
                        console.error(e);
                    }
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDrawWrap = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.chartDrawPanelNormalCFD) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(18));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, layoutBaseClass) {
            return function(chartWrapper, ctrlLayout) {
                var _self = this, _chartWrapper = chartWrapper;
                this.prototype = new layoutBaseClass(chartWrapper, ctrlLayout), layoutBaseClass.apply(this, arguments), 
                this.OBJECT_NAME = "CFD_NORMAL_LAYOUT", this.OnContextMenu = function(posval, contextMenu, isAxisArea, actionArea) {
                    if (_self.didClearTooltipEventer(), _self.didShowTooltip(!1), 1 != isAxisArea && (!actionArea || 1 != actionArea.isDetail && 1 != actionArea.isLegend)) {
                        var isCrossHairMode = xUtils.trendLine.isCrossHairMode(_self.m_strTrendLine);
                        if (!(_self.m_bTrendLine && 1 != isCrossHairMode || _self.m_bMouseRowResize)) {
                            var xResult = _self.didGetPanelInfoAtPos(posval);
                            if (xResult && "object" == typeof contextMenu) {
                                var xDoPrice = _self.didGetReferencedPriceObject();
                                if (contextMenu.symbolCode = xDoPrice.m_symbolInfo.strCode, contextMenu.symbol = xUtils.didClone(xDoPrice.m_symbolInfo), 
                                !0 !== xResult.isMain) return contextMenu.isMain = !1, void _chartWrapper.didReflectCallForContextMenu(contextMenu);
                                var xDoSelected, objectInfo, xPanel = xResult.panel, hitPosVal = xUtils.didClone(posval), xTestPanel = xPanel;
                                actionArea && 1 == actionArea.isExtraArea && _self.m_xExtraPanel && (xTestPanel = _self.m_xExtraPanel), 
                                xTestPanel.OnSelectChartObj(hitPosVal) >= 0 && (xDoSelected = xTestPanel.m_xSelectedOepObject || xTestPanel.m_xDoExtraSelected) && (objectInfo = xDoSelected.didGetOepObjectInfo()), 
                                contextMenu.isMain = !0, contextMenu.price = xPanel.GetYPosToVal(posval.YPos), contextMenu.verpos = xDoPrice.didGetPointValue(), 
                                contextMenu.objectInfo = objectInfo, contextMenu.pricePos = 0, xDoPrice.didCheckPricePos && (contextMenu.pricePos = xDoPrice.didCheckPricePos(contextMenu.price)), 
                                actionArea && actionArea.isExtraArea && (contextMenu.isMain = !1), _chartWrapper.didReflectCallForContextMenu(contextMenu);
                            }
                        }
                    }
                }, this.didUpdateAskBidData = function(hide, ask, bid, validFlag) {
                    try {
                        var xDoPrice = _self.didGetReferencedPriceObject();
                        if (xDoPrice && xDoPrice.didUpdateAskBidData) return xDoPrice.didUpdateAskBidData(hide, ask, bid, validFlag);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didHitTestForOnMoveInMain = function(posval) {
                    if (posval) {
                        if (1 == xUtils.trendLine.isObjectMovableMode(_self.m_strTrendLine)) {
                            var hitPosVal = xUtils.didClone(posval);
                            hitPosVal.__onmove__ = !0;
                            var xDoSelected, localDrawFrame = _self.m_arrChartDrawFramelist[_self.m_iCanvasMouseMoveIndex];
                            if (localDrawFrame && localDrawFrame.m_bMainFrame && localDrawFrame.OnSelectChartObj(hitPosVal, !0) >= 0) {
                                if ((xDoSelected = localDrawFrame.m_xSelectedOepObject) && 1 == xDoSelected.m_bOrder) return xDoSelected;
                                if (xDoSelected = localDrawFrame.m_selectTrendlineObj) {
                                    var trendLineInfo = xUtils.trendLine.didGetDefaultTrendlineInfoAt(xDoSelected.m_strTrendlineName);
                                    if (trendLineInfo && 1 == trendLineInfo.isHoverObject) return xDoSelected;
                                }
                            }
                        }
                    }
                }, this.didProcForMouseHoverOnObject = function(posval, actionArea) {
                    try {
                        if (!posval) return;
                        if (actionArea) return;
                        var cursor, xEnv = _self.didGetEnvInfo();
                        if (!xEnv.System.CursorConfig || !(cursor = xEnv.System.CursorConfig["hover-object"])) return;
                        if (1 != xUtils.isAvailableToSelectObject(xEnv)) return;
                        _self.didHitTestForOnMoveInMain(posval) ? _self.SetMouseCursor(cursor, !0) : _self.SetMouseCursor("", !0);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.OnTrendLineAdd = function(strTrendLine) {
                    var xEnv = _self.didGetEnvInfo();
                    if (xEnv.System.CursorConfig) try {
                        var trendLineInfo = xUtils.trendLine.didGetDefaultTrendlineInfoAt(strTrendLine), cursor = "";
                        trendLineInfo && trendLineInfo.cursor && (cursor = trendLineInfo.cursor), _self.SetMouseCursor(cursor, !0);
                    } catch (e) {
                        console.error(e);
                    }
                    if (_self.m_bTrendLine = xUtils.trendLine.isDrawableTrendline(strTrendLine), _self.m_bTrendLine) _self.m_strTrendLine = strTrendLine; else {
                        strTrendLine === xUtils.constants.trendLineCodes.deleteOne ? function(argPanel) {
                            void 0 !== argPanel && null != argPanel && void 0 !== argPanel.didRemoveSelectedLineTool && (argPanel.didRemoveSelectedLineTool(), 
                            _self.DrawingChartDrawFrame(!0));
                        }(_self.GetDrawPanelAt(_self.m_iCanvasMouseDownIndex)) : strTrendLine === xUtils.constants.trendLineCodes.deleteAll && (_self.didRemoveAllLineTools(!0), 
                        _self.DrawingChartDrawFrame(!0)), _self.m_strTrendLine = strTrendLine;
                    }
                    1 == xUtils.didStateChangeOnTrendline(xEnv, _self.m_strTrendLine) && _self.DrawingChartDrawFrame(!1);
                }, this.didProcessForDeleteKeyEvent = function(keyValue) {}, this.didProcForCursorForTrendline = function(strTrendLine, cursor) {
                    if (_self.UnsetMouseCursor(), _self.didGetEnvInfo().System.CursorConfig) try {
                        var trendLineInfo = xUtils.trendLine.didGetDefaultTrendlineInfoAt(strTrendLine);
                        trendLineInfo && trendLineInfo.cursor && (cursor = trendLineInfo.cursor), _self.SetMouseCursor(cursor, !0);
                    } catch (e) {
                        console.error(e);
                    } else _self.SetMouseCursor(cursor);
                }, this.didCheckOepPosInAxisArea = function(posval) {};
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDrawPanelNormal = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.chartDrawPanelNormal) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(19));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, layoutBaseClass, drawFrameClass, xAxisPanelClass, axisUnitFactory) {
            return function(chartWrapper, ctrlLayout) {
                var _self = this, _chartWrapper = chartWrapper, _ctrlLayout = ctrlLayout;
                this.prototype = new layoutBaseClass(chartWrapper, ctrlLayout), layoutBaseClass.apply(this, arguments), 
                this.OBJECT_NAME = "NORMAL_LAYOUT", this.didCreateAxisXPanel = function() {
                    _self.m_chartXAxisObj = new xAxisPanelClass(_chartWrapper, _self, _ctrlLayout), 
                    _self.m_chartXAxisObj.Init();
                }, this.GetDataSize = function() {
                    return _self.GetDataCount();
                };
                var _CalcForDrawV = function(nStart, nSize, nState) {
                    var result = {
                        screenStartIndex: nStart,
                        screenSize: nSize
                    };
                    if (!_self.CheckForDraw()) return result;
                    _self.SetAxisStyle(xUtils.constants.ngc.enum.ELS_VOLUME, !0);
                    var xEnv = _ctrlLayout.didGetEnvInfo();
                    _self.m_nXWidth = _self.GetChartFrameAreaWidth(), _self.m_xAxisX.m_nDiffSize = 5;
                    var rc = _self.GetFullDrawPanelRect(), nWidth = rc.width;
                    _self.m_nXWidth = rc.width, rc = _self.CheckMulti1Panel(rc), _self.m_nXWidth = nWidth = rc.width;
                    var xFullRange = _self.didGetFullRange(), nZoomSize = _self.ExGetZoomInfo();
                    if (_self.m_xAxisX.m_stScaleInfo.dMaxS = xFullRange.length, _self.m_xAxisX.m_stScaleInfo.dMinS = 0, 
                    _self.m_nScrDSize = nZoomSize, _self.m_nScrDSize <= 0) return result;
                    var xScrInfo;
                    if (void 0 === (xScrInfo = _self.CalcScrDInfo(nStart, nSize, nState)) || null == xScrInfo) return result;
                    nStart = xScrInfo.screenStartIndex, nSize = xScrInfo.screenSize, result.screenStartIndex = nStart, 
                    result.screenSize = nSize;
                    var nOffMinus = xUtils.didCalculateShiftValue(_self.m_xShiftInfo, xUtils.constants.default.SHIFT_IS_ST), nDataIdx = xUtils.EC_GetDataZScr(nStart, nOffMinus, 0, !1), xVolume = _self.didCalcReferencedPriceVolumeAtRange({
                        position: nDataIdx,
                        length: nSize
                    }), dVolFull = xVolume.fullVolume, dVol = xVolume.rangeVolume;
                    if (dVol < -1) return result;
                    var nRWidth = nWidth - (nSize + 1) * xEnv.System.Gap;
                    return _self.m_xAxisX.CalcAxisInfoVol(_self, nRWidth, nOffMinus, 1, xFullRange.length, dVol, dVolFull, result.screenStartIndex, result.screenSize), 
                    result;
                }, _CalcForDrawN = function(nStart, nSize, nState) {
                    var result = {
                        screenStartIndex: nStart,
                        screenSize: nSize
                    };
                    if (!_self.CheckForDraw()) return result;
                    _self.SetAxisStyle(xUtils.constants.ngc.enum.ELS_NORMAL, !0), _self.m_xAxisX.m_nDiffSize = 0;
                    var rc = (_ctrlLayout.didGetEnvInfo(), _self.GetFullDrawPanelRect()), nWidth = rc.width;
                    _self.m_nXWidth = rc.width, rc = _self.CheckMulti1Panel(rc), _self.m_nXWidth = nWidth = rc.width;
                    var xFullRange = _self.didGetFullRange(), nDataSize = (_self.ExGetZoomInfo(), _self.GetDataSize()), nOffFull = _self.m_xShiftInfo.all;
                    _self.m_xAxisX.m_stScaleInfo.dMaxS = xFullRange.length, _self.m_xAxisX.m_stScaleInfo.dMinS = 0, 
                    _self.m_nScrDSize = _self.m_xAxisX.CalcAxisInfoByScrollInfo(_self, nWidth, _self.m_xScrollInfo, nDataSize, nOffFull);
                    var xScrInfo;
                    return void 0 === (xScrInfo = _self.CalcScrDInfo(nStart, nSize, nState)) || null == xScrInfo ? result : (result.screenStartIndex = xScrInfo.screenStartIndex, 
                    result.screenSize = xScrInfo.screenSize, result);
                };
                this.CalcForDraw = function(nStart, nSize, nState) {
                    var result = {
                        screenStartIndex: nStart,
                        screenSize: nSize
                    };
                    switch (_self.m_nAxisX) {
                      case xUtils.constants.ngc.enum.ELS_NORMAL:
                      case xUtils.constants.ngc.enum.ELS_FULL:
                        result = _CalcForDrawN(nStart, nSize, nState);
                        break;

                      case xUtils.constants.ngc.enum.ELS_VOLUME:
                        result = _CalcForDrawV(nStart, nSize, nState);
                    }
                    return result;
                }, this.OnTrendLineAdd = function(strTrendLine) {
                    if (_self.m_bTrendLine = xUtils.trendLine.isDrawableTrendline(strTrendLine), !_self.m_bTrendLine) {
                        return strTrendLine === xUtils.constants.trendLineCodes.deleteOne ? function(argPanel) {
                            void 0 !== argPanel && null != argPanel && void 0 !== argPanel.didRemoveSelectedLineTool && (argPanel.didRemoveSelectedLineTool(), 
                            _self.DrawingChartDrawFrame(!0));
                        }(_self.GetDrawPanelAt(_self.m_iCanvasMouseDownIndex)) : strTrendLine === xUtils.constants.trendLineCodes.deleteAll && (_self.didRemoveAllLineTools(!0), 
                        _self.DrawingChartDrawFrame(!0)), void (_self.m_strTrendLine = strTrendLine);
                    }
                    _self.m_strTrendLine = strTrendLine;
                }, this.didGetObjectInfo = function(objectName, isSelected) {
                    if (!0 === isSelected) {
                        var xSelectedPanel = _self.GetDrawPanelAt(_self.m_iCanvasMouseDownIndex);
                        if (void 0 !== xSelectedPanel && null != xSelectedPanel) {
                            return xSelectedPanel.didFindSelectedObject();
                        }
                    }
                }, this.didGetOrderingInfoForIndicators = function(argList) {
                    if (!(void 0 === argList || null == argList || void 0 === argList.length || null == argList.length || argList.length < 1)) {
                        for (var nCount = _self.m_arrChartDrawFramelist.length, xOrderingInfos = [], ii = 0; ii < nCount; ii++) {
                            var xPanel = _self.m_arrChartDrawFramelist[ii], xOi = [], listLen = argList.length;
                            if (xPanel && xPanel.didFindFirstIndicatorObjectByTypeId) for (var jj = 0; jj < listLen; jj++) {
                                var typeId = argList[jj];
                                if (xPanel.didFindFirstIndicatorObjectByTypeId(typeId)) {
                                    xOi.push(typeId), argList.splice(jj, 1);
                                    break;
                                }
                            }
                            xOi.length > 0 && xOrderingInfos.push(xOi);
                        }
                        return xOrderingInfos.length > 0 ? xOrderingInfos : void 0;
                    }
                }, this.didChangeIndicatorSettingByKey = function(argKey, argSettings) {
                    for (var xChanged = {
                        isMulti: !1,
                        param: !1,
                        plot: !1,
                        shift: !1,
                        line: !1
                    }, bResult = !1, nCount = _self.m_arrChartDrawFramelist.length, ii = 0; ii < nCount; ii++) {
                        var xPanel = _self.m_arrChartDrawFramelist[ii];
                        if (xPanel && xPanel.didChangeIndicatorSettingByKey && !0 === (bResult = xPanel.didChangeIndicatorSettingByKey(argKey, argSettings, xChanged))) break;
                    }
                    if (!0 === bResult) return _self.didEndChangeForIndicator(!1, xChanged), !0;
                }, this.didChangeIndicatorSettingByTypeId = function(argTypeId, argSettings) {
                    for (var xEnv = _self.didGetEnvInfo(), xChanged = {
                        isMulti: xEnv.System.MultipleSeries,
                        param: !1,
                        plot: !1,
                        shift: !1,
                        line: !1
                    }, bResult = !1, nCount = _self.m_arrChartDrawFramelist.length, ii = 0; ii < nCount; ii++) {
                        var xPanel = _self.m_arrChartDrawFramelist[ii];
                        if (xPanel && xPanel.didChangeIndicatorSettingByTypeId) {
                            var bRes = xPanel.didChangeIndicatorSettingByTypeId(argTypeId, argSettings, xChanged);
                            if (!0 === xEnv.System.MultipleSeries) bResult |= bRes; else if (!0 === bRes) {
                                bResult = bRes;
                                break;
                            }
                        }
                    }
                    if (!0 === bResult) return _self.didEndChangeForIndicator(!1, xChanged), !0;
                }, this.didGetCurrentLiveIndicatorInformationAll = function() {
                    for (var nCount = _self.m_arrChartDrawFramelist.length, xResult = {
                        trends: [],
                        ocillators: []
                    }, ii = 0; ii < nCount; ii++) {
                        var xPanel = _self.m_arrChartDrawFramelist[ii];
                        if (xPanel && xPanel.didGetCurrentLiveIndicatorInformationAll) {
                            var arrInfos1 = xPanel.didGetCurrentLiveIndicatorInformationAll(!1, !0);
                            arrInfos1 && arrInfos1.length && arrInfos1.length > 0 && xUtils.didAppendDatas(xResult.trends, arrInfos1);
                            var arrInfos2 = xPanel.didGetCurrentLiveIndicatorInformationAll(!1, !1);
                            arrInfos2 && arrInfos2.length && arrInfos2.length > 0 && xUtils.didAppendDatas(xResult.ocillators, arrInfos2);
                        }
                    }
                    return xResult;
                }, this.didDeleteTargetToolObject = function(argDoLs) {
                    if (!0 === xUtils.trendLine.didDeleteTargetToolObject(argDoLs)) return _self.DrawingChartDrawFrame(!1), 
                    !0;
                };
                var _didDeleteTargetIndicator = function(argTypeId) {
                    for (var nCount = _self.m_arrChartDrawFramelist.length, ii = 0; ii < nCount; ii++) {
                        var xPanel = _self.m_arrChartDrawFramelist[ii];
                        if (void 0 !== xPanel && null != xPanel) {
                            var xResult = xPanel.didDeleteIndicator(argTypeId);
                            if (void 0 !== xResult && null != xResult) return _self.didEndChangeForIndicator(!0), 
                            xResult;
                        }
                    }
                };
                this.didProcessForDeleteKeyEvent = function(keyValue) {
                    var xSelectedPanel = _self.GetDrawPanelAt(_self.m_iCanvasMouseDownIndex);
                    if (void 0 !== xSelectedPanel && null != xSelectedPanel) {
                        var xInfo = xSelectedPanel.didFindSelectedObject();
                        if (xInfo) if (xInfo.tool && xInfo.tool.ls) {
                            var xDoLs = xInfo.tool.ls;
                            if (!0 === _self.didDeleteTargetToolObject(xDoLs)) return;
                        } else if (xInfo.indicator) {
                            var xTargetInfo = _self.didDeleteSelectedIndicator();
                            _self.m_ctrlLayout.didNotifyForDeletingIndicator(xTargetInfo);
                        }
                    }
                }, this.didDeleteSelectedIndicator = function() {
                    return _didDeleteTargetIndicator();
                }, this.didDeleteIndicatorByTypeId = function(argTypeId) {
                    return _didDeleteTargetIndicator(argTypeId);
                }, this.didGetAxisX = function() {
                    return _self;
                }, this.didConvertPixelToOffset = function(argPixel) {
                    if (void 0 !== _self.m_xAxisX && null != _self.m_xAxisX) {
                        var __offset = _self.m_xAxisX.GetMovePx2Idx(_self, argPixel, !1);
                        return __offset;
                    }
                    var __ratio = _self.didGetRatioHorizontal(!0), __offset = parseInt(argPixel * __ratio);
                    return __offset;
                }, this.GetXIndexGap = function(iXPos) {
                    if (void 0 !== _self.m_xAxisX && null != _self.m_xAxisX) {
                        var nScrSIdx = _self.m_xScrollInfo.pos, xOutput = {};
                        _self.m_xAxisX.GetPos2Index(_self, nScrSIdx, 0, iXPos, !1, 0, xOutput);
                        return xOutput.nRIdx;
                    }
                    var __ratio = _self.didGetRatioHorizontal(!0);
                    return parseInt(iXPos * __ratio);
                }, this.GetXIndex = function(iXPos) {
                    return _self.didConvertHorizontalPosToDataIndex(iXPos, !0);
                }, this.didConvertHorizontalPosToDataIndex = function(argPosX, bRelative) {
                    var __posX = !0 === bRelative ? argPosX : _self.GetRelativePostionX(argPosX), __nLocalIndex = _self.didConvertPixelToOffset(__posX);
                    return _self.didConvertLocalIndexToDataIndex(__nLocalIndex);
                }, this.GetXPos = function(argLocalIdx) {
                    if (void 0 !== _self.m_xAxisX && null != _self.m_xAxisX) {
                        var nScrSIdx = _self.m_xScrollInfo.pos, nScrCIdx = argLocalIdx + nScrSIdx, xLRInfo = {};
                        return _self.m_xAxisX.GetIndex2Pixel(_self, nScrSIdx, 0, nScrCIdx, xLRInfo);
                    }
                    var __ratio = _self.didGetRatioHorizontal(!1), __nGridWidth = __ratio, iXPos = Math.round(argLocalIdx * __ratio);
                    return iXPos = Math.round(iXPos + __nGridWidth / 2);
                }, this.GetXPosAtDataIndex = function(dataIndex) {
                    var __localIndex = _self.didConvertDataIndexToLocalIndex(dataIndex);
                    return _self.GetXPos(__localIndex);
                }, this.GetIndex2Pixel = function(dataIndex, extraOuput) {
                    var nScrSIdx = _self.m_xScrollInfo.pos, nScrCIdx = _self.m_xShiftInfo.left + dataIndex;
                    return _self.m_xAxisX.GetIndex2Pixel(_self, nScrSIdx, 0, nScrCIdx, extraOuput);
                }, this.didGetRatioHorizontal = function(baseIsPixel) {
                    if (void 0 !== _self.m_xAxisX && null != _self.m_xAxisX) {
                        var __ratio = 0;
                        return 0 !== _self.m_xAxisX.m_dRatioD && (__ratio = baseIsPixel ? 1 / _self.m_xAxisX.m_dRatioD : _self.m_xAxisX.m_dRatioD), 
                        __ratio;
                    }
                    var __ratio = 0, __frameWidth = _self.GetChartFrameAreaWidth(), __nScreenSize = _self.m_xScrollInfo.screenSize;
                    return __ratio = baseIsPixel ? __nScreenSize / __frameWidth : __frameWidth / __nScreenSize;
                }, this.didGetAdjustedBarInfo = function(nLocalXPos) {
                    var __ratio = _self.didGetRatioHorizontal(!1), __barWidth = __ratio;
                    return xUtils.axis.didGetAdjustedBarInfo(__barWidth, nLocalXPos);
                }, this.didGetSaveInfo = function() {}, this.didProcForMouseDownInAxisArea = function(posval, argEvent) {
                    var check = _self.didCheckOepPosInAxisArea(posval);
                    if (void 0 === check || null == check) return !1;
                    var xResult = check.result;
                    check.cursor && _self.SetMouseCursor(check.cursor), _self.didDeselectAllFrameObjects();
                    var trendLineInfo, localDrawFrame = (_self.m_xDoBasePrice.m_symbolInfo, xResult.panel), strOrderLine = xUtils.constants.trendLineCodes.orderLine;
                    try {
                        trendLineInfo = _ctrlLayout.didFindTrendlineInfoAt(strOrderLine), trendLineInfo.isAdd = !0;
                    } catch (e) {}
                    return localDrawFrame.CreateTrendlineObj(strOrderLine, posval, trendLineInfo), _self.m_bOrderLine = !0, 
                    _self.DrawingChartDrawFrame(!1), !0;
                }, this.didCheckOepPosInAxisArea = function(posval) {
                    if (!_self.m_bTrendLine && !_self.m_bMouseRowResize) {
                        var xResult = _self.didGetPanelInfoAtPos(posval);
                        if (xResult && !0 === xResult.isMain) {
                            var xEnv = _self.didGetEnvInfo();
                            if (!0 === xEnv.System.UseOneClickOepMode) {
                                var cursor = "crosshair";
                                return void 0 !== xEnv.System.OepMouseCursor && null != xEnv.System.OepMouseCursor && (cursor = "url(" + xEnv.System.OepMouseCursor + "), crosshair"), 
                                {
                                    result: xResult,
                                    cursor: cursor
                                };
                            }
                        }
                    }
                }, this.OnContextMenu = function(posval, contextMenu) {
                    if (_self.didClearTooltipEventer(), _self.didShowTooltip(!1), !_self.m_bTrendLine && !_self.m_bMouseRowResize) {
                        var xResult = _self.didGetPanelInfoAtPos(posval);
                        if (xResult && !0 === xResult.isMain && _self.m_xDoBasePrice && _self.m_xDoBasePrice.m_symbolInfo) {
                            _self.didDeselectAllFrameObjects();
                            var localDrawFrame, objectInfo, symbolInfo = _self.m_xDoBasePrice.m_symbolInfo, isNew = !1, xEnv = _self.didGetEnvInfo();
                            contextMenu.symbolCode = symbolInfo.strCode, contextMenu.symbol = xUtils.didClone(symbolInfo);
                            var __newOrderFunc__ = function(localDrawFrame, posval, symbolInfo) {
                                var __nPrice = localDrawFrame.GetYPosToVal(posval.YPos);
                                return __nPrice = xUtils.axis.didAdjustZFValue(__nPrice, !0), {
                                    symbol: xUtils.didClone(symbolInfo),
                                    symbolCode: symbolInfo.strCode,
                                    price: __nPrice
                                };
                            };
                            if (0 === xResult.axis) {
                                if (xResult.panel) if (localDrawFrame = xResult.panel, localDrawFrame.OnSelectChartObj(posval), 
                                localDrawFrame.m_selectTrendlineObj) localDrawFrame.m_selectTrendlineObj.m_bSelect = !1; else if (localDrawFrame.m_xSelectedOepObject) {
                                    var objectInfo = localDrawFrame.m_xSelectedOepObject.didGetOepObjectInfo();
                                    objectInfo && (contextMenu.objectInfo = objectInfo.origin, !0 === objectInfo.isOrder ? objectInfo.isCancel = !0 : objectInfo.isPosit = !0, 
                                    contextMenu.isNew = isNew = !1, !0);
                                } else contextMenu.objectInfo = objectInfo = __newOrderFunc__(localDrawFrame, posval, symbolInfo), 
                                contextMenu.price = objectInfo.price, contextMenu.isNew = isNew = !0, !0;
                            } else !0 === xEnv.System.ContextMenuOrderAll && xResult.panel && (localDrawFrame = xResult.panel, 
                            contextMenu.objectInfo = objectInfo = __newOrderFunc__(localDrawFrame, posval, symbolInfo), 
                            contextMenu.price = objectInfo.price, contextMenu.isNew = isNew = !0, !0);
                            objectInfo && (1 == isNew ? _self.m_chartWrapper.didReflectCallForNewOrder(contextMenu) : 1 == objectInfo.isOrder ? contextMenu.objectInfo && !0 === contextMenu.objectInfo.cancelableFlag && (contextMenu.isCancel = !0, 
                            _self.m_chartWrapper.didReflectCallForCancelOrder(contextMenu)) : contextMenu.objectInfo && !0 === contextMenu.objectInfo.checkSettlementFlag && (contextMenu.isPosit = !0, 
                            _self.m_chartWrapper.didReflectCallForExecutionOrder(contextMenu))), _self.DrawingChartDrawFrame(!1);
                        }
                    }
                }, this.WillBeDrawnBackground = function(notifyData) {
                    if (notifyData && _self.m_xDoBasePrice) try {
                        var pstDp = notifyData;
                        _self.m_xDoBasePrice.didDrawPriceOnFullMode(pstDp);
                    } catch (e) {
                        console.error(e);
                    }
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDrawPanelNormal = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.chartDrawPanelBase, global.WGC_CHART.chartDrawFrameNormal, global.WGC_CHART.chartXAxisPanelNormal, global.WGC_CHART.chartAxisUnit) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(20), __webpack_require__(7), __webpack_require__(11), __webpack_require__(3));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, drawFrameClass, xAxisPanelClass, doFactory, axisUnitFactory, extraPanelClass, tooltipClass, gxDc) {
            return function(chartWrapper, ctrlLayout) {
                var _self = this, _chartWrapper = chartWrapper, _drawFrameClass = drawFrameClass, _ctrlLayout = ctrlLayout;
                this.OBJECT_NAME = "BASE_LAYOUT", this.m_doFactory = doFactory, this.m_chartWrapper = _chartWrapper, 
                this.m_ctrlLayout = _ctrlLayout, this.m_domElemChartDraw = null, this.m_xDoBasePrice = null, 
                this.m_arrChartDrawFramelist = [], this.m_chartXAxisObj = null, this.m_arrIchiMokulist = [], 
                this.m_strCompareCode = "", this.m_strDomElemPostfix = "", this.m_arrDoSubPrices = [], 
                this.m_domElems = {
                    layoutRoot: null,
                    layout: null,
                    panelRoot: null,
                    axis: null,
                    axisCanvas: null,
                    axisLabel: null
                }, this.m_xScrollInfo = {
                    pos: 0,
                    range: {
                        location: 0,
                        length: 0
                    },
                    screenSize: _ctrlLayout.m_stEnv.System.Scroll.zoom,
                    useCalcZoom: !0,
                    barSize: _ctrlLayout.m_stEnv.System.Scroll.barSize,
                    barGap: _ctrlLayout.m_stEnv.System.Scroll.barGap,
                    levelList: _ctrlLayout.m_stEnv.System.Scroll.LevelList,
                    level: _ctrlLayout.m_stEnv.System.Scroll.Level ? _ctrlLayout.m_stEnv.System.Scroll.Level : 0
                }, this.m_xShiftInfo = {
                    all: 0,
                    left: 0,
                    right: 0
                }, this.m_iSpanMax = 0, this.m_iStartX = 0, this.m_iEndX = 0, this.m_iXPosIndex = 0, 
                this.m_bMouseDown = !1, this.m_bMouseRowResize = !1, this.m_bMouseUpXArea = !1, 
                this.m_iXPosMouseDown = 0, this.m_bTrendLine = !1, this.m_bOrderLine = !1, this.m_bMouseDownSelectedChartObj = !1, 
                this.m_ptCrossline = {}, this.m_bCrosslineObject = !1, this.m_nSelectedChartObjectIndex = -1, 
                this.m_SelectFrame = null, this.m_iRowPos = null, this.m_iCanvasMouseDownIndex = 0, 
                this.m_iCanvasMouseMoveIndex = 0, this.m_symbolInfo = {}, this.m_xPriceInfo = {
                    m_iHighVal: -xUtils.constants.default.DEFAULT_WRONG_VALUE,
                    m_iLowVal: xUtils.constants.default.DEFAULT_WRONG_VALUE,
                    m_iUpCount: 0,
                    m_iDownCount: 0,
                    m_bStateUp: !1,
                    m_bStateDown: !1,
                    m_iOpenVal: 0,
                    m_iBoxCount: 0,
                    m_iBoxSize: 0
                }, this.m_stEnv = _ctrlLayout.m_stEnv, this.m_xSwipeInfo = {}, this.m_xSwipeEvent, 
                this.m_xAxisX = null, this.m_nAxisX = xUtils.constants.ngc.enum.ELS_NORMAL, this.m_nXWidth = 0;
                var _didDrawBackgrounds = function() {
                    var xEnv = _self.didGetEnvInfo(), canvas = _self.m_domElems.background;
                    if (canvas) {
                        var context = canvas.getContext("2d");
                        canvas.style.backgroundColor = "transparent", context.clearRect(0, 0, 1, canvas.height), 
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        var nFrameCount = _self.m_arrChartDrawFramelist.length;
                        if (nFrameCount > 1) for (var __bgWidth = _self.GetDrawPanelWidth(), ii = 1; ii < nFrameCount; ii++) {
                            var xFrame = _self.m_arrChartDrawFramelist[ii];
                            if (xFrame) try {
                                var bgColor = xFrame.didGetBackgroundColor(!0), rectInfo = xFrame.m_rectInfo, drawRectParam = {
                                    context: context,
                                    rect: {
                                        x: 0,
                                        y: Math.round(rectInfo.y + xEnv.System.SubBackgroundMargin),
                                        width: Math.round(__bgWidth),
                                        height: Math.round(rectInfo.height - 2 * xEnv.System.SubBackgroundMargin)
                                    },
                                    lineWidth: 1,
                                    lineColor: bgColor,
                                    fillColor: bgColor
                                };
                                gxDc.Rectangle(drawRectParam);
                            } catch (e) {
                                console.error(e);
                            }
                        }
                    }
                }, _didAdjustSizeForBackgrounds = function() {
                    var xEnv = _self.didGetEnvInfo(), __bgLeft = xEnv.ExtraPanelWidth, __bgWidth = _self.GetDrawPanelWidth(), __bgHeight = _self.GetFullDrawPanelHeight();
                    if (_self.m_domElems.background) {
                        var devicePixelRatio = window.devicePixelRatio || 1, ratio = devicePixelRatio;
                        _self.m_domElems.background.width = ratio * __bgWidth, _self.m_domElems.background.height = ratio * __bgHeight, 
                        _self.m_domElems.background.style.left = __bgLeft + "px", _self.m_domElems.background.style.width = __bgWidth + "px", 
                        _self.m_domElems.background.style.height = __bgHeight + "px";
                    }
                    _self.m_domElems.backgroundLogo && (_self.m_domElems.backgroundLogo.style.left = __bgLeft + xEnv.System.BackgroundLogo.LeftMargin + "px", 
                    _self.m_domElems.backgroundLogo.style.top = __bgHeight - (xEnv.System.BackgroundLogo.BottomMargin + xEnv.System.BackgroundLogo.Height) + "px");
                }, _didAdjustSizeOfPanels = function() {
                    _self.CheckBlankChartDrawFramelist();
                    for (var iFrameCount = _self.m_arrChartDrawFramelist.length, iChartWrapHeight = _self.GetFullDrawPanelHeight(), iDivFrameHeight = parseInt(iChartWrapHeight / (iFrameCount + 1)), __resizeParam = {
                        left: _self.GetLeftPosOfTheLayout(),
                        top: 0,
                        width: _self.GetDrawPanelWidth(),
                        height: 0,
                        leftY: _self.m_stEnv.System.YAxisLeft,
                        rightY: _self.m_stEnv.System.YAxisRight
                    }, __previousPos = 0, __previousHeight = 0, __ii = 0; __ii < iFrameCount; __ii++) {
                        var __drawPanel = _self.m_arrChartDrawFramelist[__ii];
                        __resizeParam.top = 0 === __ii ? 0 : __previousPos + __previousHeight - 1, __resizeParam.height = __ii === iFrameCount - 1 ? iChartWrapHeight - __resizeParam.top + 1 : 0 === __ii ? 2 * iDivFrameHeight : iDivFrameHeight, 
                        __drawPanel.didResizePanel(__resizeParam), __previousPos = __resizeParam.top, __previousHeight = __resizeParam.height;
                    }
                    var xEnv = _self.didGetEnvInfo();
                    __resizeParam.top = _self.GetFullDrawPanelHeight() - 1, __resizeParam.height = xUtils.didGetXAxisHeight(xEnv) + 1, 
                    _self.m_chartXAxisObj.didResizePanel(__resizeParam), __resizeParam.left = 0, __resizeParam.top = 0, 
                    __resizeParam.height = _self.GetFullDrawPanelHeight() + xUtils.didGetXAxisHeight(xEnv), 
                    __resizeParam.width = xEnv.ExtraPanelWidth, _self.m_xExtraPanel.didResizePanel(__resizeParam), 
                    _didAdjustSizeForBackgrounds(), _self.SetBottomButton(iChartWrapHeight);
                }, _didMovePanelBoundaryPosTo = function(argPosY, panelNo) {
                    if ((!0 === _self.m_bMouseDown || panelNo > 0) && _self.SetMouseCursor("row-resize"), 
                    _self.m_bMouseDown) {
                        _self.m_bMouseRowResize = !0;
                        var __nUpperPanelNo = _self.m_iCanvasMouseDownIndex - 1, __nLowerPanelNo = _self.m_iCanvasMouseDownIndex, __drawPanelUpper = _self.GetDrawPanelAt(__nUpperPanelNo), __drawPanelLower = _self.GetDrawPanelAt(__nLowerPanelNo);
                        if (null === __drawPanelUpper || null === __drawPanelLower) return _self.m_bMouseRowResize = !1, 
                        void _self.SetMouseCursor("default");
                        var __upperRect = __drawPanelUpper.didGetPanelRect(), __lowerRect = __drawPanelLower.didGetPanelRect(), __yPosAtChart = _self.GetPosYMargined(argPosY), __movedOffset = __lowerRect.top - __yPosAtChart, __upperHeight = __upperRect.height - __movedOffset, __lowerHeight = __lowerRect.height + __movedOffset, __limitHeight = xUtils.constants.chartConfigConstants.MinimumPanelSpace;
                        if (__upperHeight < __limitHeight || __lowerHeight < __limitHeight) return;
                        __drawPanelUpper.didResizePanelHeight(__upperHeight + 1);
                        var lowerYPos = __drawPanelUpper.m_rectInfo.y + __drawPanelUpper.m_rectInfo.height;
                        __drawPanelLower.didResizePanelHeight(__lowerHeight - 1, lowerYPos), __drawPanelUpper.DrawFrame(!0), 
                        __drawPanelLower.DrawFrame(!0);
                    }
                }, _didCheckIfSelectedChartObjectIsTrendlineOrNot = function() {
                    var selectedIndex = _self.m_nSelectedChartObjectIndex;
                    if (!(void 0 === selectedIndex || null == selectedIndex || selectedIndex < 0)) return selectedIndex >= xUtils.constants.default.DEFAULT_WRONG_VALUE;
                };
                this.isNontimeChartType = function() {
                    return xUtils.isNontimeChartType(_self.m_stEnv.ChartType);
                }, this.DisableSelection = function(divObj) {
                    void 0 !== divObj.onselectstart && (divObj.onselectstart = function() {
                        return !1;
                    });
                }, this.didCreateDrawPanel = function(argNo, initParam) {
                    var __chartDrawFrame = _drawFrameClass.createPanel(_chartWrapper, _self);
                    return 0 === argNo ? _self.m_xDoBasePrice = __chartDrawFrame.didInitDrawFrame(!0, initParam) : __chartDrawFrame.didInitDrawFrame(!1, initParam), 
                    __chartDrawFrame;
                }, this.didAppendDrawPanel = function(argNo, argBlank, argBasePrice, argTypeName, argChartType) {
                    var __parentObj = _self.m_domElems.panelRoot;
                    _self.DisableSelection(__parentObj);
                    var initParam = {
                        root: _self.m_domElemChartDraw,
                        no: argNo,
                        parent: __parentObj,
                        onMouseDown: _self.OnCanvasMouseDownPosition,
                        onMouseMove: _self.OnCanvasMouseMovePosition,
                        onClose: _self.OnCloseButtonClick,
                        closeImage: _chartWrapper.m_EtcFolder + "Close_H.png",
                        anotherInfo: null,
                        blank: argBlank,
                        basePrice: argBasePrice,
                        priceTypeName: argTypeName
                    }, __chartDrawFrame = _self.didCreateDrawPanel(argNo, initParam, argChartType);
                    return _self.m_arrChartDrawFramelist.push(__chartDrawFrame), __chartDrawFrame;
                }, this.didCreateAxisXPanel = function() {
                    _self.m_chartXAxisObj = new xAxisPanelClass(_chartWrapper, _self, _ctrlLayout), 
                    _self.m_chartXAxisObj.Init();
                }, this.didCreateChartDrawFrame = function(argBasePrice, argTypeName) {
                    _self.m_arrChartDrawFramelist = [], _self.didAppendDrawPanel(0, !1, argBasePrice, argTypeName, _self.m_stEnv.ChartType), 
                    _self.didCreateAxisXPanel(_self.m_stEnv.ChartType), _self.didCreateExtraPanel(), 
                    _self.ResizeChart(!0);
                }, this.didGetShiftInfo = function(bRecalc) {
                    if (!0 === bRecalc) {
                        var __nFrameCount = _self.m_arrChartDrawFramelist.length;
                        _self.m_xShiftInfo.all = 0, _self.m_xShiftInfo.left = 0, _self.m_xShiftInfo.right = 0;
                        for (var __ii = 0; __ii < __nFrameCount; __ii++) {
                            var __xPanel = _self.m_arrChartDrawFramelist[__ii];
                            void 0 !== __xPanel && null != __xPanel && void 0 !== __xPanel.didCalcShiftInfo && function(argPanel, argRef) {
                                var ___tempResult = argPanel.didCalcShiftInfo();
                                argRef.all = Math.max(___tempResult.all, argRef.all), argRef.left = Math.max(___tempResult.left, argRef.left), 
                                argRef.right = Math.max(___tempResult.right, argRef.right);
                            }(__xPanel, _self.m_xShiftInfo);
                        }
                    }
                    return _self.m_xShiftInfo;
                }, this.SetBottomButton = function(iChartWrapHeight) {
                    var domElemBottomTools = _chartWrapper.didFindDomElementById("idChartBottomTools");
                    void 0 !== domElemBottomTools && null != domElemBottomTools && (domElemBottomTools.style.left = _self.GetDrawPanelWidth() / 2 - 90 + "px", 
                    domElemBottomTools.style.top = iChartWrapHeight - 5 + "px");
                }, this.OnCloseButtonClick = function(event) {
                    var iIndex = String(event.currentTarget.id).substring(10, 12);
                    if (!_self.m_arrChartDrawFramelist[iIndex].m_bMainFrame) {
                        var bExistIchiMoku = !1, iExistSpanIndex = -1, idxObj = 0;
                        for (idxObj = 0; idxObj < _self.m_arrChartDrawFramelist[iIndex].m_arrChartObjlist.length; idxObj++) {
                            var idxSpan = 0;
                            if ("IchiMoku" == _self.m_arrChartDrawFramelist[iIndex].m_arrChartObjlist[idxObj].m_strChartName) {
                                for (idxSpan = 0; idxSpan < _self.m_arrIchiMokulist.length; idxSpan++) if (_self.m_arrIchiMokulist[idxSpan] == parseInt(_self.m_arrChartDrawFramelist[iIndex].m_arrChartObjlist[idxObj].m_arrPeriod[3])) {
                                    iExistSpanIndex = idxSpan;
                                    break;
                                }
                                if (iExistSpanIndex > -1) {
                                    for (_self.m_iSpanMax = 0, _self.m_arrIchiMokulist.splice(iExistSpanIndex, 1), idxSpan = 0; idxSpan < _self.m_arrIchiMokulist.length; idxSpan++) _self.m_iSpanMax = Math.max(_self.m_iSpanMax, _self.m_arrIchiMokulist[idxSpan]);
                                    for (var iGap = parseInt(_self.m_arrChartDrawFramelist[iIndex].m_arrChartObjlist[idxObj].m_arrPeriod[3]) - _self.m_iSpanMax, idxDelete = 0; idxDelete < iGap; idxDelete++) _gfJsonData.Modules.deleteBlankData();
                                }
                                bExistIchiMoku = !0;
                                break;
                            }
                        }
                        if (_self.m_arrChartDrawFramelist[iIndex].OnDestroy(), bExistIchiMoku) {
                            for (var idx = 0; idx < _self.m_arrChartDrawFramelist.length; idx++) for (idxObj = 0; idxObj < _self.m_arrChartDrawFramelist[idx].m_arrChartObjlist.length; idxObj++) _self.m_arrChartDrawFramelist[idx].m_arrChartObjlist[idxObj].m_bMainChart || _self.m_arrChartDrawFramelist[idx].m_arrChartObjlist[idxObj].didClearData(1, _self.m_arrChartDrawFramelist[idx].m_arrChartObjlist[idxObj].m_strChartName);
                            _self.ReceiveData();
                        }
                        _self.ResizeChart(!1);
                    }
                }, this.didCalculateAllData = function(bReal) {
                    var __nFrameCount = _self.m_arrChartDrawFramelist.length;
                    if (!0 === bReal) for (var nDSize = _self.GetBaseDataCount(), nStart = _self.m_xScrollInfo.pos, nSSize = _self.m_xScrollInfo.screenSize, __ii = 0; __ii < __nFrameCount; __ii++) !function(argPanel) {
                        void 0 !== argPanel && null != argPanel && void 0 !== argPanel.didCalculateData && argPanel.didCalculateRealData(nStart, nDSize, nSSize);
                    }(_self.m_arrChartDrawFramelist[__ii]); else for (var __ii = 0; __ii < __nFrameCount; __ii++) !function(argPanel) {
                        void 0 !== argPanel && null != argPanel && void 0 !== argPanel.didCalculateData && argPanel.didCalculateData();
                    }(_self.m_arrChartDrawFramelist[__ii]);
                    return !0;
                }, this.didCalculateDataForExtraObject = function() {
                    for (var nFrameCount = _self.m_arrChartDrawFramelist.length, nDSize = _self.GetBaseDataCount(), nStart = _self.m_xScrollInfo.pos, nSSize = _self.m_xScrollInfo.screenSize, __ii = 0; __ii < nFrameCount; __ii++) !function(argPanel) {
                        void 0 !== argPanel && null != argPanel && void 0 !== argPanel.didCalculateDataForExtraObject && argPanel.didCalculateDataForExtraObject(nStart, nDSize, nSSize);
                    }(_self.m_arrChartDrawFramelist[__ii]);
                }, this.ReceiveCompareData = function(strCode) {
                    for (var idx = 0; idx < _self.m_arrChartDrawFramelist.length; idx++) _self.m_arrChartDrawFramelist[idx].m_bMainFrame && _self.m_arrChartDrawFramelist[idx].ReceiveCompareData(strCode);
                }, this.CalcMaxMin = function() {
                    for (var idx = 0; idx < _self.m_arrChartDrawFramelist.length; idx++) _self.m_arrChartDrawFramelist[idx].CalcMaxMin();
                }, this.DrawingChartDrawFrame = function(bResize) {
                    _self.m_domElems.axis.style.backgroundColor = _self.m_stEnv.BackgroundColor, bResize || _self.didCalcMinMax(!1);
                    for (var idx = 0; idx < _self.m_arrChartDrawFramelist.length; idx++) !function(drawPanel) {
                        drawPanel.DrawFrame(bResize);
                    }(_self.m_arrChartDrawFramelist[idx]);
                    _self.m_chartXAxisObj.didDraw(), _self.m_xExtraPanel && _self.m_xExtraPanel.didDraw && _self.m_xExtraPanel.didDraw(), 
                    _didDrawBackgrounds();
                }, this.ResizeChartEx = function(bResize) {
                    if (!0 === _self.didGetEnvInfo().System.UseObjectCrossline && (void 0 === _self.m_ptCrossline.x || null == _self.m_ptCrossline.x || void 0 === _self.m_ptCrossline.y || null == _self.m_ptCrossline.y)) {
                        var iChartWrapWidth = _self.GetDrawPanelWidth(), iChartWrapHeight = _self.GetFullDrawPanelHeight();
                        _self.m_ptCrossline.x = parseInt(iChartWrapWidth / 2), _self.m_ptCrossline.y = parseInt(iChartWrapHeight / 2);
                    }
                    _didAdjustSizeOfPanels(), _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_RESIZE), 
                    _self.didRecalcFactor(), _self.DrawingChartDrawFrame(bResize);
                }, this.ResizeChart = function(bResize) {
                    _self.ResizeChartEx(bResize);
                }, this.didInitElements = function() {
                    _self.m_domElems.layoutRoot = _chartWrapper.didFindDomElementById("idChartArea");
                    var __deParent = _self.m_domElems.layoutRoot, __domElemId = "";
                    return __domElemId = "idChartDrawAPIPanel" + _self.m_strDomElemPostfix, _self.m_domElems.layout = document.createElement("div"), 
                    _self.m_domElems.layout.setAttributeNS(null, "id", __domElemId), _self.m_domElems.layout.className = "classChartLayout", 
                    __domElemId = "idChartDrawArea" + _self.m_strDomElemPostfix, _self.m_domElems.panelRoot = document.createElement("div"), 
                    _self.m_domElems.panelRoot.setAttributeNS(null, "id", __domElemId), _self.m_domElems.panelRoot.className = "classChartDrawArea", 
                    __domElemId = "idChartXArea" + _self.m_strDomElemPostfix, _self.m_domElems.axis = document.createElement("div"), 
                    _self.m_domElems.axis.setAttributeNS(null, "id", __domElemId), _self.m_domElems.axis.className = "classChartXArea", 
                    __domElemId = "idChartExtraPanel", _self.m_domElems.extraPanel = document.createElement("div"), 
                    _self.m_domElems.extraPanel.setAttributeNS(null, "id", __domElemId), _self.m_domElems.extraPanel.className = "classChartExtraPanel", 
                    __domElemId = "idChartDrawAreaBackground" + _self.m_strDomElemPostfix, _self.m_domElems.background = document.createElement("canvas"), 
                    _self.m_domElems.background.setAttributeNS(null, "id", __domElemId), _self.m_domElems.background.className = "classChartDrawAreaBackground", 
                    __domElemId = "idChartDrawAreaBackgroundLogo" + _self.m_strDomElemPostfix, _self.m_domElems.backgroundLogo = document.createElement("div"), 
                    _self.m_domElems.backgroundLogo.setAttributeNS(null, "id", __domElemId), _self.m_domElems.backgroundLogo.className = "classChartDrawAreaBackgroundLogo", 
                    _self.m_domElems.panelRoot.appendChild(_self.m_domElems.background), _self.m_domElems.panelRoot.appendChild(_self.m_domElems.backgroundLogo), 
                    _self.m_domElems.layout.appendChild(_self.m_domElems.panelRoot), _self.m_domElems.layout.appendChild(_self.m_domElems.axis), 
                    __deParent.appendChild(_self.m_domElems.layout), _self.m_domElems.layout;
                }, this.didRemoveLinkElements = function() {
                    void 0 !== _self.m_domElems.layoutRoot && null != _self.m_domElems.layoutRoot && (_self.m_domElems.axis.removeChild(_self.m_domElems.axisCanvas), 
                    _self.m_domElems.axis.removeChild(_self.m_domElems.axisLabel), _self.m_domElems.panelRoot.removeChild(_self.m_domElems.background), 
                    _self.m_domElems.panelRoot.removeChild(_self.m_domElems.backgroundLogo), _self.m_domElems.layout.removeChild(_self.m_domElems.axis), 
                    _self.m_domElems.layout.removeChild(_self.m_domElems.extraPanel), _self.m_domElems.layout.removeChild(_self.m_domElems.panelRoot), 
                    _self.m_domElems.layoutRoot.removeChild(_self.m_domElems.layout));
                };
                var _InitAxisX = function(bDefault, nStyle) {
                    var nAxis = nStyle;
                    return bDefault ? _self.SetAxisStyle(xUtils.constants.ngc.enum.ELS_NORMAL) : _self.SetAxisStyle(nAxis), 
                    xUtils.constants.ngc.define.NGC_SUCCESS;
                };
                this.didInitVariables = function() {
                    var levelInfo = _self.didGetScrollLevelInfo(), barGapInfo = xUtils.axis.didCalcBarGapInfoFromLevelInfo(_self.m_xScrollInfo.barSize, _self.m_xScrollInfo.barGap, levelInfo);
                    barGapInfo && (_self.m_xScrollInfo.barSize = barGapInfo.barSize, _self.m_xScrollInfo.barGap = barGapInfo.barGap);
                    try {
                        var xEnv = _self.didGetEnvInfo();
                        _self.m_strTrendLine = xEnv.System.DefaultTrendline, xUtils.didStateChangeOnTrendline(xEnv, _self.m_strTrendLine);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didInitDrawPanelLayout = function(argBasePrice) {
                    if (_self.didInitVariables(), _self.m_domElemChartDraw = _self.didInitElements(), 
                    1 == _self.didGetEnvInfo().System.UseForMiniChart) try {
                        _self.m_domElems && _self.m_domElems.backgroundLogo && (_self.m_domElems.backgroundLogo.style.display = "none");
                    } catch (e) {
                        console.error(e);
                    }
                    _self.didCreateChartDrawFrame(argBasePrice), _InitAxisX(!0, 0);
                }, this.CheckBlankChartDrawFramelist = function() {
                    var idx = 0;
                    for (idx = _self.m_arrChartDrawFramelist.length - 1; idx >= 0; idx--) {
                        var __drawPanel = _self.m_arrChartDrawFramelist[idx];
                        void 0 !== __drawPanel && null != __drawPanel && !0 === __drawPanel.didCheckEmptyPanel(!0) && _self.m_arrChartDrawFramelist.splice(idx, 1);
                    }
                    for (var __ii in _self.m_arrChartDrawFramelist) {
                        var __drawPanel = _self.m_arrChartDrawFramelist[__ii];
                        void 0 !== __drawPanel && null != __drawPanel && __drawPanel.didResetPanelNo(__ii);
                    }
                }, this.didChangeBasicChartType = function(strBasicChart) {
                    var nAxisID = xUtils.getChartTypeNumCodeFromCode(strBasicChart);
                    _self.SetAxisStyle(nAxisID);
                }, this.didEndChangeForIndicator = function(isAdjustedPanel, extraInfo) {
                    !0 === isAdjustedPanel && _didAdjustSizeOfPanels();
                    var bRecalc = !0;
                    void 0 !== extraInfo && null != extraInfo && (bRecalc = !1, !0 !== extraInfo.param && !0 !== extraInfo.shift || (bRecalc = !0)), 
                    !0 === bRecalc && (_self.didGetShiftInfo(!0), _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_ADD_SERIES), 
                    _self.didRecalcFactor()), _self.DrawingChartDrawFrame(!1);
                }, this.didAddIndicator = function(code, info, isRef) {
                    var __xDos = _self.m_doFactory.createDrawObject(code, !1, info, isRef);
                    if (void 0 === __xDos || null == __xDos) return !1;
                    var __bPriceType = __xDos.m_bPriceType, isAdjustedPanel = !1;
                    if (__bPriceType) {
                        var iMainChartIdx, idx = 0;
                        for (idx = 0; idx < _self.m_arrChartDrawFramelist.length; idx++) if (_self.m_arrChartDrawFramelist[idx].m_bMainFrame) {
                            iMainChartIdx = idx;
                            break;
                        }
                        _self.m_arrChartDrawFramelist[iMainChartIdx].didAddChartObj(__xDos);
                    } else {
                        var __nFrameCount = _self.m_arrChartDrawFramelist.length;
                        __nFrameCount < 0 && (__nFrameCount = 0);
                        var __drawPanel = _self.didAppendDrawPanel(__nFrameCount, !0);
                        void 0 !== __drawPanel && null != __drawPanel && __drawPanel.didAddChartObj(__xDos), 
                        isAdjustedPanel = !0;
                    }
                    return _self.didEndChangeForIndicator(isAdjustedPanel), !0;
                }, this.OnTrendLineAdd = function(strTrendLine) {}, this.didGetScrollInfo = function(isCopy) {
                    if (_self.m_xScrollInfo) return 1 == isCopy ? xUtils.didClone(_self.m_xScrollInfo) : _self.m_xScrollInfo;
                }, this.didGetScrollSize = function() {
                    return _self.m_xScrollInfo.range.length;
                }, this.didGetScrollEndPos = function() {
                    return _self.m_xScrollInfo.range.length - _self.m_xScrollInfo.screenSize;
                }, this.didScrollToEndPos = function(bEndPos, isNotFix, bDraw) {
                    return !0 !== bEndPos ? (!0 !== isNotFix && (_self.m_stEnv.GoToEndPos = !1), !0) : (!0 !== isNotFix && (_self.m_stEnv.GoToEndPos = !0), 
                    _self.didStopSwipeAction(), _self.m_xScrollInfo.pos = _self.didGetScrollEndPos(), 
                    _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_SCROLL), _self.didRecalcFactor(), 
                    _self.DrawingChartDrawFrame(!1), !0);
                };
                var _didScrollTo = function(argPos, bDraw) {
                    var __nScrollCount = _self.didGetScrollSize(), __nNewPos = 0, __xEnv = _self.didGetEnvInfo();
                    return void 0 !== argPos && null != argPos && (__nNewPos = parseInt(argPos)), __xEnv.GoToEndPos = !1, 
                    __nNewPos < 0 ? (__nNewPos = 0, !1) : __nNewPos >= __nScrollCount - _self.m_xScrollInfo.screenSize && (__nNewPos = __nScrollCount - _self.m_xScrollInfo.screenSize, 
                    !1, __xEnv.GoToEndPos = !0), _self.m_xScrollInfo.range.extra = 0, __nNewPos !== _self.m_xScrollInfo.pos && (_self.m_xScrollInfo.pos = __nNewPos, 
                    _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_SCROLL), _self.didRecalcFactor(), 
                    !0 === bDraw && _self.DrawingChartDrawFrame(!1), !0);
                }, _didZoomTo = function(nShows, bDraw) {
                    var xEnv = _self.didGetEnvInfo(), __nCurPos = _self.m_xScrollInfo.pos, __nCurSize = _self.m_xScrollInfo.screenSize;
                    if (nShows == __nCurSize) return !1;
                    if ((__nCurSize = nShows) < xEnv.System.Scroll.screenSize.min) __nCurSize = xEnv.System.Scroll.screenSize.min; else {
                        __nCurSize = _self.didAdjustZoomMax(__nCurSize);
                        var __nTemp = __nCurSize + __nCurPos, __nDiff = __nTemp - _self.m_xScrollInfo.range.length;
                        if (__nDiff > 0) {
                            var __nTempPos = __nCurPos - __nDiff;
                            __nTempPos < 0 && (__nTempPos = 0), __nCurPos = __nTempPos;
                        }
                    }
                    return _self.m_xScrollInfo.pos = __nCurPos, _self.m_xScrollInfo.screenSize = __nCurSize, 
                    _self.m_xScrollInfo.range.length < _self.m_xScrollInfo.screenSize && (_self.m_xScrollInfo.range.length = _self.m_xScrollInfo.screenSize, 
                    _self.m_xScrollInfo.pos = 0), _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_SCROLL), 
                    _self.didRecalcFactor(), !0 === bDraw && _self.DrawingChartDrawFrame(!1), !0;
                };
                this.didScrollScreen = function(nDelta, bDraw, isMouse) {
                    if (0 === nDelta) return !1;
                    var __nScrollCount = _self.didGetScrollSize(), __bChanged = !0, __nNewPos = _self.m_xScrollInfo.pos - nDelta, __xEnv = _self.didGetEnvInfo(), nOverTriggerForRequestingPastCount = 0;
                    return !0 === isMouse && xUtils.isAvailableChartTypeForCallingPreviousNext(__xEnv) && (_self.m_bOverTriggerForRequestingPast = !0, 
                    nOverTriggerForRequestingPastCount = parseInt(.3 * _self.m_xScrollInfo.screenSize), 
                    isNaN(nOverTriggerForRequestingPastCount) && (nOverTriggerForRequestingPastCount = 0)), 
                    __nNewPos < -1 * nOverTriggerForRequestingPastCount ? (__nNewPos = -1 * nOverTriggerForRequestingPastCount, 
                    __bChanged = !1) : __nNewPos > __nScrollCount - _self.m_xScrollInfo.screenSize && (__nNewPos = __nScrollCount - _self.m_xScrollInfo.screenSize, 
                    __bChanged = !1), _self.m_xScrollInfo.pos = __nNewPos, !0 === isMouse && __nNewPos < 0 && (_self.m_xScrollInfo.range.extra = __nNewPos), 
                    _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_SCROLL), _self.didRecalcFactor(), 
                    !0 === bDraw && _self.DrawingChartDrawFrame(!1), __bChanged;
                }, this.didAdjustZoomMax = function(zoomSize) {
                    var xEnv = _self.didGetEnvInfo();
                    try {
                        void 0 !== xEnv.System.Scroll.screenSize.max && null != xEnv.System.Scroll.screenSize.max && zoomSize > xEnv.System.Scroll.screenSize.max && (zoomSize = xEnv.System.Scroll.screenSize.max);
                    } catch (e) {
                        console.error(e);
                    }
                    return zoomSize;
                }, this.didZoomScreen = function(nDelta, bDraw) {
                    var xEnv = _self.didGetEnvInfo();
                    if (!0 === xEnv.System.UseScrollAction) {
                        try {
                            var frameWidth = _self.GetChartFrameAreaWidth(), barSizeLimit = parseInt(frameWidth / 4);
                            _self.m_xAxisX.CalculateScrollInfo(_self.m_xScrollInfo, xEnv, nDelta, barSizeLimit);
                        } catch (e) {
                            console.error(e);
                        }
                        _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_ZOOM), _self.didRecalcFactor(), 
                        !0 === bDraw && _self.DrawingChartDrawFrame(!1);
                    }
                }, this.didToggleGoToEndPos = function(isStop) {
                    try {
                        var xEnv = _self.didGetEnvInfo();
                        if (!0 === isStop) {
                            var nEndPos = _self.didGetScrollEndPos();
                            _self.m_xScrollInfo.pos >= nEndPos && (xEnv.GoToEndPos = !0);
                        } else xEnv.GoToEndPos = !1;
                    } catch (e) {
                        console.error(e);
                    }
                }, this.OnMouseDown = function(posval, argEvent, isAxisArea, actionArea) {
                    var xEnv = _self.didGetEnvInfo();
                    _self.didClearTooltipEventer(), _self.didShowTooltip(!1), _self.m_bOverTriggerForRequestingPast = !1, 
                    _self.didStopSwipeAction(), _self.m_bMouseDown = !0, _self.m_bCrosslineObject = !1, 
                    _self.m_bMouseUpXArea = !1, _self.m_iXPosMouseDown = posval.XPos, _self.m_bMouseDownSelectedChartObj = !1, 
                    _self.m_nSelectedChartObjectIndex = -1;
                    var isDeleteOneRepeat = xUtils.trendLine.isDeleteOneRepeat(_self.m_strTrendLine), isCrossHairMode = xUtils.trendLine.isCrossHairMode(_self.m_strTrendLine), isAvailableToSelectObject = xUtils.isAvailableToSelectObject(xEnv);
                    if (_self.m_bTrendLine && !0 !== isDeleteOneRepeat && !0 !== isCrossHairMode) {
                        var xPanel = _self.m_arrChartDrawFramelist[_self.m_iCanvasMouseDownIndex];
                        if (void 0 !== xPanel && null != xPanel && !0 === xPanel.m_bMainFrame) if (!0 === xUtils.trendLine.isDeleteOneRepeat(_self.m_strTrendLine)) _self.didDeselectAllFrameObjects(); else {
                            var nAllTrendlineCount = _self.didGetCountForAllTrenslines(), bOverLimit = !1, bNewOrderLine = xUtils.trendLine.isNewOrderLine(_self.m_strTrendLine);
                            if (nAllTrendlineCount >= xEnv.System.TrendlineLimits && (bOverLimit = !0), 1 != bNewOrderLine && 1 == bOverLimit) return console.debug("[WGC] Over limit"), 
                            void setTimeout(function() {
                                try {
                                    _ctrlLayout.didNotifyForError(xUtils.error.errorCodes.overLimitForTrendline);
                                } catch (e) {
                                    console.debug(e);
                                }
                            }, 50);
                            var trendLineInfo;
                            try {
                                trendLineInfo = _ctrlLayout.didFindTrendlineInfoAt(_self.m_strTrendLine), trendLineInfo.isAdd = !0;
                            } catch (e) {
                                console.debug(e);
                            }
                            xPanel.CreateTrendlineObj(_self.m_strTrendLine, posval, trendLineInfo), _self.DrawingChartDrawFrame(!1);
                        }
                    } else {
                        if (!0 === isAxisArea) {
                            if (!0 === _self.didProcForMouseDownInAxisArea(posval, argEvent)) return;
                            return !0;
                        }
                        if (!0 === _self.didCheckPosvalInPanel(posval)) {
                            if (actionArea ? _self.UnsetMouseCursor() : 1 == xEnv.CrossLine.hide ? 1 != isDeleteOneRepeat && (_self.UnsetMouseCursor(), 
                            _self.SetMouseCursor("move")) : (_self.UnsetMouseCursor(), _self.SetMouseCursor("move")), 
                            _self.didDeselectAllFrameObjects(), _self.m_bCrosslineObject = _self.isHitCrosslineBox(posval), 
                            !0 === _self.m_bCrosslineObject) ; else if (1 == isDeleteOneRepeat || 1 == isAvailableToSelectObject) {
                                var localDrawFrame = _self.m_arrChartDrawFramelist[_self.m_iCanvasMouseDownIndex];
                                if (void 0 !== localDrawFrame && null != localDrawFrame) {
                                    _self.m_nSelectedChartObjectIndex = localDrawFrame.OnSelectChartObj(posval);
                                    var notifyData;
                                    localDrawFrame.m_selectTrendlineObj && (_self.m_bTrendLine && !0 === isDeleteOneRepeat ? localDrawFrame.didRemoveSelectedLineTool() : notifyData = localDrawFrame.m_selectTrendlineObj.didGetSimpleAttribute()), 
                                    setTimeout(function() {
                                        try {
                                            _ctrlLayout.didNotifyForTrendline(notifyData);
                                        } catch (e) {
                                            console.debug(e);
                                        }
                                    }, 50), localDrawFrame.m_xSelectedOepObject && localDrawFrame.m_xSelectedOepObject.isAvailableToMoveObject && 1 != localDrawFrame.m_xSelectedOepObject.isAvailableToMoveObject() && (localDrawFrame.m_xSelectedOepObject.DeselectAllObject(), 
                                    localDrawFrame.m_xSelectedOepObject = void 0, _self.m_nSelectedChartObjectIndex = -1);
                                }
                            }
                            _self.DrawingChartDrawFrame(!1);
                        }
                    }
                    if (_self.m_nSelectedChartObjectIndex < 0 && _didCheckPanelResizeFlagWithRowPos(_self.m_iRowPos), 
                    !0 === _self.didProcForMouseDownAboutAction(posval, argEvent, actionArea)) return void (_self.m_bMouseDown = !1);
                    _self.didPrepareSwipeAction(posval);
                }, this.OnMouseUp = function(posval, argEvent, isAxisArea) {
                    var mouseDownedPanel = _self.GetDrawPanelAt(_self.m_iCanvasMouseDownIndex), isDeleteOneRepeat = (_self.didGetEnvInfo(), 
                    xUtils.trendLine.isDeleteOneRepeat(_self.m_strTrendLine));
                    if (_self.m_bMouseDown) if (_self.m_bTrendLine || _self.m_bOrderLine) {
                        if (!0 !== isDeleteOneRepeat && void 0 !== mouseDownedPanel && null != mouseDownedPanel) {
                            mouseDownedPanel.SetTrendlineLastPoint(posval);
                            var xDecoResult = mouseDownedPanel.DidEndCreatingObject();
                            if (xDecoResult) {
                                if (void 0 !== xDecoResult.newOrder && null != xDecoResult.newOrder && _self.m_chartWrapper.didReflectCallForNewOrder) {
                                    var xOepData = xDecoResult.newOrder;
                                    xOepData.isNew = !0, xOepData.objectInfo = xDecoResult.newOrder, _self.m_chartWrapper.didReflectCallForNewOrder(xOepData);
                                }
                                !0 === xDecoResult.refresh && _self.DrawingChartDrawFrame(!1);
                            }
                        }
                        void 0 !== _self.m_chartWrapper.m_callbackTrendline && null != _self.m_chartWrapper.m_callbackTrendline && (_self.m_chartWrapper.m_callbackTrendline.call(), 
                        _self.m_bTrendLine = !1);
                    } else if (mouseDownedPanel && mouseDownedPanel.m_xSelectedOepObject) {
                        var oepResult = mouseDownedPanel.m_xSelectedOepObject.didStopEditMode(posval, argEvent);
                        void 0 !== oepResult && null != oepResult && _self.m_chartWrapper.didReflectCallForOepValueIsChanged && _self.m_chartWrapper.didReflectCallForOepValueIsChanged(oepResult), 
                        _self.DrawingChartDrawFrame(!1);
                    } else _self.m_xScrollInfo.pos < 0 && (_didScrollTo(0, !0), _self.m_chartWrapper.didReflectCallForRequestNextData && _self.m_chartWrapper.didReflectCallForRequestNextData());
                    var cursor = "default";
                    if (!0 === isAxisArea) {
                        var check = _self.didCheckOepPosInAxisArea(posval);
                        check && check.cursor && (cursor = check.cursor);
                    }
                    _self.SetMouseCursor(cursor), _self.m_iRowPos = null, _self.m_bMouseDown = !1, _self.m_bMouseRowResize = !1, 
                    _self.m_bMouseDownSelectedChartObj = !1, _self.m_bOrderLine = !1, _self.m_nSelectedChartObjectIndex = -1, 
                    _self.m_bOverTriggerForRequestingPast = !1, !0 !== _self.didTriggerSwipeAction(posval) && _self.didToggleGoToEndPos(!0), 
                    _self.m_bCrosslineObject = !1, _self.didProcForCursorForTrendline ? _self.didProcForCursorForTrendline(_self.m_strTrendLine, cursor) : _self.UnsetMouseCursor();
                };
                var _didCheckInRowGapSize = function(argGap) {
                    return void 0 !== argGap && null != argGap && (argGap >= 0 && argGap < 10);
                }, _didCheckPanelResizeFlagWithRowPos = function(argRowPos) {
                    _self.m_bMouseRowResize = void 0 !== argRowPos && null != argRowPos;
                };
                this.OnMouseMove = function(posval, isAxisArea, actionArea) {
                    var xEnv = _self.didGetEnvInfo(), bAllowScroll = _self.didProcForCrosslineOnMouseMove(posval), divObjMove = (_chartWrapper.didFindDomElementById("idChartDraw" + (_self.m_iCanvasMouseDownIndex - 1)), 
                    _chartWrapper.didFindDomElementById("idChartDraw" + _self.m_iCanvasMouseDownIndex), 
                    _chartWrapper.didFindDomElementById("idChartDraw" + _self.m_iCanvasMouseMoveIndex)), xEnv = _self.didGetEnvInfo();
                    if (null === divObjMove || void 0 === divObjMove) return _self.m_bMouseRowResize = !1, 
                    void _self.UnsetMouseCursor();
                    var iRowResizeGap = _self.GetPosYMargined(posval.YPos) - divObjMove.offsetTop;
                    !0 === _didCheckInRowGapSize(iRowResizeGap) ? _self.m_iRowPos = iRowResizeGap : _self.m_iRowPos = null;
                    var isDeleteOneRepeat = xUtils.trendLine.isDeleteOneRepeat(_self.m_strTrendLine), isCrossHairMode = xUtils.trendLine.isCrossHairMode(_self.m_strTrendLine);
                    if (_self.m_bMouseDown && (_self.m_bTrendLine || _self.m_bOrderLine) && 1 != isCrossHairMode) !0 !== isDeleteOneRepeat && (_self.m_arrChartDrawFramelist[_self.m_iCanvasMouseDownIndex].SetTrendlineLastPoint(posval), 
                    _self.DrawingChartDrawFrame(!1)); else if (_self.m_bMouseDown && !_self.m_bMouseRowResize) {
                        if (_self.m_nSelectedChartObjectIndex === xUtils.constants.default.DEFAULT_WRONG_VALUE) {
                            var localDrawFrame = _self.m_arrChartDrawFramelist[_self.m_iCanvasMouseDownIndex];
                            try {
                                !0 === localDrawFrame.SetTrendlineMove(posval) && _self.SetMouseCursor("move", !0), 
                                _self.DrawingChartDrawFrame(!1);
                            } catch (e) {
                                console.error(e);
                            }
                            return;
                        }
                        if (!0 !== xEnv.System.UseScrollAction) return;
                        if (!0 !== bAllowScroll) return;
                        _self.UnsetMouseCursor(), _self.SetMouseCursor("move");
                        var __currentIdx = _self.didConvertHorizontalPosToDataIndex(posval.XPos, !1), __previousIdx = _self.didConvertHorizontalPosToDataIndex(_self.m_iXPosMouseDown, !1), iIndexGap = __currentIdx - __previousIdx;
                        0 !== iIndexGap && (_self.didToggleGoToEndPos(!1), _self.didScrollScreen(iIndexGap, !1, !0), 
                        _self.DrawingChartDrawFrame(!1), Math.abs(iIndexGap) > 0 && (_self.m_iXPosMouseDown = posval.XPos));
                    } else if (!0 !== _didCheckInRowGapSize(iRowResizeGap) && !_self.m_bMouseRowResize || !0 === _didCheckIfSelectedChartObjectIsTrendlineOrNot()) {
                        var cursor = "default";
                        if (!0 === isAxisArea) {
                            var check = _self.didCheckOepPosInAxisArea(posval);
                            check && check.cursor && (cursor = check.cursor);
                        }
                        _self.m_bMouseRowResize = !1, 1 != isAxisArea && _self.didProcForCursorForTrendline ? _self.didProcForCursorForTrendline(_self.m_strTrendLine, cursor) : _self.SetMouseCursor(cursor), 
                        _self.m_iXPosIndex = _self.didConvertHorizontalPosToDataIndex(posval.XPos, !1), 
                        _self.didProcForTooltip(posval, actionArea), _self.didProcForMouseHoverOnObject && _self.didProcForMouseHoverOnObject(posval, actionArea);
                    } else _didMovePanelBoundaryPosTo(posval.YPos, _self.m_iCanvasMouseMoveIndex);
                }, this.OnSwipe = function(event) {
                    var xEnv = _self.didGetEnvInfo();
                    if (!0 === xUtils.isAvailableSmoothScroll(xEnv) && void 0 !== event && null != event && !0 !== _self.m_xSwipeInfo.isSwipe) {
                        var swipestart = event.swipestart, swipestop = event.swipestop, distance = {
                            x: swipestop.coords[0] - swipestart.coords[0],
                            y: swipestop.coords[1] - swipestart.coords[1]
                        }, elapsedTime = swipestop.time - swipestart.time, velocity = {
                            x: distance.x / elapsedTime,
                            y: distance.y / elapsedTime
                        };
                        _self.m_xSwipeInfo.isSwipe = !0, _self.didSwipeScroll(velocity.x);
                    }
                }, this.didSwipeScroll = function(velocity) {
                    !function() {
                        var distanceFactor, localDistanceFactor = (_self.didGetBasePriceFrame(), _self.didGetDistanceFactor());
                        0 !== localDistanceFactor && (distanceFactor = localDistanceFactor) < .1 && (distanceFactor = .1);
                        var bezierCurveInfo = xUtils.smoothScroll.didGetBezierCurveInfo(velocity, distanceFactor), nLoop = bezierCurveInfo.datas.length, nIndex = 0, funcInterval = function() {
                            var splineInfo = bezierCurveInfo.datas[nIndex];
                            if (void 0 === splineInfo) return void _self.didStopSwipeAction();
                            var delta = Math.round(splineInfo.distance);
                            if (Math.abs(delta) < 1) {
                                if (!(bezierCurveInfo.overLimit > 0)) return void _self.didStopSwipeAction();
                                delta = 1 * bezierCurveInfo.direction, bezierCurveInfo.overLimit--;
                            }
                            if (!0 !== _self.didScrollScreen(delta, !0)) return void _self.didStopSwipeAction();
                            if (++nIndex >= nLoop) {
                                if (!(bezierCurveInfo.overLimit > 0)) return void _self.didStopSwipeAction();
                                nIndex = nLoop - 1, bezierCurveInfo.overLimit--;
                            }
                        };
                        _self.m_xSwipeInfo.intervalId = setInterval(funcInterval, bezierCurveInfo.timerMs);
                    }();
                }, this.didPrepareSwipeAction = function(posval) {
                    var xEnv = _self.didGetEnvInfo();
                    if (!0 === xEnv.System.UseScrollAction && !0 !== _self.m_bTrendLine && xUtils.isAvailableSmoothScroll(xEnv)) {
                        var checkScroll = _self.didCheckScrollAvailable();
                        if (checkScroll && !0 === checkScroll.scroll) {
                            !0 !== _didCheckIfSelectedChartObjectIsTrendlineOrNot() && !0 !== _self.m_bCrosslineObject && (_self.m_xSwipeInfo.Event = xUtils.mobileGesture.swipeStart(posval), 
                            _self.m_xSwipeInfo.isSwipe = !1);
                        }
                    }
                }, this.didTriggerSwipeAction = function(posval) {
                    if (_self.m_xSwipeInfo.Event = xUtils.mobileGesture.swipeEnd(_self.m_xSwipeInfo.Event, posval), 
                    _self.m_xSwipeInfo.Event && _self.m_xSwipeInfo.Event.type) {
                        var swipeEvent = xUtils.didClone(_self.m_xSwipeInfo.Event);
                        return _self.m_xSwipeInfo.Event = void 0, _self.OnSwipe(swipeEvent), !0;
                    }
                    return !1;
                }, this.didStopSwipeAction = function() {
                    _self.m_xSwipeInfo.isSwipe = !1, _self.m_xSwipeInfo.Event = void 0, void 0 !== _self.m_xSwipeInfo.intervalId && (clearInterval(_self.m_xSwipeInfo.intervalId), 
                    _self.m_xSwipeInfo.intervalId = void 0), _self.didToggleGoToEndPos(!0);
                }, this.didGetObjectInfo = function(objectName, isSelected) {}, this.didProcessForDeleteKeyEvent = function(keyValue) {}, 
                this.SetCrossLinePoint = function(posval) {
                    var __rectFullChart = _self.GetFullDrawPanelRect(!0), __posXLeft = (_self.GetChartFrameAreaRect(!0), 
                    __rectFullChart.x), __posXRight = __rectFullChart.x + __rectFullChart.width, __posYTop = __rectFullChart.y, __posYBottom = __rectFullChart.y + __rectFullChart.height;
                    __posXLeft < posval.XPos && __posXRight > posval.XPos && __posYTop < posval.YPos && __posYBottom > posval.YPos ? (_self.m_ptCrossline.x = _self.didCalcAdjustedRelativePositionFromAbsolutePosition(posval.XPos), 
                    _self.m_ptCrossline.y = _self.GetRelativePostionY(posval.YPos)) : (_self.m_ptCrossline.x = -1, 
                    _self.m_ptCrossline.y = -1);
                    for (var __posval = {
                        XPos: _self.m_ptCrossline.x,
                        YPos: _self.m_ptCrossline.y
                    }, idx = 0; idx < _self.m_arrChartDrawFramelist.length; idx++) {
                        var panel = _self.m_arrChartDrawFramelist[idx];
                        void 0 !== panel && null != panel && panel.SetCrossLine(xUtils.didClone(__posval));
                    }
                    _self.DrawingChartDrawFrame(!1), _self.m_chartXAxisObj.SetCrossLine(xUtils.didClone(__posval)), 
                    _self.m_chartXAxisObj.didDraw();
                }, this.didCalcAdjustedRelativePositionFromAbsolutePosition = function(argAbsolutePostionX) {
                    return _self.m_chartXAxisObj.SetXPosition(argAbsolutePostionX);
                }, this.didGetCrosslinePoint = function() {
                    return xUtils.didClone(_self.m_ptCrossline);
                }, this.OnDragOver = function(posval) {}, this.OnMouseWheel = function(posval) {
                    if (!0 === _self.m_xSwipeInfo.isSwipe) return !0;
                    _self.didZoomScreen(posval.Delta, !0);
                }, this.OnKeyDown = function(keyValue, combineKey) {
                    if (void 0 !== combineKey && null != combineKey) {
                        if (keyValue === xUtils.constants.keyEvent.RETURN) {
                            if (!0 === xUtils.debug.modeOn) {
                                var xObjInfo = _self.didGetObjectInfo("", !0);
                                xObjInfo && xObjInfo.indicator && xObjInfo.indicator.didPrintDebugData && xObjInfo.indicator.didPrintDebugData();
                            }
                            return;
                        }
                        if (keyValue === xUtils.constants.keyEvent.SPACE) {
                            if (!0 === xUtils.debug.modeOn) {
                                var xObjInfo = _self.didGetObjectInfo("", !0);
                                if (xObjInfo.indicator) {
                                    xUtils.indicator.didConvertToShortSeriesInformation(xObjInfo.indicator.m_xSeriesInfo);
                                }
                            }
                            return;
                        }
                    }
                    keyValue === xUtils.constants.keyEvent.DELETE && _self.didProcessForDeleteKeyEvent(keyValue);
                }, this.OnCanvasMouseDownPosition = function(event) {
                    var iIndex = String(event.currentTarget.id).substring(8, 10);
                    _self.m_iCanvasMouseDownIndex = iIndex;
                }, this.OnCanvasMouseMovePosition = function(event) {
                    var iIndex = String(event.currentTarget.id).substring(8, 10);
                    _self.m_iCanvasMouseMoveIndex = iIndex;
                }, this.OnCanvasMouseUpPosition = function(event) {
                    _self.m_bMouseUpXArea = !0;
                }, this.UnsetMouseCursor = function() {
                    _self.SetMouseCursor(""), _self.SetMouseCursor("", !0);
                }, this.SetMouseCursor = function(cursor, toMain) {
                    var divObj = _chartWrapper.didFindDomElementById("idChartArea");
                    if (toMain) {
                        var domElemTarget = _chartWrapper.didFindDomElementById("idCanvas0");
                        domElemTarget && (divObj = domElemTarget);
                    }
                    var xEnv = _self.didGetEnvInfo();
                    if (xEnv.System.CursorConfig && cursor) try {
                        var temp = xEnv.System.CursorConfig[cursor];
                        void 0 !== temp && null != temp && (cursor = temp);
                    } catch (e) {
                        console.error(e);
                    }
                    divObj.style.cursor = cursor;
                }, this.didGetPriceDatas = function() {
                    return _self.m_xDoBasePrice.didGetPriceDatas();
                }, this.didGetReferencedPriceObject = function() {
                    return _self.m_xDoBasePrice;
                }, this.didGetReferencedPriceDatas = function(id) {
                    return _self.m_xDoBasePrice.didGetPriceDatas(id);
                }, this.didGetTimeDatas = function(id) {
                    return _self.m_xDoBasePrice.didGetTimeDatas(id);
                }, this.didGetTickNos = function() {
                    return _self.m_xDoBasePrice.didGetTickNos();
                }, this.hasTimeDatas = function() {
                    var __datas = _self.m_xDoBasePrice.didGetTimeDatas();
                    return !(void 0 === __datas || null == __datas || void 0 === __datas.length || null == __datas.length || __datas.length < 1);
                }, this.GetDataCount = function() {
                    var __nDataCount = 0, __xDatas = _self.didGetPriceDatas();
                    return void 0 !== __xDatas && null != __xDatas && (__nDataCount = __xDatas.length), 
                    __nDataCount;
                }, this.didGetFullRange = function() {
                    return {
                        position: 0,
                        length: _self.GetDataCount() + parseInt(_self.m_stEnv.MarginRight) + _self.m_xShiftInfo.all
                    };
                }, this.didCalcReferencedPriceVolumeAtRange = function(argRange) {
                    return _self.m_xDoBasePrice.didCalcVolumeAtRange(argRange);
                }, this.GetBaseDataCount = function() {
                    var __nDataCount = 0, __xDatas = _self.didGetReferencedPriceDatas();
                    return void 0 !== __xDatas && null != __xDatas && (__nDataCount = __xDatas.length), 
                    __nDataCount;
                }, this.GetBaseDatas = function(to, count) {
                    var __nDataCount = 0, __xDatas = _self.didGetReferencedPriceDatas();
                    void 0 !== __xDatas && null != __xDatas && (__nDataCount = __xDatas.length);
                    var __result = [];
                    if (to < count - 1 || __nDataCount < count) return null;
                    for (var __ii = count - 1; __ii >= 0; __ii--) {
                        var __stPrice = __xDatas[to - __ii];
                        __result.push(__stPrice);
                    }
                    return __result;
                }, this.GetBaseDataAtPos = function(argXPos, bAdjusted) {
                    var __dataIndex = _self.didConvertHorizontalPosToDataIndex(argXPos, bAdjusted);
                    return _self.GetBaseDataAt(__dataIndex, !1);
                }, this.GetBaseDataAt = function(at, bScreen) {
                    var __nDataCount = 0, __xDatas = _self.didGetReferencedPriceDatas();
                    void 0 !== __xDatas && null != __xDatas && (__nDataCount = __xDatas.length);
                    var __dataIndex = !0 === bScreen ? _self.didConvertLocalIndexToDataIndex(at) : at;
                    return __nDataCount < 1 || __dataIndex < 0 || __dataIndex >= __nDataCount ? null : __xDatas[__dataIndex];
                }, this.didGetTimedataAtPos = function(argXPos, bAdjusted, ignoreLimit) {
                    var __dataIndex = _self.didConvertHorizontalPosToDataIndex(argXPos, bAdjusted);
                    return _self.didGetTimedataAt(__dataIndex, !1, ignoreLimit);
                }, this.didGetTimeIndexByTimeString = function(argTimedata) {
                    var __nDataCount = 0, __xDatas = _self.didGetTimeDatas();
                    if (void 0 !== __xDatas && null != __xDatas && (__nDataCount = __xDatas.length), 
                    !(__nDataCount < 1)) {
                        var __timeType = xUtils.dateTime.timeType[_self.m_xDoBasePrice.m_symbolInfo.nTType], __timeInterval = _self.m_xDoBasePrice.m_symbolInfo.nTGap;
                        __timeInterval = void 0 === __timeInterval || null == __timeInterval ? 1 : Math.max(1, __timeInterval);
                        var __xData1 = __xDatas[0], __xData2 = __xDatas[__nDataCount - 1], __timeData1 = xUtils.dateTime.convertStringToDate(argTimedata);
                        if (__xData1 > argTimedata) {
                            var __timeData2 = xUtils.dateTime.convertStringToDate(__xData1), __diff = parseInt(xUtils.dateTime.dateDiff(__timeData1, __timeData2, __timeType) / __timeInterval);
                            return 0 - __diff;
                        }
                        if (__xData2 < argTimedata) {
                            var __timeData2 = xUtils.dateTime.convertStringToDate(__xData2), __diff = parseInt(xUtils.dateTime.dateDiff(__timeData1, __timeData2, __timeType) / __timeInterval);
                            return __nDataCount - 1 - __diff;
                        }
                        return _self.didFindTimeIndexBy(argTimedata);
                    }
                }, this.didGetTimedataAt = function(at, bScreen, ignoreLimit) {
                    var __nDataCount = 0, __xTimes = _self.didGetTimeDatas(), __xTnos = _self.didGetTickNos();
                    void 0 !== __xTimes && null != __xTimes && (__nDataCount = __xTimes.length);
                    var __dataIndex = !0 === bScreen ? _self.didConvertLocalIndexToDataIndex(at) : at;
                    if (!0 === ignoreLimit) {
                        if (__nDataCount < 1) return null;
                        var __nTType = _self.m_xDoBasePrice.m_symbolInfo.nTType, __nTGap = _self.m_xDoBasePrice.m_symbolInfo.nTGap, __result = {
                            dateTime: void 0,
                            tickNo: 0
                        };
                        if (__dataIndex < 0) {
                            var __nOffset = __dataIndex, __xData = __xTimes[0], __dateData = xUtils.dateTime.convertStringToDate(__xData), __timeType = xUtils.dateTime.timeType[__nTType], __calcDate = xUtils.dateTime.addDate(__dateData, __nOffset * __nTGap, __timeType);
                            __result.dateTime = xUtils.dateTime.formatDate(__calcDate, xUtils.dateTime.dateTimeFormat1);
                        } else if (__dataIndex >= __nDataCount) {
                            var __nOffset = __dataIndex - (__nDataCount - 1), __xData = __xTimes[__nDataCount - 1], __dateData = xUtils.dateTime.convertStringToDate(__xData), __timeType = xUtils.dateTime.timeType[__nTType], __calcDate = xUtils.dateTime.addDate(__dateData, __nOffset * __nTGap, __timeType);
                            __result.dateTime = xUtils.dateTime.formatDate(__calcDate, xUtils.dateTime.dateTimeFormat1);
                        } else {
                            __result.dateTime = __xTimes[__dataIndex];
                            try {
                                var tno = __xTnos[__dataIndex];
                                isNaN(tno) && (tno = 0), __result.tickNo = tno;
                            } catch (e) {}
                        }
                        return __result;
                    }
                    if (__nDataCount < 1 || __dataIndex < 0 || __dataIndex >= __nDataCount) return null;
                    var __result = {
                        dateTime: __xTimes[__dataIndex],
                        tickNo: 0
                    };
                    try {
                        var tno = __xTnos[__dataIndex];
                        isNaN(tno) && (tno = 0), __result.tickNo = tno;
                    } catch (e) {}
                    return __result;
                }, this.didFindTimeIndexBy = function(timeData) {
                    var __nDataCount = 0, __xDatas = _self.didGetTimeDatas();
                    if (void 0 !== __xDatas && null != __xDatas && (__nDataCount = __xDatas.length), 
                    !(__nDataCount < 1)) {
                        var currentElement, searchElement = timeData, currentIndex = 0, offset = 0;
                        for (currentIndex = 0; currentIndex < __nDataCount; currentIndex++) if (!((currentElement = __xDatas[currentIndex]) < searchElement)) {
                            if (currentElement == searchElement) break;
                            offset = -1;
                            break;
                        }
                        return currentIndex = Math.max(0, currentIndex + offset);
                    }
                }, this.IsOuterIndex = function(index) {
                    var iTotCount = _self.GetDataCount();
                    return iTotCount < 1 || index < 0 || index >= iTotCount;
                }, this.IsOuterIndexes = function(indexes) {
                    var iTotCount = _self.GetDataCount();
                    if (iTotCount < 1) return !0;
                    for (var __ii in indexes) {
                        var nDataIdx = indexes[__ii];
                        if (nDataIdx < 0 || nDataIdx >= iTotCount) return !0;
                    }
                    return !1;
                }, this.GetXAxisPanelElementInfo = function() {
                    var xEnv = _self.didGetEnvInfo(), result = {}, domElem = _self.m_domElems.axis, domElemCanvas = null;
                    domElem.style.position = "absolute", domElem.style.backgroundColor = _self.m_stEnv.BackgroundColor, 
                    domElem.style.left = xUtils.constants.default.LEFTMARGINAREA + "px", domElem.style.top = _self.GetFullDrawPanelHeight(), 
                    domElem.style.width = _self.GetDrawPanelWidth() + "px", domElem.style.height = xUtils.didGetXAxisHeight(xEnv) + "px", 
                    domElem.style.visibility = xUtils.didGetAxisPanelVisibility(xEnv), domElemCanvas = document.createElement("canvas"), 
                    domElemCanvas.setAttributeNS(null, "id", "idCanvasX"), domElemCanvas.style.position = "absolute", 
                    domElemCanvas.style.backgroundColor = _self.m_stEnv.BackgroundColor, domElemCanvas.style.left = "0px", 
                    domElemCanvas.onmouseup = _self.OnCanvasMouseUpPosition, domElem.appendChild(domElemCanvas), 
                    _self.m_domElems.axisCanvas = domElemCanvas;
                    var __domElemCrosslineX = document.createElement("div");
                    return domElem.appendChild(__domElemCrosslineX), _self.m_domElems.axisLabel = __domElemCrosslineX, 
                    result.panel = domElem, result.canvas = domElemCanvas, result.label = __domElemCrosslineX, 
                    result;
                }, this.GetRelativePostionX = function(argAbsolutePostionX, noExtra) {
                    return argAbsolutePostionX - _self.GetLeftPosOfTheLayout(noExtra);
                }, this.GetRelativePostionY = function(argAbsolutePostionY) {
                    return argAbsolutePostionY - xUtils.constants.default.TOP_HEIGHT;
                }, this.GetPosXMargined = function(argVal, noExtra) {
                    return _self.GetRelativePostionX(argVal, noExtra);
                }, this.GetPosYMargined = function(argVal) {
                    return _self.GetRelativePostionY(argVal);
                }, this.GetYAxisAreaWidth = function() {
                    return _self.m_stEnv.System.YAxisLeft + _self.m_stEnv.System.YAxisRight;
                }, this.GetDrawPanelWidth = function() {
                    return _chartWrapper.m_iChartWrapWidth - _self.GetNonChartAreaWidth();
                }, this.GetHorizontalRangeOfAllPanelsInFullArea = function() {
                    var __result = {
                        left: {
                            pos: 0,
                            width: 0
                        },
                        center: {
                            pos: 0,
                            width: 0
                        },
                        right: {
                            pos: 0,
                            width: 0
                        }
                    };
                    return __result.left.pos = 0, __result.left.width = _self.m_stEnv.System.YAxisLeft, 
                    __result.center.pos = __result.left.pos + __result.left.width, __result.center.width = _self.GetChartFrameAreaWidth(), 
                    __result.right.pos = __result.center.pos + __result.center.width, __result.right.width = _self.m_stEnv.System.YAxisRight, 
                    __result;
                }, this.GetFullDrawPanelHeight = function() {
                    var xEnv = _self.didGetEnvInfo();
                    return _chartWrapper.m_iChartWrapHeight - (xUtils.constants.default.TOP_HEIGHT + xUtils.didGetXAxisHeight(xEnv) + xUtils.constants.default.BOTTOMMARGINAREA);
                }, this.GetFullDrawPanelRect = function(exceptOnlyXAxis) {
                    return {
                        x: _self.m_stEnv.System.YAxisLeft,
                        y: xUtils.constants.default.TOP_HEIGHT,
                        width: !0 === exceptOnlyXAxis ? _self.GetDrawPanelWidth() : _self.GetChartFrameAreaWidth(),
                        height: _self.GetFullDrawPanelHeight()
                    };
                }, this.GetNonChartAreaWidth = function() {
                    return xUtils.constants.default.RIGHTMARGINAREA + xUtils.constants.default.LEFTMARGINAREA + _self.GetExtraPanelWidth();
                }, this.GetLeftPosOfTheLayout = function(noExtra) {
                    var xEnv = _self.didGetEnvInfo(), nLeftLayoutPos = xUtils.constants.default.LEFTMARGINAREA + xEnv.System.YAxisLeft;
                    return !0 !== noExtra && (nLeftLayoutPos += _self.GetExtraPanelWidth()), nLeftLayoutPos;
                }, this.GetExtraPanelWidth = function() {
                    return _self.didGetEnvInfo().ExtraPanelWidth || 0;
                }, this.GetChartFrameAreaWidth = function() {
                    return _chartWrapper.m_iChartWrapWidth - (_self.GetNonChartAreaWidth() + _self.GetYAxisAreaWidth());
                }, this.GetChartFrameAreaRect = function(entire) {
                    var xEnv = _self.didGetEnvInfo(), __rect = {
                        x: 0,
                        y: 0,
                        width: _self.GetChartFrameAreaWidth(),
                        height: _self.GetFullDrawPanelHeight()
                    };
                    return !0 === entire && (__rect.height = _chartWrapper.m_iChartWrapHeight + xUtils.didGetXAxisHeight(xEnv)), 
                    __rect;
                }, this.GetChartFrameAreaInfo = function() {
                    return {
                        leftAxis: _self.m_stEnv.System.YAxisLeft,
                        rightAxis: _self.m_stEnv.System.YAxisRight,
                        chart: {
                            left: _self.m_stEnv.System.YAxisLeft,
                            width: _self.GetChartFrameAreaWidth()
                        }
                    };
                }, this.GetCurrentSymbolPointValue = function() {
                    var __symbolInfo = _self.m_xDoBasePrice.m_symbolInfo;
                    return void 0 === __symbolInfo || null === __symbolInfo ? 3 : void 0 === __symbolInfo.verpos || null === __symbolInfo.verpos ? 3 : __symbolInfo.verpos;
                }, this.GetDrawPanelAt = function(argNo) {
                    var __nFrameCount = _self.m_arrChartDrawFramelist.length;
                    return __nFrameCount < 1 || argNo < 0 || argNo >= __nFrameCount ? null : _self.m_arrChartDrawFramelist[argNo];
                }, this.didCheckPosvalInPanel = function(posval) {
                    if (void 0 === posval || null == posval) return !1;
                    var rectPanel = _self.GetFullDrawPanelRect();
                    return !0 === xUtils.shapes.posvalInRect(posval, rectPanel);
                }, this.didClearFactors = function(nextCount) {
                    var xEnv = _self.didGetEnvInfo();
                    _self.m_xScrollInfo.pos = 0, _self.m_xScrollInfo.range.location = 0, _self.m_xScrollInfo.range.length = 0, 
                    void 0 !== nextCount && null != nextCount || !0 !== xEnv.System.ResetScaleFactor || (_self.m_xScrollInfo.screenSize = xEnv.System.Scroll.zoom, 
                    _self.m_xScrollInfo.barSize = xEnv.System.Scroll.barSize, _self.m_xScrollInfo.barGap = xEnv.System.Scroll.barGap, 
                    _self.m_xScrollInfo.levelList = xEnv.System.Scroll.LevelList, _self.m_xScrollInfo.level = xEnv.System.Scroll.Level ? xEnv.System.Scroll.Level : 0), 
                    _self.m_xShiftInfo.all = 0, _self.m_xShiftInfo.left = 0, _self.m_xShiftInfo.right = 0, 
                    _self.m_iSpanMax = 0, _self.m_iStartX = 0, _self.m_iEndX = 0, _self.m_iXPosIndex = 0, 
                    _self.m_bMouseDown = !1, _self.m_bMouseRowResize = !1, _self.m_bMouseUpXArea = !1, 
                    _self.m_iXPosMouseDown = 0, _self.m_bMouseDownSelectedChartObj = !1, _self.m_nSelectedChartObjectIndex = -1, 
                    _self.m_SelectFrame = null, _self.m_iRowPos = null, _self.m_iCanvasMouseDownIndex = 0, 
                    _self.m_iCanvasMouseMoveIndex = 0;
                }, this.didClearIndicatorDatas = function() {
                    for (var __nFrameCount = _self.m_arrChartDrawFramelist.length, __ii = 0; __ii < __nFrameCount; __ii++) !function(argObj) {
                        void 0 !== argObj && null != argObj && argObj.didClearIndicatorDatas();
                    }(_self.m_arrChartDrawFramelist[__ii]);
                }, this.didClearDatas = function() {
                    _self.m_xDoBasePrice.didClearDatas(), _self.didClearIndicatorDatas(), _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_UPDATE_IQ), 
                    _self.didRecalcFactor(), _self.DrawingChartDrawFrame(!1);
                }, this.didRemoveAllLineTools = function(bFlag) {
                    if (!1 !== bFlag) for (var __nFrameCount = _self.m_arrChartDrawFramelist.length, __ii = 0; __ii < __nFrameCount; __ii++) !function(argObj) {
                        void 0 !== argObj && null != argObj && argObj.didRemoveAllLineTools();
                    }(_self.m_arrChartDrawFramelist[__ii]);
                }, this.willBeReceivedAlertExecutionData = function(isAlertOrExecution, receivedDatas) {
                    if (void 0 !== _self.m_xDoBasePrice.willBeReceivedAlertExecutionData && null != _self.m_xDoBasePrice.willBeReceivedAlertExecutionData) return _self.m_xDoBasePrice.willBeReceivedAlertExecutionData(isAlertOrExecution, receivedDatas);
                }, this.didReceiveAlertExecutionData = function(isAlertOrExecution, receivedDatas) {
                    if (void 0 !== _self.m_xDoBasePrice.didReceiveAlertExecutionData && null != _self.m_xDoBasePrice.didReceiveAlertExecutionData) return _self.m_xDoBasePrice.didReceiveAlertExecutionData(isAlertOrExecution, receivedDatas);
                }, this.willBeReceivedOrderPositData = function(isOrderOrPosit, receivedDatas) {
                    if (void 0 !== _self.m_xDoBasePrice.willBeReceivedOrderPositData && null != _self.m_xDoBasePrice.willBeReceivedOrderPositData) return _self.m_xDoBasePrice.willBeReceivedOrderPositData(isOrderOrPosit, receivedDatas);
                }, this.didReceiveOrderPositData = function(isOrderOrPosit, receivedDatas) {
                    if (void 0 !== _self.m_xDoBasePrice.didReceiveOrderPositData && null != _self.m_xDoBasePrice.didReceiveOrderPositData) return _self.m_xDoBasePrice.didReceiveOrderPositData(isOrderOrPosit, receivedDatas);
                }, this.willBeReceivedData = function(symbolInfo, receivedDatas, nextCount, multiTargetId) {
                    !0 === _self.m_xDoBasePrice.willBeReceivedData(symbolInfo, receivedDatas, multiTargetId) && (!function() {
                        _self.m_xDoBasePrice.didClearDatas();
                    }(), void 0 !== nextCount && null != nextCount || (_self.didRemoveAllLineTools(), 
                    _self.didClearOrderPositObjects(!0, !0), _self.didClearAllSubRequestedObjects(!1, !1, !0, !0)), 
                    _self.didClearFactors(nextCount));
                }, this.didReceiveData = function(symbolInfo, receivedDatas, nextCount, multiTargetId) {
                    !function() {
                        _self.m_xDoBasePrice.didReceiveData(symbolInfo, receivedDatas, multiTargetId);
                    }(), _self.didCalculateAllData(), _self.didGetShiftInfo(!0), _self.didGetEnvInfo().GoToEndPos = !0, 
                    _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_UPDATE_IQ), _self.didRecalcFactor(), 
                    nextCount && _didScrollTo(nextCount, !1);
                }, this.willBeReceivedRealData = function(receivedData, multiTargetId) {}, this.didReceiveRealData = function(receivedData, multiTargetId) {
                    !function() {
                        _self.m_xDoBasePrice.didReceiveRealData(receivedData, multiTargetId);
                    }(), _self.didCalculateAllData(!0), _ctrlLayout.RecalcProc(xUtils.constants.ngcl.enum.EUS_UPDATE_RT), 
                    _self.didRecalcFactor();
                }, this.didRecalcProcess = function(argStatus) {}, this.didRecalcFactor = function() {
                    _self.didCalcMinMax(!1), _self.didCalcRatioFactor();
                }, this.didCalcRatioFactor = function() {
                    for (var __nFrameCount = _self.m_arrChartDrawFramelist.length, __ii = 0; __ii < __nFrameCount; __ii++) !function(argObj) {
                        void 0 !== argObj && null != argObj && void 0 !== argObj.didCalcRatioFactor && argObj.didCalcRatioFactor();
                    }(_self.m_arrChartDrawFramelist[__ii]);
                }, this.didCalcMinMax = function(argFlag) {
                    for (var __nFrameCount = _self.m_arrChartDrawFramelist.length, __ii = 0; __ii < __nFrameCount; __ii++) !function(argObj) {
                        void 0 !== argObj && null != argObj && void 0 !== argObj.didCalcMinMax && argObj.didCalcMinMax(argFlag);
                    }(_self.m_arrChartDrawFramelist[__ii]);
                }, this.didReceiveDataExt = function() {
                    _self.m_xDoBasePrice.didReceiveDataExt();
                }, this.didReceiveDataForNontime = function(argLayout) {}, this.SetThreeBreakLine = function(iIndex, stPrice) {
                    _self.m_xDoBasePrice.SetThreeBreakLine(iIndex, stPrice);
                }, this.SetPointFigure = function(iIndex, stPrice) {
                    _self.m_xDoBasePrice.SetPointFigure(iIndex, stPrice);
                }, this.didGetIndexOfTime = function(strTime, tickNo, bAdjust, ignoreLimit) {
                    var __dataIndex = _self.m_xDoBasePrice.didGetDataIndexOfTime(strTime, tickNo), __index = void 0;
                    return (void 0 === __dataIndex || null == __dataIndex || __dataIndex < 0) && !0 === ignoreLimit && (__dataIndex = _self.didGetTimeIndexByTimeString(strTime)), 
                    void 0 !== __dataIndex && (__index = bAdjust ? _self.didConvertDataIndexToLocalIndex(__dataIndex) : __dataIndex), 
                    __index;
                }, this.didPopSelectedChartObjInPanel = function(panel) {
                    if (void 0 === panel || null == panel || void 0 === panel.m_arrChartObjlist) return null;
                    for (var __nObjectCount = panel.m_arrChartObjlist.length, __selectedObj = null, __ii = __nObjectCount - 1; __ii >= 0; __ii--) {
                        var __tempObj = panel.m_arrChartObjlist[__ii];
                        if (void 0 !== __tempObj && null != __tempObj && !0 === __tempObj.m_bSelect) {
                            __selectedObj = __tempObj, panel.m_arrChartObjlist.splice(__ii, 1);
                            break;
                        }
                    }
                    return __selectedObj;
                }, this.OnDoubleClick = function(posval, argEvent, isAxisArea) {
                    if (!0 === _self.didGetEnvInfo().System.UseDoubleClick && (_self.m_bOverTriggerForRequestingPast = !1, 
                    _self.didStopSwipeAction(), _self.m_bCrosslineObject = !1, _self.m_bMouseUpXArea = !1, 
                    _self.m_iXPosMouseDown = posval.XPos, _self.m_bMouseDownSelectedChartObj = !1, _self.m_nSelectedChartObjectIndex = -1, 
                    !_self.m_bTrendLine && !isAxisArea && !0 === _self.didCheckPosvalInPanel(posval))) {
                        if (_self.didDeselectAllFrameObjects(), _self.m_bCrosslineObject = _self.isHitCrosslineBox(posval), 
                        !0 !== _self.m_bCrosslineObject) {
                            var localDrawFrame = _self.m_arrChartDrawFramelist[_self.m_iCanvasMouseDownIndex];
                            void 0 !== localDrawFrame && null != localDrawFrame && (_self.m_nSelectedChartObjectIndex = localDrawFrame.OnSelectChartObj(posval), 
                            localDrawFrame.m_selectTrendlineObj && setTimeout(function() {
                                try {
                                    _ctrlLayout.didNotifyForDoubleClick(localDrawFrame.m_selectTrendlineObj.didGetSimpleAttribute());
                                } catch (e) {
                                    console.debug(e);
                                }
                            }, 50));
                        }
                        _self.DrawingChartDrawFrame(!1);
                    }
                }, this.OnDestroy = function() {
                    for (var iFrameCount = _self.m_arrChartDrawFramelist.length, idx = 0; idx < iFrameCount; idx++) _self.m_arrChartDrawFramelist[idx].OnDestroy();
                    _self.m_arrChartDrawFramelist = [], _self.m_chartXAxisObj.OnDestroy(), delete _self.m_chartXAxisObj, 
                    _self.m_chartXAxisObj = null, _self.didRemoveLinkElements(), _self.didDestroy(), 
                    _self.didDestroyExtra();
                }, this.didDestroy = function() {
                    void 0 !== _self.m_xAxisX && null != _self.m_xAxisX && (delete _self.m_xAxisX, _self.m_xAxisX = null);
                }, this.didDestroyExtra = function() {}, this.OnSettingEnv = function(stEnv) {}, 
                this.didGetBasePriceFrame = function() {
                    for (var __nFrameCount = _self.m_arrChartDrawFramelist.length, __ii = 0; __ii < __nFrameCount; __ii++) {
                        var __xPanel = _self.m_arrChartDrawFramelist[__ii];
                        if (!0 === __xPanel.hasPriceBar()) return __xPanel;
                    }
                }, this.didHitTest = function(mctx, posval) {
                    var posvalAdjusted = {
                        XPos: _self.GetPosXMargined(posval.XPos),
                        YPos: _self.GetPosYMargined(posval.YPos)
                    };
                    return xUtils.hitTest.didHitTest(mctx, posvalAdjusted);
                }, this.didGetXGridDatas = function() {
                    for (var __result = {}, __ii = (_self.GetDataCount(), 0); __ii <= 3; __ii++) {
                        var iIndex, iTotCount = _self.GetDataCount();
                        iIndex = _self.m_iEndX > iTotCount - 1 - _self.m_iSpanMax - _self.m_stEnv.MarginRight ? parseInt((_self.m_iEndX - _self.m_iStartX - _self.m_iSpanMax - _self.m_stEnv.MarginRight + (iTotCount - 1 - _self.m_iEndX)) * __ii / 3) : parseInt((_self.m_iEndX - _self.m_iStartX) * __ii / 3);
                        var iXPos = _self.GetXPos(iIndex), stPrice = _self.GetBaseDataAt(_self.m_iStartX + iIndex, !1);
                        if (0 == parseInt(stPrice.close)) break;
                        _self.DrawLine({
                            context: _self.m_context,
                            startX: iXPos,
                            startY: 1,
                            endX: iXPos,
                            endY: _self.m_canvas.height - 1,
                            lineWidth: 1,
                            lineColor: "#F0F0F0"
                        });
                    }
                    return __result;
                }, this.OnIndiSettingEnv = function(stIndiEnv) {}, this.didMoveDoToNewPanel = function(argFromPanel) {
                    var fromPanel = argFromPanel;
                    if (void 0 !== fromPanel && null != fromPanel) {
                        var popObject = _self.didPopSelectedChartObjInPanel(fromPanel);
                        if (void 0 !== popObject && null != popObject) {
                            _self.m_bMouseUpXArea = !1;
                            var nFrameCount = _self.m_arrChartDrawFramelist.length;
                            nFrameCount < 0 && (nFrameCount = 0);
                            var newPanel = _self.didAppendDrawPanel(nFrameCount, !0);
                            null != popObject && (newPanel.m_arrChartObjlist.push(popObject), popObject.ReSetFrame(newPanel), 
                            popObject.m_bMainChart && (fromPanel.SetMainFrame(!1), newPanel.SetMainFrame(!0))), 
                            _self.ResizeChart(!1);
                        }
                    }
                }, this.didMoveSelectedDoToTargetPanel = function(argFromPanelNo, argTargetPanelNo) {
                    for (var nFromPanelNo = _self.m_iCanvasMouseDownIndex, nTargerPanelNo = _self.m_iCanvasMouseMoveIndex, iSelectIndex = -1, SelectObj = null, iObjCount = _self.m_arrChartDrawFramelist[nFromPanelNo].m_arrChartObjlist.length, idx = iObjCount - 1; idx >= 0; idx--) if (_self.m_arrChartDrawFramelist[nFromPanelNo].m_arrChartObjlist[idx].m_bSelect) {
                        iSelectIndex = idx, SelectObj = _self.m_arrChartDrawFramelist[nFromPanelNo].m_arrChartObjlist[idx];
                        break;
                    }
                    iSelectIndex > -1 && (_self.m_arrChartDrawFramelist[nFromPanelNo].m_arrChartObjlist.splice(iSelectIndex, 1), 
                    _self.m_arrChartDrawFramelist[nTargerPanelNo].m_arrChartObjlist.push(SelectObj), 
                    SelectObj.ReSetFrame(_self.m_arrChartDrawFramelist[nTargerPanelNo]), SelectObj.m_bMainChart && (_self.m_arrChartDrawFramelist[nFromPanelNo].didSetMainFrame(!1), 
                    _self.m_arrChartDrawFramelist[_self.m_arrChartDrawFramelist.length - 1].didSetMainFrame(!0))), 
                    _self.ResizeChart(!1);
                }, this.didGetEnvInfo = function() {
                    return _self.m_stEnv;
                }, this.GetDataSize = function() {
                    return 0;
                }, this.SetAxisStyle = function(nStyle, nullCreate) {
                    return !0 === nullCreate ? (void 0 !== _self.m_xAxisX && null != _self.m_xAxisX || (_self.m_xAxisX = axisUnitFactory.SF_CreateAxisX(nStyle), 
                    _self.m_nAxisX = nStyle), xUtils.constants.ngc.define.NGC_SUCCESS) : _self.m_nAxisX != nStyle ? (void 0 !== _self.m_xAxisX && null != _self.m_xAxisX && (delete _self.m_xAxisX, 
                    _self.m_xAxisX = null), _self.m_xAxisX = axisUnitFactory.SF_CreateAxisX(nStyle), 
                    _self.m_nAxisX = nStyle, xUtils.constants.ngc.define.NGC_SUCCESS) : void 0 === _self.m_xAxisX || null == _self.m_xAxisX ? (_self.m_xAxisX = axisUnitFactory.SF_CreateAxisX(nStyle), 
                    xUtils.constants.ngc.define.NGC_SUCCESS) : xUtils.constants.ngc.define.NGC_SUCCESS;
                }, this.GetAxisStyle = function() {
                    return _self.m_nAxisX;
                }, this.CheckForDraw = function() {
                    return !0;
                }, this.CheckMulti1Panel = function(rc) {
                    return rc;
                }, this.CalcForDraw = function(nStart, nSize, nState) {
                    return {
                        screenStartIndex: nStart,
                        screenSize: nSize
                    };
                }, this.CalcScrDInfo = function(nStart, nSize, nState) {
                    var result = {
                        screenStartIndex: nStart,
                        screenSize: nSize
                    }, bEndPos = !1;
                    return nState === xUtils.constants.ngcl.enum.EUS_UPDATE_IQ && (bEndPos = !0), _self.didCalcScrollInfo(null, bEndPos), 
                    result.screenStartIndex = _self.m_xScrollInfo.pos, result.screenSize = _self.m_xScrollInfo.screenSize, 
                    result;
                }, this.didCalcScrollInfo = function(shiftInfo, bEndPos) {
                    void 0 !== shiftInfo && null != shiftInfo && (_self.m_xShiftInfo.all = shiftInfo.all, 
                    _self.m_xShiftInfo.left = shiftInfo.left, _self.m_xShiftInfo.right = shiftInfo.right), 
                    _self.m_iSpanMax = _self.m_xShiftInfo.left + _self.m_xShiftInfo.right;
                    var xFullRange = _self.didGetFullRange();
                    _self.m_xScrollInfo.range.length = xFullRange.length, _self.m_xScrollInfo.range.length < _self.m_xScrollInfo.screenSize ? (_self.m_xScrollInfo.range.length = _self.m_xScrollInfo.screenSize, 
                    !0 !== _self.m_bOverTriggerForRequestingPast && (_self.m_xScrollInfo.pos = 0)) : !0 === bEndPos ? _self.m_xScrollInfo.pos = _self.didGetScrollEndPos() : !0 === _self.m_stEnv.GoToEndPos && (_self.m_xScrollInfo.pos = _self.didGetScrollEndPos()), 
                    _self.SetSBRange();
                }, this.GetSBHandle = function() {
                    return _ctrlLayout.didGetSBHandle();
                }, this.SetSBRange = function() {
                    var zsbHandle = _self.GetSBHandle();
                    zsbHandle && (zsbHandle.SetZSBRange(_self.m_xScrollInfo.screenSize, _self.m_xScrollInfo.range.length, !0), 
                    zsbHandle.SetZSBPos(_self.m_xScrollInfo.pos, !0));
                }, this.DidScrollToPos = function(argPos, nShows) {
                    nShows && _didZoomTo(nShows, !0), _didScrollTo(argPos, !0);
                }, this.WillBeDrawnBackground = function(pstDp) {}, this.GetSBDiff = function() {
                    return parseInt(_self.m_stEnv.MarginRight);
                }, this.ExGetZoomInfo = function() {
                    return _self.m_xScrollInfo.screenSize;
                }, this.didConvertLocalIndexToDataIndex = function(argLocalIdx, ignoreScrollPos) {
                    var __nScrSIdx = _self.m_xScrollInfo.pos;
                    return ignoreScrollPos && (__nScrSIdx = 0), __nScrSIdx + argLocalIdx - _self.m_xShiftInfo.left;
                }, this.didConvertDataIndexToLocalIndex = function(argDataIdx) {
                    var __nScrSIdx = _self.m_xScrollInfo.pos;
                    return _self.m_xShiftInfo.left + argDataIdx - __nScrSIdx;
                }, this.didGetAxisX = function() {
                    return _self;
                }, this.didConvertPixelToOffset = function(argPixel) {
                    var __ratio = _self.didGetRatioHorizontal(!0);
                    return parseInt(argPixel * __ratio);
                }, this.GetXIndexGap = function(iXPos) {
                    var __ratio = _self.didGetRatioHorizontal(!0);
                    return parseInt(iXPos * __ratio);
                }, this.GetXIndex = function(iXPos) {
                    return _self.didConvertHorizontalPosToDataIndex(iXPos, !0);
                }, this.didConvertHorizontalPosToDataIndex = function(argPosX, bRelative) {
                    var __posX = !0 === bRelative ? argPosX : _self.GetRelativePostionX(argPosX), __nLocalIndex = _self.didConvertPixelToOffset(__posX);
                    return _self.didConvertLocalIndexToDataIndex(__nLocalIndex);
                }, this.GetXPos = function(argLocalIdx) {
                    var __ratio = _self.didGetRatioHorizontal(!1), __nGridWidth = __ratio, iXPos = Math.round(argLocalIdx * __ratio);
                    return iXPos = Math.round(iXPos + __nGridWidth / 2);
                }, this.didConvertHorizontalLocalIndexToPos = function(nScrIdx) {
                    return _self.GetXPos(nScrIdx);
                }, this.GetXPosAtDataIndex = function(dataIndex) {
                    var __ratio = _self.didGetRatioHorizontal(!1), __nGridWidth = __ratio, __localIndex = _self.didConvertDataIndexToLocalIndex(dataIndex), __nLocalPositionX = Math.round(__localIndex * __ratio);
                    return __nLocalPositionX = Math.round(__nLocalPositionX + __nGridWidth / 2);
                }, this.GetIndex2Pixel = function(dataIndex, extraOuput) {
                    var __ratio = _self.didGetRatioHorizontal(!1), __nGridWidth = __ratio, __localIndex = _self.didConvertDataIndexToLocalIndex(dataIndex), __nLocalPositionX = Math.round(__localIndex * __ratio);
                    if (__nLocalPositionX = Math.round(__nLocalPositionX + __nGridWidth / 2), "object" == typeof extraOuput) {
                        var xBarInfo = _self.didGetAdjustedBarInfo(__nLocalPositionX);
                        extraOuput.barRange = xBarInfo, extraOuput.barInfo = {
                            center: __nLocalPositionX,
                            left: __nLocalPositionX - (parseInt(xBarInfo.width / 2) + 1),
                            right: __nLocalPositionX + (parseInt(xBarInfo.width / 2) + 1)
                        };
                    }
                    return __nLocalPositionX;
                }, this.didGetRatioHorizontal = function(baseIsPixel) {
                    var __frameWidth = _self.GetChartFrameAreaWidth(), __nScreenSize = _self.m_xScrollInfo.screenSize;
                    return baseIsPixel ? __nScreenSize / __frameWidth : __frameWidth / __nScreenSize;
                }, this.GetRelativePositionXInfo = function(argAbsolutePostionX) {
                    var nRelativePos = _self.GetRelativePostionX(argAbsolutePostionX);
                    return {
                        pos: nRelativePos,
                        idx: _self.didConvertDataIndexToLocalIndex(_self.GetXIndex(nRelativePos))
                    };
                }, this.didGetAdjustedBarInfo = function(nLocalXPos) {
                    var __ratio = _self.didGetRatioHorizontal(!1), __barWidth = __ratio, __barWidth1 = __barWidth - 1, __halfRatio = __barWidth1 / 2, __halfBar = parseInt(__halfRatio), __result = {
                        grid: __barWidth
                    };
                    return void 0 !== nLocalXPos && (__barWidth > 30 ? (__result.pos = parseInt(nLocalXPos - __halfBar + 3), 
                    __result.width = parseInt(nLocalXPos + __halfBar - 3) - __result.pos) : __barWidth > 15 ? (__result.pos = parseInt(nLocalXPos - __halfBar + 2), 
                    __result.width = parseInt(nLocalXPos + __halfBar - 2) - __result.pos) : __barWidth > 5 ? (__result.pos = parseInt(nLocalXPos - __halfBar + 1), 
                    __result.width = parseInt(nLocalXPos + __halfBar - 1) - __result.pos) : __barWidth > 3 ? (__result.pos = parseInt(nLocalXPos - __halfBar), 
                    __result.width = parseInt(nLocalXPos + __halfBar) - __result.pos) : (__result.pos = nLocalXPos, 
                    __result.width = 1)), __result;
                }, this.didSetDataViewInfo = function(arrDatas) {
                    for (var nCount = _self.m_arrChartDrawFramelist.length, ii = 0; ii < nCount; ii++) {
                        _self.m_arrChartDrawFramelist[ii].didSetDataViewInfo(arrDatas, _self.m_ptCrossline.x);
                    }
                }, this.didGetSelectedTrendlineInfo = function() {
                    for (var nCount = _self.m_arrChartDrawFramelist.length, ii = 0; ii < nCount; ii++) {
                        var xPanel = _self.m_arrChartDrawFramelist[ii], xInfo = xPanel.didFindSelectedObject();
                        if (xInfo && xInfo.tool) return xInfo.tool;
                    }
                }, this.didGetCountForAllTrenslines = function() {
                    for (var nSum = 0, nCount = _self.m_arrChartDrawFramelist.length, ii = 0; ii < nCount; ii++) {
                        var xPanel = _self.m_arrChartDrawFramelist[ii];
                        try {
                            nSum += Math.max(0, xPanel.didGetCountForAllTrenslines());
                        } catch (e) {}
                    }
                    return nSum;
                }, this.didClearAllSubRequestedObjects = function(isOrder, isPosit, isExecution, isAlert) {
                    if (void 0 === _self.m_xDoBasePrice || null == _self.m_xDoBasePrice) return !1;
                    _self.m_xDoBasePrice.didClearOrderPositObjects(isOrder, isPosit);
                    !0 === isExecution && _self.m_xDoBasePrice.didClearExecutionObjects();
                    !0 === isAlert && _self.m_xDoBasePrice.didClearAlertObjects(), _self.DrawingChartDrawFrame(!1);
                }, this.didClearOrderPositObjects = function(isOrder, isPosit) {
                    if (void 0 === _self.m_xDoBasePrice || null == _self.m_xDoBasePrice) return !1;
                    _self.m_xDoBasePrice.didClearOrderPositObjects(isOrder, isPosit);
                }, this.didClearExecutionObjects = function() {
                    if (void 0 === _self.m_xDoBasePrice || null == _self.m_xDoBasePrice) return !1;
                    _self.m_xDoBasePrice.didClearExecutionObjects();
                }, this.didClearAlertObjects = function() {
                    if (void 0 === _self.m_xDoBasePrice || null == _self.m_xDoBasePrice) return !1;
                    _self.m_xDoBasePrice.didClearAlertObjects();
                }, this.didGetAxisXPanel = function() {
                    return _self.m_chartXAxisObj;
                }, this.didGetPanelInfoAtPos = function(posval) {
                    var xHorzArea = _self.GetHorizontalRangeOfAllPanelsInFullArea(), nFullHeight = _self.GetFullDrawPanelHeight();
                    if (!(posval.YPos < 0 || posval.YPos > nFullHeight)) {
                        var xResult = {};
                        xHorzArea.left.pos <= posval.XPos && posval.XPos <= xHorzArea.left.pos + xHorzArea.left.width && (xResult.axis = -1), 
                        xHorzArea.center.pos <= posval.XPos && posval.XPos <= xHorzArea.center.pos + xHorzArea.center.width && (xResult.axis = 0), 
                        xHorzArea.right.pos <= posval.XPos && posval.XPos <= xHorzArea.right.pos + xHorzArea.right.width && (xResult.axis = 1);
                        for (var nCount = _self.m_arrChartDrawFramelist.length, ii = 0; ii < nCount; ii++) {
                            var xPanel = _self.m_arrChartDrawFramelist[ii];
                            if (xPanel) {
                                var xRect = xPanel.didGetPanelRect();
                                xRect.top <= posval.YPos && posval.YPos <= xRect.top + xRect.height && (xResult.panel = xPanel, 
                                xResult.panelNo = ii, xResult.isMain = xPanel.m_bMainFrame);
                            }
                        }
                        return xResult;
                    }
                }, this.didDeselectAllFrameObjects = function(bRefresh) {
                    for (var ii = 0; ii < _self.m_arrChartDrawFramelist.length; ii++) _self.m_arrChartDrawFramelist[ii].DeselectAllObject();
                    !0 === bRefresh && _self.DrawingChartDrawFrame(!1);
                }, this.didProcForMouseDownInAxisArea = function(posval, argEvent) {
                    return !1;
                }, this.didCheckOepPosInAxisArea = function(posval) {}, this.didProcForCrosslineOnMouseMove = function(posval) {
                    var result = _self.didCheckScrollAvailable(), bFlag = !1, bAllowScroll = !0;
                    return result && (bFlag = result.crossline, bAllowScroll = result.scroll), !0 === bFlag && _self.SetCrossLinePoint(posval), 
                    bAllowScroll;
                }, this.didCheckScrollAvailable = function() {
                    var xEnv = _self.didGetEnvInfo(), bFlag = !1, bAllowScroll = !0;
                    return !0 === xEnv.System.UseObjectCrossline && !0 === _self.m_bCrosslineObject && !0 === _self.m_bMouseDown ? (bFlag = !0, 
                    bAllowScroll = !1) : !0 !== xEnv.System.UseObjectCrossline && (xUtils.isCFDPriceBar(xEnv) ? xUtils.isAvailableMouseScrollActionOnCFD(xEnv, _self.m_strTrendLine) ? (bFlag = !0, 
                    bAllowScroll = !0) : (bFlag = !1, bAllowScroll = !1) : (bFlag = !0, bAllowScroll = !0)), 
                    !0 !== _self.m_bMouseDown && (bAllowScroll = !1), {
                        scroll: bAllowScroll,
                        crossline: bFlag
                    };
                }, this.isHitCrosslineBox = function(posval) {
                    var xEnv = _self.didGetEnvInfo();
                    if (!0 !== xEnv.System.UseObjectCrossline) return !1;
                    if (void 0 === _self.m_ptCrossline || null == _self.m_ptCrossline) return !1;
                    try {
                        var radius = xEnv.System.CrosslineBoxRadius + 3, nDistX = Math.abs(posval.XPos - _self.m_ptCrossline.x), nDistY = Math.abs(posval.YPos - _self.m_ptCrossline.y);
                        if (xEnv.CrossLine.box.isCircle) {
                            if (Math.sqrt(Math.pow(nDistX, 2) + Math.pow(nDistY, 2)) < radius) return !0;
                        } else if (nDistX < radius && nDistY < radius) return !0;
                    } catch (e) {
                        console.error(e);
                    }
                    return !1;
                }, this.didProcForMouseDownAboutAction = function(posval, argEvent, actionArea) {
                    if (void 0 === actionArea || null == actionArea) return !1;
                    if (actionArea.isDetail) {
                        if (_self.m_chartWrapper.didReflectCallForDetailView) {
                            var xNotifyData = {
                                targetId: actionArea.targetId
                            };
                            _self.m_chartWrapper.didReflectCallForDetailView(xNotifyData);
                        }
                        return _self.didGetEnvInfo().DetailViewStatusIsShown = !0, _self.DrawingChartDrawFrame(), 
                        !0;
                    }
                    if (actionArea.isLegend) {
                        try {
                            for (var nCount = _self.m_arrChartDrawFramelist.length, ii = 0; ii < nCount; ii++) {
                                var xDf = _self.m_arrChartDrawFramelist[ii];
                                if (xDf && xDf.didClickLegendButton && !0 === xDf.didClickLegendButton(actionArea.targetId)) break;
                            }
                            return !0;
                        } catch (e) {
                            console.error(e);
                        }
                        return !0;
                    }
                    if (actionArea.isExtraArea) try {
                        return _self.m_xExtraPanel && _self.m_xExtraPanel.OnSelectChartObj && _self.m_xExtraPanel.OnSelectChartObj(posval), 
                        !0;
                    } catch (e) {
                        console.error(e);
                    }
                    return !1;
                }, this.didCreateExtraPanel = function() {
                    _self.m_xExtraPanel = new extraPanelClass(_chartWrapper, _self), _self.m_xExtraPanel.didInitPanel(_self.m_domElemChartDraw);
                }, this.m_toolTipToid = null, this.m_toolTipPosval = null, this.m_toolTipActionArea = null, 
                this.didShowTooltip = function(isShow, posval, toolTipText, limitRect) {
                    void 0 !== _self.m_xTooltip && null != _self.m_xTooltip || (_self.m_xTooltip = new tooltipClass(_chartWrapper, _self), 
                    _self.m_xTooltip.didInitPanel(_self.m_domElemChartDraw)), _self.m_xTooltip.didShowTooltip(isShow, posval, toolTipText, limitRect);
                }, this.didClearTooltipEventer = function() {
                    _self.m_toolTipPosval = null, _self.m_toolTipActionArea = null, void 0 !== _self.m_toIdTooltip && null != _self.m_toIdTooltip && clearTimeout(_self.m_toIdTooltip), 
                    _self.m_toIdTooltip = null;
                }, this.didHitTestForExtraObject = function(posval, actionArea) {
                    if (posval) {
                        var hitPosVal = xUtils.didClone(posval);
                        hitPosVal.__onmove__ = !0;
                        var xDoSelected;
                        if (actionArea && 1 == actionArea.isExtraArea) _self.m_xExtraPanel.OnSelectChartObj(hitPosVal) >= 0 && (xDoSelected = _self.m_xExtraPanel.m_xDoExtraSelected); else {
                            var localDrawFrame = _self.m_arrChartDrawFramelist[_self.m_iCanvasMouseMoveIndex];
                            localDrawFrame.OnSelectChartObj(hitPosVal) >= 0 && (xDoSelected = localDrawFrame.m_xSelectedOepObject);
                        }
                        return xDoSelected;
                    }
                }, this.didProcForTooltip = function(posval, actionArea) {
                    try {
                        if (!posval) return;
                        var xEnv = _self.didGetEnvInfo(), isDeleteOneRepeat = xUtils.trendLine.isDeleteOneRepeat(_self.m_strTrendLine), isCrossHairMode = xUtils.trendLine.isCrossHairMode(_self.m_strTrendLine);
                        if (1 == _self.m_bMouseDown || 1 == _self.m_bOrderLine || 1 == isDeleteOneRepeat || 1 == _self.m_bTrendLine && 1 != isCrossHairMode) return;
                        _self.didShowTooltip(!1), _self.didClearTooltipEventer(), _self.m_toolTipPosval = xUtils.didClone(posval), 
                        _self.m_toolTipActionArea = xUtils.didClone(actionArea), _self.m_toIdTooltip = setTimeout(function() {
                            if (_self.m_toolTipPosval && _self.m_toolTipActionArea) {
                                var xDoSelected = _self.didHitTestForExtraObject(_self.m_toolTipPosval, _self.m_toolTipActionArea);
                                if (xDoSelected && xDoSelected.didGetTooltipText) {
                                    var rect = {
                                        x: 0,
                                        y: 0,
                                        width: _chartWrapper.m_iChartWrapWidth,
                                        height: _chartWrapper.m_iChartWrapHeight
                                    };
                                    _self.didShowTooltip(!0, _self.m_toolTipPosval, xDoSelected.didGetTooltipText(), rect);
                                }
                            }
                            _self.didClearTooltipEventer();
                        }, xEnv.TooltipDelay);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didGetScrollLevelInfo = function() {
                    if (!(void 0 === _self.m_xScrollInfo.levelList || null == _self.m_xScrollInfo.levelList || void 0 === _self.m_xScrollInfo.levelList.length || null == _self.m_xScrollInfo.levelList.length || _self.m_xScrollInfo.levelList.length < 1)) {
                        var level = _self.m_xScrollInfo.level || 0;
                        return _self.m_xScrollInfo.levelList[level];
                    }
                }, this.didGetDistanceFactor = function() {
                    return _self.GetChartFrameAreaWidth() / _self.m_xScrollInfo.screenSize;
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDrawPanelBase = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.chartDrawFrameNormal, global.WGC_CHART.chartXAxisPanelNormal, global.WGC_CHART.chartDOFactory, global.WGC_CHART.chartAxisUnit, global.WGC_CHART.chartDrawPanelExtra, global.WGC_CHART.chartDrawPanelTooltip, global.WGC_CHART.canvas2DUtil) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(7), __webpack_require__(11), __webpack_require__(2), __webpack_require__(3), __webpack_require__(31), __webpack_require__(32), __webpack_require__(1));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(gxDc, xUtils, doFactory) {
            var exports = {};
            return exports.m_idChartDraw = "idChartDrawAPIPanel", exports.panelBase = function(chartWrapper, drawWrapper) {
                var _self = this;
                this.OBJECT_NAME = "BASE_FRAME", this.m_doFactory = doFactory, this.m_chartWraper = chartWrapper, 
                this.m_drawWrapper = drawWrapper, this.m_arrChartObjlist = [], this.m_idChartDraw = "", 
                this.m_iFrameIndex = 0, this.m_initParam = null, this.m_rectInfo = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    lw: 0,
                    rw: 0
                }, this.m_canvas = null, this.m_canvasLY = null, this.m_canvasRY = null, this.m_btnClose = null, 
                this.m_context = null, this.m_contextLY = null, this.m_contextRY = null, this.m_memcanvas = null, 
                this.m_memcontext = null, this.m_bMainFrame = !1, this.m_currTrendlineObj = null, 
                this.m_selectTrendlineObj = null, this.m_objCrosslineY = null, this.m_iBaseWidth = 0, 
                this.m_iBaseHeight = 0, this.m_iBaseOriginY = 0, this.m_iGridWidth = 0, this.m_iGridHeight = 0, 
                this.m_xScaleInfo = xUtils.scale.didCreateScaleInfo(), this.m_iLastMaxPrice = 0, 
                this.m_iLastMinPrice = 0, this.m_xSelectedOepObject = null, this.isNontime = !1, 
                this.didGetEnvInfo = function() {
                    return _self.m_drawWrapper.didGetEnvInfo();
                }, this.didInitContext = function() {
                    _self.m_context = _self.m_canvas.getContext("2d"), _self.m_contextLY = _self.m_canvasLY.getContext("2d"), 
                    _self.m_contextRY = _self.m_canvasRY.getContext("2d"), _self.m_memcanvas = document.createElement("canvas"), 
                    _self.m_memcanvas.width = _self.m_canvas.width, _self.m_memcanvas.height = _self.m_canvas.height, 
                    _self.m_memcontext = _self.m_memcanvas.getContext("2d");
                };
                var _didInitCrosslineLabelElement = function(domElem) {
                    void 0 !== domElem && null != domElem && (domElem.className = "classCrosslineLabel", 
                    domElem.style.position = "absolute", domElem.style.left = "0px", domElem.style.top = "0px", 
                    domElem.style.visibility = "hidden");
                };
                this.didClickLegendButton = function(targetId) {
                    if (!targetId) return !1;
                    try {
                        var temps = targetId.split("_"), __tempNo = temps[1], __no = _self.m_initParam.no;
                        if (void 0 !== __tempNo && null != __tempNo && __no === parseInt(__tempNo)) {
                            var isOn = !_self.m_initParam.showLegend;
                            return _self.didUpdateLegendOnOff(isOn), _self.DrawFrame(!1), !0;
                        }
                    } catch (e) {
                        console.error(e);
                    }
                    return !1;
                }, this.didUpdateLegendOnOff = function(isOn) {
                    try {
                        _self.m_initParam.showLegend = isOn;
                        var className = "classLegendInfoButtonImageOn";
                        !0 === _self.m_initParam.showLegend && (className = "classLegendInfoButtonImageOff"), 
                        _self.m_initParam.imgLegendInfo.className = className;
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didSetMainFrame = function(mainFrame, noSet) {
                    !0 !== noSet && (_self.m_bMainFrame = mainFrame), _self.m_initParam.btnDetailInfo && (1 == _self.m_bMainFrame ? _self.m_initParam.btnDetailInfo.style.visibility = "visible" : _self.m_initParam.btnDetailInfo.style.visibility = "hidden");
                }, this.didInitActionElements = function(initParam) {
                    try {
                        var __deParent = _self.m_initParam.drawPanel, __no = _self.m_initParam.no;
                        _self.m_btnDetailInfo = document.createElement("button"), _self.m_btnDetailInfo.setAttributeNS(null, "id", "eidDetailInfoButton_" + __no), 
                        _self.m_btnDetailInfo.className = "classDetailInfoButton", _self.m_initParam.btnDetailInfo = _self.m_btnDetailInfo, 
                        _self.m_btnLegendInfo = document.createElement("div"), _self.m_btnLegendInfo.setAttributeNS(null, "id", "eidLegendInfoButton_" + __no), 
                        _self.m_btnLegendInfo.className = "classLegendInfoButton", _self.m_imgLegendInfo = document.createElement("image"), 
                        _self.m_imgLegendInfo.setAttributeNS(null, "id", "eidLegendInfoButtonImage_" + __no), 
                        _self.m_btnLegendInfo.appendChild(_self.m_imgLegendInfo), _self.m_initParam.btnLegendInfo = _self.m_btnLegendInfo, 
                        _self.m_initParam.imgLegendInfo = _self.m_imgLegendInfo, _self.didSetMainFrame(_self.m_bMainFrame, !0), 
                        _self.didUpdateLegendOnOff(!0), __deParent.appendChild(_self.m_btnDetailInfo), __deParent.appendChild(_self.m_btnLegendInfo);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didGetBackgroundColor = function(useOpacity) {
                    if (1 != useOpacity) return "transparent";
                    var xEnv = _self.didGetEnvInfo();
                    return _self.m_bMainFrame ? xEnv.BackgroundColor : void 0 === xEnv.SubBackgroundColor || null == xEnv.SubBackgroundColor ? xEnv.BackgroundColor : xEnv.SubBackgroundColor;
                }, this.didInitElements = function(initParam) {
                    _self.m_initParam = initParam;
                    var __deParent = _self.m_initParam.parent, __no = _self.m_initParam.no;
                    _self.m_chartdraw = document.createElement("div"), _self.m_chartdraw.setAttributeNS(null, "id", "idChartDraw" + __no), 
                    _self.m_chartdraw.className = "classChartItem", _self.m_initParam.drawPanel = _self.m_chartdraw, 
                    _self.m_canvas = document.createElement("canvas"), _self.m_canvasLY = document.createElement("canvas"), 
                    _self.m_canvasRY = document.createElement("canvas"), _self.m_initParam.drawCanvas = _self.m_canvas, 
                    _self.m_initParam.drawCanvasLY = _self.m_canvasLY, _self.m_initParam.drawCanvasRY = _self.m_canvasRY;
                    var backgroundColor = _self.didGetBackgroundColor();
                    _self.m_canvas.className = "classChartItem", _self.m_canvas.style.backgroundColor = backgroundColor, 
                    _self.m_canvas.onmousedown = _self.m_initParam.onMouseDown, _self.m_canvas.onmousemove = _self.m_initParam.onMouseMove, 
                    _self.m_canvasLY.className = "classChartItem", _self.m_canvasLY.style.backgroundColor = backgroundColor, 
                    _self.m_canvasRY.className = "classChartItem", _self.m_canvasRY.style.backgroundColor = backgroundColor, 
                    _self.m_btnClose = document.createElement("div"), _self.m_btnClose.className = "panelCloseButton", 
                    _self.m_initParam.drawClose = _self.m_btnClose, _self.m_btnClose.style.position = "absolute", 
                    _self.m_btnClose.style.width = "10px", _self.m_btnClose.style.height = "10px", _self.m_btnClose.style.visibility = "hidden", 
                    _self.m_btnClose.onclick = _self.m_initParam.onClose, _self.m_objCrosslineLY = document.createElement("div"), 
                    _self.m_initParam.drawCrossLY = _self.m_objCrosslineLY, _didInitCrosslineLabelElement(_self.m_objCrosslineLY), 
                    _self.m_objCrosslineRY = document.createElement("div"), _self.m_initParam.drawCrossRY = _self.m_objCrosslineRY, 
                    _didInitCrosslineLabelElement(_self.m_objCrosslineRY), _self.m_chartdraw.appendChild(_self.m_canvasLY), 
                    _self.m_chartdraw.appendChild(_self.m_canvas), _self.m_chartdraw.appendChild(_self.m_canvasRY), 
                    _self.m_chartdraw.appendChild(_self.m_objCrosslineLY), _self.m_chartdraw.appendChild(_self.m_objCrosslineRY), 
                    _self.m_chartdraw.appendChild(_self.m_btnClose), __deParent.appendChild(_self.m_chartdraw), 
                    _self.didInitContext(), _self.didResetPanelNo(__no);
                }, this.didCreateDefaultObject = function(bMainFrame, initParam) {
                    _self.didGetEnvInfo();
                    if (!0 === bMainFrame) return function(argPanel) {
                        var __chartObj = argPanel.m_doFactory.createDrawObject(xUtils.constants.keywords.defaults.price, !0), __strChartName = _self.m_drawWrapper.m_stEnv.ChartType;
                        return __chartObj.Init(argPanel, __strChartName, _self.m_drawWrapper), argPanel.m_arrChartObjlist.push(__chartObj), 
                        __chartObj;
                    }(_self);
                }, this.didInitDrawFrame = function(bMainFrame, initParam) {
                    var xEnv = _self.didGetEnvInfo();
                    return _self.m_arrChartObjlist = [], _self.m_bMainFrame = bMainFrame, _self.didInitElements(initParam), 
                    1 != xEnv.System.UseForMiniChart && _self.didInitActionElements(initParam), _self.didCreateDefaultObject(bMainFrame, initParam);
                }, this.didGetShiftInfo = function() {
                    return _self.m_drawWrapper.didGetShiftInfo();
                }, this.didCalcShiftInfo = function() {
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, __result = {
                        all: 0,
                        left: 0,
                        right: 0
                    }, __ii = 0; __ii < __nObjectCount; __ii++) {
                        var __xDo = _self.m_arrChartObjlist[__ii];
                        void 0 !== __xDo && null != __xDo && void 0 !== __xDo.didGetShifRightCount && (__result.left = Math.max(__xDo.didGetShifLeftCount(), __result.left), 
                        __result.right = Math.max(__xDo.didGetShifRightCount(), __result.right));
                    }
                    return __result.all = __result.left + __result.right, __result;
                }, this.didResetPanelNo = function(argNo) {
                    if (_self.m_iFrameIndex = argNo, _self.m_idChartDraw = "idChartDraw" + argNo, void 0 !== _self.m_initParam && null != _self.m_initParam) {
                        var __dePanel = _self.m_initParam.drawPanel, __deCanvas = _self.m_initParam.drawCanvas, __deCanvasLY = _self.m_initParam.drawCanvasLY, __deCanvasRY = _self.m_initParam.drawCanvasRY, __deBtnClose = _self.m_initParam.drawClose, __deCrossLY = _self.m_initParam.drawCrossLY, __deCrossRY = _self.m_initParam.drawCrossRY;
                        __dePanel.setAttributeNS(null, "id", "idChartDraw" + argNo), __deCanvas.setAttributeNS(null, "id", "idCanvas" + argNo), 
                        __deCanvasLY.setAttributeNS(null, "id", "idCanvasLY" + argNo), __deCanvasRY.setAttributeNS(null, "id", "idCanvasRY" + argNo), 
                        __deBtnClose.setAttributeNS(null, "id", "idCloseBtn" + argNo), __deCrossLY.setAttributeNS(null, "id", "idCrosslineLY" + argNo), 
                        __deCrossRY.setAttributeNS(null, "id", "idCrosslineRY" + argNo);
                    }
                }, this.didCheckEmptyPanel = function(bRemoveLink) {
                    return _self.m_arrChartObjlist.length < 1 && !0 === bRemoveLink && (_self.didRemoveLinkElements(), 
                    !0);
                }, this.didRemoveLinkElements = function() {
                    if (void 0 !== _self.m_initParam && null != _self.m_initParam) {
                        var __deParent = _self.m_initParam.parent, __dePanel = _self.m_initParam.drawPanel, __deCanvas = _self.m_initParam.drawCanvas, __deCanvasLY = _self.m_initParam.drawCanvasLY, __deCanvasRY = _self.m_initParam.drawCanvasRY, __deBtnClose = _self.m_initParam.drawClose;
                        __dePanel.removeChild(__deCanvas), __dePanel.removeChild(__deCanvasLY), __dePanel.removeChild(__deCanvasRY), 
                        __dePanel.removeChild(__deBtnClose), __dePanel.removeChild(_self.m_initParam.drawCrossLY), 
                        __dePanel.removeChild(_self.m_initParam.drawCrossRY), __dePanel.removeChild(_self.m_initParam.btnDetailInfo), 
                        __dePanel.removeChild(_self.m_initParam.btnLegendInfo), __deParent.removeChild(__dePanel);
                    }
                }, this.didGetPanelRect = function() {
                    var __rect = {
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0
                    };
                    return void 0 !== _self.m_chartdraw && null != _self.m_chartdraw && (__rect.left = _self.m_chartdraw.offsetLeft, 
                    __rect.top = _self.m_chartdraw.offsetTop, __rect.width = _self.m_chartdraw.offsetWidth, 
                    __rect.height = _self.m_chartdraw.offsetHeight), __rect;
                }, this.didResizePanel = function(resizeParam) {
                    if (void 0 !== resizeParam && null != resizeParam) {
                        var __chartWidth = (_self.didGetEnvInfo(), resizeParam.width - (resizeParam.leftY + resizeParam.rightY)), __chartHeight = resizeParam.height;
                        _self.m_rectInfo.x = resizeParam.left, _self.m_rectInfo.y = resizeParam.top, _self.m_rectInfo.width = resizeParam.width, 
                        _self.m_rectInfo.height = __chartHeight, _self.m_rectInfo.lw = resizeParam.leftY, 
                        _self.m_rectInfo.rw = resizeParam.rightY;
                        var devicePixelRatio = window.devicePixelRatio || 1, ratio = devicePixelRatio;
                        _self.m_canvas.width = ratio * __chartWidth, _self.m_canvas.height = ratio * __chartHeight, 
                        _self.m_canvasLY.width = ratio * resizeParam.leftY, _self.m_canvasLY.height = ratio * __chartHeight, 
                        _self.m_canvasRY.width = ratio * resizeParam.rightY, _self.m_canvasRY.height = ratio * __chartHeight, 
                        _self.m_memcanvas.width = _self.m_canvas.width, _self.m_memcanvas.height = _self.m_canvas.height, 
                        _self.m_chartdraw.style.left = resizeParam.left + "px", _self.m_chartdraw.style.top = resizeParam.top + "px", 
                        _self.m_chartdraw.style.width = resizeParam.width + "px", _self.m_chartdraw.style.height = __chartHeight + "px", 
                        _self.m_canvas.style.left = resizeParam.leftY + "px", _self.m_canvas.style.top = "0px", 
                        _self.m_canvas.style.width = __chartWidth + "px", _self.m_canvas.style.height = __chartHeight + "px", 
                        _self.m_canvasLY.style.left = "0px", _self.m_canvasLY.style.top = "0px", _self.m_canvasLY.style.width = resizeParam.leftY + "px", 
                        _self.m_canvasLY.style.height = __chartHeight + "px", _self.m_canvasRY.style.left = resizeParam.leftY + __chartWidth + "px", 
                        _self.m_canvasRY.style.top = "0px", _self.m_canvasRY.style.width = resizeParam.rightY + "px", 
                        _self.m_canvasRY.style.height = __chartHeight + "px", _self.m_btnClose.style.left = resizeParam.leftY + __chartWidth - 15 + "px", 
                        _self.m_btnClose.style.top = "5px", _self.didResizeActionButton(resizeParam), _self.SetBaseSize();
                    }
                }, this.didResizeActionButton = function(resizeParam) {
                    if (void 0 !== resizeParam && null != resizeParam) try {
                        var __xEnv = _self.didGetEnvInfo();
                        if (!0 === __xEnv.System.UseForMiniChart) return;
                        var nLeftPos = resizeParam.leftY + __xEnv.ActionButtonLeft, nTopPos = __xEnv.ActionButtonTop;
                        _self.m_initParam.btnDetailInfo.style.left = nLeftPos + "px", _self.m_initParam.btnDetailInfo.style.top = nTopPos + "px", 
                        nLeftPos += __xEnv.ActionButtonGap + __xEnv.ActionButtonSize, _self.m_initParam.btnLegendInfo.style.left = nLeftPos + "px", 
                        _self.m_initParam.btnLegendInfo.style.top = nTopPos + "px";
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didChangeAxisWidth = function(argLeft, argRight) {
                    var __resizeParam = {
                        left: _self.m_rectInfo.x,
                        top: _self.m_rectInfo.y,
                        width: _self.m_rectInfo.width,
                        height: _self.m_rectInfo.height,
                        leftY: argLeft,
                        rightY: argRight
                    };
                    _self.didResizePanel(__resizeParam);
                }, this.didResizePanelHeight = function(argHeight, argTop) {
                    var __resizeParam = {
                        left: _self.m_rectInfo.x,
                        top: void 0 !== argTop ? argTop : _self.m_rectInfo.y,
                        width: _self.m_rectInfo.width,
                        height: argHeight,
                        leftY: _self.m_rectInfo.lw,
                        rightY: _self.m_rectInfo.rw
                    };
                    _self.didResizePanel(__resizeParam);
                }, this.AddChartObj = function(strChartName) {
                    var __chartObj = null;
                    void 0 !== (__chartObj = _self.m_doFactory.createDrawObject(strChartName)) && null !== __chartObj && (_self.m_arrChartObjlist.push(__chartObj), 
                    __chartObj.Init(this, strChartName, _self.m_drawWrapper), "IchiMoku" != strChartName && __chartObj.didCalculateData());
                }, this.didAddChartObj = function(argDo) {
                    var __chartObj = argDo;
                    if (void 0 !== __chartObj && null !== __chartObj) {
                        _self.m_arrChartObjlist.push(__chartObj), __chartObj.Init(this, __chartObj.m_strIndicator, _self.m_drawWrapper);
                        var xShiftInfo = _self.didGetShiftInfo();
                        return void 0 !== xShiftInfo && null != xShiftInfo && void 0 !== __chartObj.SetOffMinus && null != __chartObj.SetOffMinus && __chartObj.SetOffMinus(xUtils.didCalculateShiftValue(xShiftInfo, xUtils.constants.default.SHIFT_IS_ST)), 
                        "IchiMoku" !== __chartObj.m_strIndicator && __chartObj.didCalculateData(), !0;
                    }
                }, this.CreateTrendlineObj = function(strTrendLine, posval) {}, this.DidEndCreatingObject = function() {
                    var xResult = {
                        refresh: !1,
                        newOrder: void 0
                    };
                    return void 0 != _self.m_currTrendlineObj && null != _self.m_currTrendlineObj && (_self.m_currTrendlineObj.m_bCreating = !1, 
                    _self.m_currTrendlineObj.isAutoDeleteObject && _self.m_currTrendlineObj.isAutoDeleteObject() ? (console.debug(_self.m_currTrendlineObj), 
                    _self.m_currTrendlineObj.didGetNewOrderValue && (xResult.newOrder = _self.m_currTrendlineObj.didGetNewOrderValue()), 
                    !0 === xUtils.trendLine.didDeleteTargetToolObject(_self.m_currTrendlineObj) && (xResult.refresh = !0)) : xResult.refresh = !0, 
                    _self.m_currTrendlineObj = void 0), xResult;
                }, this.SetTrendlineLastPoint = function(posval) {
                    void 0 !== _self.m_currTrendlineObj && null != _self.m_currTrendlineObj && (_self.m_currTrendlineObj.SetLastPoint(posval), 
                    _self.m_currTrendlineObj.SetExtraPoint());
                }, this.SetTrendlineMove = function(posval) {
                    if (_self.m_selectTrendlineObj) 1 === _self.m_selectTrendlineObj.m_iSelectGubun ? _self.m_selectTrendlineObj.SetStartPoint(posval) : 2 === _self.m_selectTrendlineObj.m_iSelectGubun ? _self.m_selectTrendlineObj.SetLastPoint(posval) : 0 === _self.m_selectTrendlineObj.m_iSelectGubun ? _self.m_selectTrendlineObj.SetMovePoint(posval) : 3 === _self.m_selectTrendlineObj.m_iSelectGubun && _self.m_selectTrendlineObj.SetExtraPoint(posval); else if (_self.m_xSelectedOepObject && _self.m_xSelectedOepObject.SetTrendlineMove && _self.m_xSelectedOepObject.SetTrendlineMove(posval)) return _self.m_objCrosslineLY.style.visibility = "hidden", 
                    _self.m_objCrosslineRY.style.visibility = "hidden", !0;
                }, this.hasPriceBar = function() {
                    if (!0 !== _self.m_bMainFrame) return !1;
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, __ii = 0; __ii < __nObjectCount; __ii++) if (!0 === _self.m_arrChartObjlist[__ii].m_bMainChart) return !0;
                    return !1;
                }, this.didGetPriceBar = function() {
                    if (!0 === _self.m_bMainFrame) for (var __nObjectCount = _self.m_arrChartObjlist.length, __ii = 0; __ii < __nObjectCount; __ii++) {
                        var xDo = _self.m_arrChartObjlist[__ii];
                        if (xDo && !0 === xDo.m_bMainChart) return xDo;
                    }
                }, this.didFindObjectByKey = function(argKey) {
                    if (void 0 !== argKey && null != argKey) for (var __nObjectCount = _self.m_arrChartObjlist.length, ii = 0; ii < __nObjectCount; ii++) {
                        var xDo = _self.m_arrChartObjlist[ii];
                        if (xDo && argKey === xDo.uniqueKey) return xDo;
                    }
                }, this.didFindIndicatorObjectsByTypeId = function(argTypeId) {
                    if (void 0 !== argTypeId && null != argTypeId) {
                        for (var arrResult = [], __nObjectCount = _self.m_arrChartObjlist.length, ii = 0; ii < __nObjectCount; ii++) {
                            var xDo = _self.m_arrChartObjlist[ii];
                            xDo && xDo.m_xSeriesInfo && xDo.m_xSeriesInfo.code && argTypeId === xDo.m_xSeriesInfo.code && arrResult.push({
                                panel: _self,
                                index: ii,
                                indicator: xDo
                            });
                        }
                        return arrResult;
                    }
                }, this.didFindFirstIndicatorObjectByTypeId = function(argTypeId) {
                    var arrResult = _self.didFindIndicatorObjectsByTypeId(argTypeId);
                    if (!(void 0 === arrResult || null == arrResult || void 0 === arrResult.length || null == arrResult.length || arrResult.length < 1)) return arrResult[0];
                }, this.didFindSelectedObject = function() {
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, ii = 0; ii < __nObjectCount; ii++) {
                        var xDo = _self.m_arrChartObjlist[ii];
                        if (!0 === xDo.m_bSelect) return !0 === xDo.m_bMainChart ? {
                            panel: _self,
                            price: xDo,
                            index: ii
                        } : {
                            panel: _self,
                            indicator: xDo,
                            index: ii
                        };
                        var xSelectedLs = xDo.didFindSelectedLineTool();
                        if (void 0 !== xSelectedLs && null != xSelectedLs) return {
                            panel: _self,
                            tool: xSelectedLs,
                            index: ii
                        };
                    }
                }, this.didGetCountForAllTrenslines = function() {
                    var nSum = 0;
                    try {
                        for (var __nObjectCount = _self.m_arrChartObjlist.length, ii = 0; ii < __nObjectCount; ii++) {
                            var xDo = _self.m_arrChartObjlist[ii];
                            if (xDo.didGetCountForAllTrenslines) {
                                var nCnt = Math.max(0, xDo.didGetCountForAllTrenslines());
                                nSum += nCnt;
                            }
                        }
                    } catch (e) {
                        nSum = 0;
                    }
                    return nSum;
                }, this.didDeleteIndicator = function(argTypeId) {
                    return !1;
                }, this.didRemoveSelectedLineTool = function() {
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, __ii = 0; __ii < __nObjectCount; __ii++) if (!0 === function(argObj) {
                        if (void 0 !== argObj && null != argObj && void 0 !== argObj.didRemoveSelectedLineTool) return !0 === argObj.didRemoveSelectedLineTool.call();
                    }(_self.m_arrChartObjlist[__ii])) return !0;
                    return !1;
                }, this.didRemoveAllLineTools = function() {
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, __ii = 0; __ii < __nObjectCount; __ii++) !function(argObj) {
                        void 0 !== argObj && null != argObj && argObj.didRemoveAllLineTools();
                    }(_self.m_arrChartObjlist[__ii]);
                }, this.didClearDrawObjectAt = function(argIndex) {
                    var __nObjectCount = _self.m_arrChartObjlist.length;
                    return __nObjectCount > 0 && argIndex >= 0 && argIndex < __nObjectCount && (function(argObj) {
                        void 0 !== argObj && null != argObj && argObj.didDestroy();
                    }(_self.m_arrChartObjlist[argIndex]), delete _self.m_arrChartObjlist[argIndex], 
                    _self.m_arrChartObjlist.splice(argIndex, 1), !0);
                }, this.didClearDrawObject = function() {
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, __ii = 0; __ii < __nObjectCount; __ii++) !function(argObj) {
                        void 0 !== argObj && null != argObj && argObj.didDestroy();
                    }(_self.m_arrChartObjlist[__ii]), delete _self.m_arrChartObjlist[__ii];
                    return _self.m_arrChartObjlist = [], !0;
                }, this.OnDestroy = function() {
                    _self.didClearDrawObject();
                }, this.didCalculateData = function() {
                    for (var ii = 0; ii < _self.m_arrChartObjlist.length; ii++) _self.m_arrChartObjlist[ii].didCalculateData();
                }, this.didCalculateRealData = function(nStart, nDSize, nSSize) {
                    for (var ii = 0; ii < _self.m_arrChartObjlist.length; ii++) _self.m_arrChartObjlist[ii].didCalculateRealData(nStart, nDSize, nSSize);
                }, this.didCalculateDataForExtraObject = function(nStart, nDSize, nSSize) {
                    for (var ii = 0; ii < _self.m_arrChartObjlist.length; ii++) _self.m_arrChartObjlist[ii].didCalculateDataForExtraObject(nStart, nDSize, nSSize);
                }, this.ReceiveCompareData = function(strCode) {
                    _self.AddChartObj(strCode);
                }, this.didApplyMinMaxToPriceType = function() {
                    !function(argObjects, argFlag, argScaleUnit) {
                        if (!0 === argFlag && void 0 !== argObjects && null != argObjects) for (var __nObjectCount = argObjects.length, __ii = 0; __ii < __nObjectCount; __ii++) {
                            var __xDo = argObjects[__ii];
                            void 0 === __xDo && null == __xDo || !0 === argFlag && !0 === __xDo.m_bPriceType && (__xDo.didApplyScaleUnit(argScaleUnit), 
                            __xDo.didCalcRatioFactor());
                        }
                    }(_self.m_arrChartObjlist, _self.m_bMainFrame, _self.m_xScaleInfo.current);
                }, this.didCalcMinMax = function(argFlag) {
                    var xScaleUnit = _self.m_xScaleInfo.current;
                    xUtils.scale.didResetScaleUnit(xScaleUnit);
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, __nScrSIdx = _self.m_drawWrapper.m_xScrollInfo.pos, __nScrSize = _self.m_drawWrapper.m_xScrollInfo.screenSize, __ii = 0; __ii < __nObjectCount; __ii++) {
                        var __xDo = _self.m_arrChartObjlist[__ii];
                        __xDo.didCalcMinMax(__nScrSIdx, __nScrSize, argFlag);
                        var xDoScaleUnit = __xDo.didGetScaleUnit();
                        !0 === _self.m_bMainFrame && !0 === __xDo.m_bPriceType && (xScaleUnit.minMaxScreen.maxValue = Math.max(xScaleUnit.minMaxScreen.maxValue, xDoScaleUnit.minMaxScreen.maxValue), 
                        xScaleUnit.minMaxScreen.minValue = Math.min(xScaleUnit.minMaxScreen.minValue, xDoScaleUnit.minMaxScreen.minValue));
                    }
                    xScaleUnit.minMaxScreen.diff = xUtils.scale.didCalcDiff(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue), 
                    xScaleUnit.minMaxScreen.diff < 0 && xUtils.scale.didAdjustReverseMinMax(xScaleUnit), 
                    _self.didApplyMinMaxToPriceType();
                }, this.didCalcRatioFactor = function() {
                    var xScaleUnit = _self.m_xScaleInfo.current;
                    _self.m_iGridHeight = _self.m_iBaseHeight / xScaleUnit.minMaxScreen.diff;
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, __ii = 0; __ii < __nObjectCount; __ii++) {
                        var __xDo = _self.m_arrChartObjlist[__ii];
                        void 0 !== __xDo && null != __xDo && __xDo.didCalcRatioFactor();
                    }
                };
                var _prepareDrawFrame = function(argPanel) {
                    var backgroundColor = _self.didGetBackgroundColor();
                    argPanel.m_canvas.style.backgroundColor = backgroundColor, argPanel.m_canvasLY.style.backgroundColor = backgroundColor, 
                    argPanel.m_canvasRY.style.backgroundColor = backgroundColor, argPanel.m_context.clearRect(0, 0, 1, argPanel.m_canvas.height), 
                    argPanel.m_contextLY.clearRect(0, 0, 1, argPanel.m_canvasLY.height), argPanel.m_contextRY.clearRect(0, 0, 1, argPanel.m_canvasRY.height), 
                    argPanel.m_context.clearRect(0, 0, argPanel.m_canvas.width, argPanel.m_canvas.height), 
                    argPanel.m_contextLY.clearRect(0, 0, argPanel.m_canvasLY.width, argPanel.m_canvasLY.height), 
                    argPanel.m_contextRY.clearRect(0, 0, argPanel.m_canvasRY.width, argPanel.m_canvasRY.height), 
                    argPanel.m_context.translate(.5, .5), argPanel.m_contextLY.translate(.5, .5), argPanel.m_contextRY.translate(.5, .5), 
                    argPanel.m_contextLY.font = argPanel.m_drawWrapper.m_stEnv.ConfigAxis.Font, argPanel.m_contextLY.fillStyle = argPanel.m_drawWrapper.m_stEnv.ConfigAxis.FontColor, 
                    argPanel.m_contextRY.font = argPanel.m_drawWrapper.m_stEnv.ConfigAxis.Font, argPanel.m_contextRY.fillStyle = argPanel.m_drawWrapper.m_stEnv.ConfigAxis.FontColor;
                }, _didEndDrawFrame = function() {
                    _self.m_context.translate(-.5, -.5), _self.m_contextLY.translate(-.5, -.5), _self.m_contextRY.translate(-.5, -.5);
                }, _drawAxisPanelBorder = function() {
                    var __xEnv = _self.didGetEnvInfo(), drawLineParam = {
                        context: void 0,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: 1,
                        lineColor: __xEnv.BorderColor
                    }, __height = _self.didGetDrawingHeight(), __lw = _self.m_rectInfo.lw, __rw = _self.m_rectInfo.rw;
                    drawLineParam.context = _self.m_contextLY, drawLineParam.pt1.x = 0, drawLineParam.pt1.y = 0, 
                    drawLineParam.pt2.x = __lw, drawLineParam.pt2.y = 0, gxDc.Line(drawLineParam), drawLineParam.pt1.x = 0, 
                    drawLineParam.pt1.y = 0, drawLineParam.pt2.x = 0, drawLineParam.pt2.y = __height, 
                    gxDc.Line(drawLineParam), drawLineParam.context = _self.m_contextRY, drawLineParam.pt1.x = -1, 
                    drawLineParam.pt1.y = 0, drawLineParam.pt2.x = __rw - 2, drawLineParam.pt2.y = 0, 
                    gxDc.Line(drawLineParam), drawLineParam.context = _self.m_contextRY, drawLineParam.pt1.x = __rw - 2, 
                    drawLineParam.pt1.y = 0, drawLineParam.pt2.x = __rw - 2, drawLineParam.pt2.y = __height, 
                    gxDc.Line(drawLineParam);
                }, _drawPanelBorder = function(argPanel) {
                    var __xEnv = _self.didGetEnvInfo();
                    _drawAxisPanelBorder();
                    var __context = _self.m_context, __nWidth = _self.m_drawWrapper.GetChartFrameAreaWidth(), __nHeight = _self.didGetDrawingHeight(), drawLineParam = {
                        context: __context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: 1,
                        lineColor: __xEnv.BorderColor
                    };
                    drawLineParam.pt1.x = __nWidth - 1, drawLineParam.pt1.y = 0, drawLineParam.pt2.x = __nWidth - 1, 
                    drawLineParam.pt2.y = __nHeight, gxDc.Line(drawLineParam), drawLineParam.pt1.x = 0, 
                    drawLineParam.pt1.y = 0, drawLineParam.pt2.x = 0, drawLineParam.pt2.y = __nHeight, 
                    gxDc.Line(drawLineParam), drawLineParam.pt1.x = -1, drawLineParam.pt1.y = 0, drawLineParam.pt2.x = __nWidth, 
                    drawLineParam.pt2.y = 0, gxDc.Line(drawLineParam), drawLineParam.pt1.x = -1, drawLineParam.pt1.y = __nHeight - 1, 
                    drawLineParam.pt2.x = __nWidth, drawLineParam.pt2.y = __nHeight - 1, gxDc.Line(drawLineParam);
                };
                this.didDrawVerticalGrid = function(argPanel) {
                    if (!0 === _self.m_drawWrapper.m_stEnv.ConfigAxis.GridShow) {
                        var xEnv = _self.didGetEnvInfo();
                        if (!0 !== xEnv.ConfigAxis.GridVertHide) {
                            var gridWidth = _self.m_drawWrapper.GetDrawPanelWidth(), __drawAxisParam = {
                                scrollInfo: {
                                    pos: _self.m_drawWrapper.m_xScrollInfo.pos,
                                    screenSize: _self.m_drawWrapper.m_xScrollInfo.screenSize
                                },
                                timeType: _self.m_drawWrapper.didGetReferencedPriceObject().m_symbolInfo.nTType,
                                timeInterval: _self.m_drawWrapper.didGetReferencedPriceObject().m_symbolInfo.nTGap,
                                config: {
                                    font: xEnv.ConfigAxis.Font,
                                    fontColor: xEnv.ConfigAxis.FontColor,
                                    gridStyle: xEnv.ConfigAxis.GridStyle,
                                    gridColor: xEnv.ConfigAxis.GridVertColor,
                                    show: xEnv.ConfigAxis.GridShow
                                },
                                height: _self.didGetDrawingHeight(),
                                axis: _self,
                                drawWrapper: _self.m_drawWrapper,
                                isGrid: !0,
                                target: {
                                    context: _self.m_context,
                                    leftWidth: xEnv.System.YAxisLeft,
                                    rightWidth: xEnv.System.YAxisRight,
                                    gridWidth: gridWidth
                                },
                                levelInfo: _self.m_drawWrapper.didGetScrollLevelInfo(),
                                isNontime: _self.isNontime
                            };
                            xUtils.axis.didDrawXAxisWithLevel(__drawAxisParam);
                        }
                    }
                };
                var _drawChartObjects = function(argPanel, bResize) {
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, __bFirst = !1, __bLast = !1, __ii = 0; __ii < __nObjectCount; __ii++) {
                        var __xDo = _self.m_arrChartObjlist[__ii];
                        __bFirst = 0 === __ii, __ii === __nObjectCount && (__bLast = !0), __xDo.DrawObj(bResize, __bFirst, __bLast);
                    }
                }, _didGetLastObject = function() {
                    var __nObjectCount = _self.m_arrChartObjlist.length;
                    if (!(__nObjectCount < 1)) {
                        return _self.m_arrChartObjlist[__nObjectCount - 1];
                    }
                }, _didGetAxisYObject = function() {
                    var __xDo = _didGetLastObject();
                    return void 0 === __xDo || null == __xDo ? _self : __xDo;
                };
                this.didGetVerticalConvertInfo = function(argLocalPosY) {
                    var xScaleUnit = _self.m_xScaleInfo.current, __result = {
                        min: xScaleUnit.minMaxScreen.minValue,
                        max: xScaleUnit.minMaxScreen.maxValue,
                        size: xUtils.scale.didCalcDiff(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue),
                        offset: 0,
                        ratioPv: 0,
                        ratioVp: 0
                    }, __base = _self.didGetBaseCoordinate();
                    return void 0 !== argLocalPosY && (__result.offset = __base.height + __base.y - argLocalPosY), 
                    __result.ratioPv = 0 !== __base.height ? __result.size / __base.height : 0, __result.ratioVp = 0 !== __result.size ? __base.height / __result.size : 0, 
                    __result;
                }, this.didDrawYAxis = function() {
                    var __xDo = _didGetLastObject();
                    if (void 0 !== __xDo && null != __xDo) {
                        var __xEnv = _self.didGetEnvInfo(), isCompare = xUtils.isCompareChartMode(__xEnv);
                        return function(xDo, verpos) {
                            var xYAxisInfo = _self.didGetYAxisInfo(xDo), __maxPrice = xYAxisInfo.max, __minPrice = xYAxisInfo.min, __xAxisY = xYAxisInfo.axis, __base = _self.didGetBaseCoordinate(), __xEnv = _self.didGetEnvInfo(), __drawParam = {
                                price: {
                                    max: __maxPrice,
                                    min: __minPrice,
                                    verpos: verpos
                                },
                                config: {
                                    font: __xEnv.ConfigAxis.Font,
                                    fontColor: __xEnv.ConfigAxis.FontColor,
                                    gridStyle: __xEnv.ConfigAxis.GridStyle,
                                    gridColor: __xEnv.ConfigAxis.GridHorzColor,
                                    multiColor: __xEnv.ConfigAxis.MultipleLabelColor,
                                    show: 1 != __xEnv.ConfigAxis.GridHorzHide
                                },
                                y: __base.y,
                                height: __base.height,
                                axis: __xAxisY,
                                target: {
                                    left: {
                                        context: _self.m_contextLY,
                                        width: _self.m_rectInfo.lw
                                    },
                                    grid: {
                                        context: _self.m_context,
                                        width: _self.m_rectInfo.width
                                    },
                                    right: {
                                        context: _self.m_contextRY,
                                        width: _self.m_rectInfo.rw
                                    }
                                },
                                guideSize: __xEnv.System.AxisGuideBase
                            };
                            if (void 0 !== __xEnv.System.SubBackgroundMargin && null != __xEnv.System.SubBackgroundMargin) {
                                var devicePixelRatio = window.devicePixelRatio || 1, ratio = devicePixelRatio, clipLeft = {
                                    x: 0,
                                    y: Math.round(__xEnv.System.SubBackgroundMargin * ratio),
                                    width: _self.m_rectInfo.lw,
                                    height: Math.round(_self.m_rectInfo.height - 2 * __xEnv.System.SubBackgroundMargin * ratio)
                                }, clipRight = {
                                    x: 0,
                                    y: Math.round(__xEnv.System.SubBackgroundMargin * ratio),
                                    width: _self.m_rectInfo.rw,
                                    height: Math.round(_self.m_rectInfo.height - 2 * __xEnv.System.SubBackgroundMargin * ratio)
                                };
                                __drawParam.target.left.clip = clipLeft, __drawParam.target.right.clip = clipRight;
                            }
                            return xUtils.axis.didDrawYAxisAsBeauty(__drawParam);
                        }(__xDo, __xDo.didGetPointValue(isCompare));
                    }
                }, this.DrawFrame = function(bResize) {
                    _prepareDrawFrame(this), _self.didDrawVerticalGrid(this), _self.didDrawYAxis(), 
                    _self.DrawLastValue(), _drawChartObjects(0, bResize), _drawPanelBorder(), _self.DrawCrossLine(), 
                    _self.DrawCrossLineYLabel(), _self.DrawTitleLabel(), _self.didSetStautsForDetailInfo(), 
                    _self.didSetStautsForLegendInfo(), _didEndDrawFrame();
                }, this.DrawTitleLabel = function() {}, this.DrawGrid = function() {}, this.SetChartTitle = function(iLeft, iTop, strChartTitle) {
                    _self.m_context.font = _self.m_drawWrapper.m_stEnv.Font, _self.m_context.fillStyle = _self.m_drawWrapper.m_stEnv.FontColor, 
                    _self.DrawText({
                        context: _self.m_context,
                        text: strChartTitle,
                        left: iLeft,
                        top: iTop
                    });
                }, this.SetCrossLine = function(posval) {
                    var __rectFullChart = _self.m_drawWrapper.GetFullDrawPanelRect(!0), __posXLeft = __rectFullChart.x, __posXRight = __rectFullChart.x + __rectFullChart.width, __posYTop = __rectFullChart.y, __posYBottom = __rectFullChart.y + __rectFullChart.height;
                    if (__posXLeft < posval.XPos && __posXRight > posval.XPos && __posYTop < posval.YPos && __posYBottom > posval.YPos) {
                        var __rPos = _self.GetRelativePositionInPanel(posval.XPos, posval.YPos);
                        posval.XPos = _self.SetXPosition(__rPos.x), posval.YPos = __rPos.y;
                    } else posval.XPos = -1, posval.YPos = -1;
                    _self.DrawCrossLine(posval), _self.DrawCrossLineYLabel(posval.YPos);
                };
                var _didDrawCrossLineBox = function(nCrossLineXPos, nCrossLineYPos) {
                    var xEnv = _self.didGetEnvInfo();
                    if (!0 === xEnv.System.UseObjectCrossline && !0 !== xEnv.CrossLine.hide) try {
                        var radius = xEnv.System.CrosslineBoxRadius, isCircle = !1;
                        try {
                            isCircle = xEnv.CrossLine.box.isCircle;
                        } catch (e) {}
                        if (void 0 !== radius && null != radius) if (isCircle) {
                            var __drawCircleParam = {
                                context: _self.m_context,
                                pt: {
                                    x: nCrossLineXPos,
                                    y: nCrossLineYPos
                                },
                                radius: radius,
                                lineWeight: xEnv.CrossLine.lineStyle.strokeWeight,
                                lineColor: xEnv.CrossLine.lineStyle.strokeColor
                            };
                            gxDc.Circle(__drawCircleParam);
                        } else {
                            var __drawRectParam = {
                                context: _self.m_context,
                                rect: {
                                    x: 0,
                                    y: 0,
                                    width: 0,
                                    height: 0
                                },
                                lineWidth: xEnv.CrossLine.lineStyle.strokeWeight,
                                lineColor: xEnv.CrossLine.lineStyle.strokeColor
                            };
                            __drawRectParam.rect.x = nCrossLineXPos - (radius + 1), __drawRectParam.rect.y = nCrossLineYPos - (radius + 1), 
                            __drawRectParam.rect.width = __drawRectParam.rect.height = 2 * radius + 1, gxDc.Rectangle(__drawRectParam);
                        }
                    } catch (e) {
                        console.error(e);
                    }
                };
                this.DrawCrossLine = function(posval) {
                    var xEnv = _self.didGetEnvInfo(), nCrossLineXPos = -1, nCrossLineYPos = -1;
                    if (void 0 === posval || null == posval) {
                        var ptCrossline = _self.didGetCrosslinePoint();
                        nCrossLineXPos = ptCrossline.x, nCrossLineYPos = _self.GetRelativePostionY(ptCrossline.y);
                    } else nCrossLineXPos = posval.XPos, nCrossLineYPos = posval.YPos;
                    var __panelWidth = _self.didGetDrawingWidth(), __panelHeight = _self.didGetDrawingHeight();
                    if (!0 !== xEnv.CrossLine.hide) {
                        var __drawLineParam = (_self.m_drawWrapper.GetChartFrameAreaWidth(), {
                            context: _self.m_context,
                            pt1: {
                                x: 0,
                                y: 0
                            },
                            pt2: {
                                x: 0,
                                y: 0
                            },
                            lineWidth: xEnv.CrossLine.lineStyle.strokeWeight,
                            lineColor: xEnv.CrossLine.lineStyle.strokeColor,
                            lineStyle: xEnv.CrossLine.lineStyle.strokeStyle
                        });
                        __drawLineParam.pt1.x = 0, __drawLineParam.pt1.y = nCrossLineYPos, __drawLineParam.pt2.x = __panelWidth, 
                        __drawLineParam.pt2.y = nCrossLineYPos, gxDc.Line(__drawLineParam), __drawLineParam.pt1.x = nCrossLineXPos, 
                        __drawLineParam.pt1.y = 0, __drawLineParam.pt2.x = nCrossLineXPos, __drawLineParam.pt2.y = __panelHeight, 
                        gxDc.Line(__drawLineParam);
                    }
                    if (_didDrawCrossLineBox(nCrossLineXPos, nCrossLineYPos), !0 === _self.m_drawWrapper.m_stEnv.ShowDataView) for (var __nObjectCount = _self.m_arrChartObjlist.length, idx = __nObjectCount - 1; idx >= 0; idx--) _self.m_arrChartObjlist[idx].DrawDataView(idx, nCrossLineXPos);
                }, this.DrawCrossLineYLabel = function(argLocalYPos) {
                    var xEnv = _self.didGetEnvInfo();
                    if (!0 !== xEnv.CrossLine.hide) {
                        if (void 0 === argLocalYPos || null == argLocalYPos) {
                            var ptCrossline = _self.didGetCrosslinePoint();
                            argLocalYPos = _self.GetRelativePostionY(ptCrossline.y);
                        }
                        var isCompare = xUtils.isCompareChartMode(xEnv), __xAxisY = _didGetAxisYObject(), __verpos = __xAxisY.didGetPointValue(isCompare), showStyleForLabelLY = "hidden", showStyleForLabelRY = "hidden";
                        if (argLocalYPos > -1) {
                            var __nPrice = __xAxisY.GetYPosToVal(argLocalYPos);
                            __nPrice = xUtils.axis.didAdjustZFValue(__nPrice, !0);
                            var xScaleUnit = __xAxisY.didGetScaleUnit(), xMMScreen = xScaleUnit.minMaxScreen, xMultipleFactor = xUtils.axis.label.didCalcMutipleValue(xMMScreen.maxValue, xMMScreen.minValue);
                            xMultipleFactor && (__nPrice = Math.round(__nPrice * xMultipleFactor.pow));
                            var strPrice = String(xUtils.number.didGetPointedValue(__nPrice, __verpos));
                            try {
                                xMMScreen.minValue > xMMScreen.maxValue && (strPrice = "0");
                            } catch (e) {
                                strPrice = "0";
                            }
                            var __horzRange = _self.m_drawWrapper.GetHorizontalRangeOfAllPanelsInFullArea(), iXPosRY = (_self.m_contextLY.measureText(strPrice).width, 
                            __horzRange.right.pos);
                            _self.m_objCrosslineLY.innerHTML = strPrice, _self.m_objCrosslineRY.innerHTML = strPrice, 
                            _self.m_objCrosslineLY.style.left = "0px", _self.m_objCrosslineRY.style.left = iXPosRY + "px", 
                            _self.m_objCrosslineLY.style.top = argLocalYPos - _self.m_objCrosslineLY.offsetHeight / 2 + "px", 
                            _self.m_objCrosslineRY.style.top = argLocalYPos - _self.m_objCrosslineRY.offsetHeight / 2 + "px";
                            try {
                                !0 !== xEnv.CrossLine.hide && (!0 === _self.m_drawWrapper.m_stEnv.ConfigAxis.ShowLeft && (showStyleForLabelLY = "visible"), 
                                !0 === _self.m_drawWrapper.m_stEnv.ConfigAxis.ShowRight && (showStyleForLabelRY = "visible"));
                            } catch (e) {
                                console.error(e);
                            }
                        }
                        _self.m_objCrosslineLY.style.visibility = showStyleForLabelLY, _self.m_objCrosslineRY.style.visibility = showStyleForLabelRY;
                    } else try {
                        _self.m_objCrosslineLY.style.visibility = "hidden", _self.m_objCrosslineRY.style.visibility = "hidden";
                    } catch (e) {
                        console.error(e);
                    }
                }, this.SetBaseSize = function() {
                    var __xEnv = _self.didGetEnvInfo(), __width = _self.m_drawWrapper.GetChartFrameAreaWidth(), __height = _self.didGetDrawingHeight(), __marginTopOrBottom = Math.round(__height * (__xEnv.MarginTopBottom / 100));
                    1 == _self.m_bMainFrame && !0 === __xEnv.System.UseFlexMarginTopBottomInMain && 1 == __xEnv.MinMaxTooltipShow && (__marginTopOrBottom += __xEnv.System.ExtraMarginForTopBottomInMain || 30), 
                    _self.m_iBaseWidth = __width, _self.m_iBaseHeight = __height - 2 * __marginTopOrBottom, 
                    _self.m_iBaseOriginY = __marginTopOrBottom, _self.m_iGridWidth = _self.didGetRatioHorizontal(!1), 
                    _self.didCalcRatioFactor();
                }, this.DrawLine = function(stStyle) {
                    var __drawParam = {
                        context: stStyle.context,
                        pt1: {
                            x: stStyle.startX,
                            y: stStyle.startY
                        },
                        pt2: {
                            x: stStyle.endX,
                            y: stStyle.endY
                        },
                        lineWidth: stStyle.lineWidth,
                        lineColor: stStyle.lineColor
                    };
                    gxDc.Line(__drawParam);
                }, this.DrawLastValue = function() {
                    try {
                        for (var __base = _self.didGetBaseCoordinate(), __xEnv = _self.didGetEnvInfo(), __drawParam = {
                            config: {
                                font: __xEnv.ConfigAxis.Font,
                                fontColor: "#ffffff"
                            },
                            y: __base.y,
                            height: __base.height,
                            target: {
                                left: {
                                    context: _self.m_contextLY,
                                    width: _self.m_canvasLY.width
                                },
                                right: {
                                    context: _self.m_contextRY,
                                    width: _self.m_canvasRY.width
                                }
                            }
                        }, __nDataCount = _self.didGetPriceDatas().length, __nObjectCount = _self.m_arrChartObjlist.length, __ii = 0; __ii < __nObjectCount; __ii++) {
                            var __xDo = _self.m_arrChartObjlist[__ii];
                            0 === __ii, __ii === __nObjectCount && !0, __xDo.DrawLastValue(__drawParam, __nDataCount - 1);
                        }
                    } catch (e) {
                        console.debug(e);
                    }
                }, this.didSetDataViewInfo = function(arrDatas, argCrossLineXPos) {
                    if (void 0 !== arrDatas && null != arrDatas && void 0 !== arrDatas.length && null != arrDatas.length) for (var __nObjectCount = _self.m_arrChartObjlist.length, ii = 0; ii < __nObjectCount; ii++) {
                        var xDo = _self.m_arrChartObjlist[ii], xInfo = xDo.didGetDataViewDataAtPos(argCrossLineXPos);
                        void 0 !== xInfo && null != xInfo && arrDatas.push(xInfo);
                    }
                }, this.DeselectAllObject = function() {
                    for (var idx = 0; idx < _self.m_arrChartObjlist.length; idx++) {
                        _self.m_arrChartObjlist[idx].DeselectAllObject();
                    }
                }, this.OnSelectChartObj = function(posval, isHover) {
                    posval.YPos = posval.YPos - _self.m_chartdraw.offsetTop, posval.YPosAdjusted = !0;
                    var hitPoint = {
                        XPos: _self.m_drawWrapper.GetPosXMargined(posval.XPos),
                        YPos: _self.m_drawWrapper.GetPosYMargined(posval.YPos)
                    }, rect = {
                        x: 0,
                        y: 0,
                        width: _self.m_canvas.width,
                        height: _self.m_canvas.height
                    }, hitTestTool = xUtils.hitTest.prepareTools(rect, hitPoint, _self.m_memcanvas, _self.m_memcontext);
                    hitTestTool.willBeHitTest(!0);
                    var iSelectIndex = -1, idx = 0;
                    _self.m_selectTrendlineObj = null, _self.m_xSelectedOepObject = null;
                    var xEnv = _self.didGetEnvInfo(), __nObjectCount = _self.m_arrChartObjlist.length;
                    for (idx = __nObjectCount - 1; idx >= 0; idx--) {
                        var __xDo = _self.m_arrChartObjlist[idx];
                        if (void 0 !== __xDo.m_arrPosits && null != __xDo.m_arrPosits) {
                            for (var __nPositCount = __xDo.m_arrPosits.length, ii = __nPositCount - 1; ii >= 0; ii--) {
                                var objPositObj = _self.m_arrChartObjlist[idx].m_arrPosits[ii];
                                if (_self.m_xSelectedOepObject = objPositObj.didHitTest(posval, hitTestTool), _self.m_xSelectedOepObject) {
                                    iSelectIndex = xUtils.constants.default.DEFAULT_WRONG_VALUE;
                                    break;
                                }
                            }
                            if (_self.m_xSelectedOepObject) break;
                        }
                        if (void 0 !== __xDo.m_arrOrders && null != __xDo.m_arrOrders) {
                            for (var __nOrderCount = __xDo.m_arrOrders.length, ii = __nOrderCount - 1; ii >= 0; ii--) {
                                var objOrderObj = _self.m_arrChartObjlist[idx].m_arrOrders[ii];
                                if (_self.m_xSelectedOepObject = objOrderObj.didHitTest(posval, hitTestTool), _self.m_xSelectedOepObject) {
                                    iSelectIndex = xUtils.constants.default.DEFAULT_WRONG_VALUE;
                                    break;
                                }
                            }
                            if (_self.m_xSelectedOepObject) break;
                        }
                        if (__xDo.didHitTestForAlertObject && (_self.m_xSelectedOepObject = __xDo.didHitTestForAlertObject(posval, hitTestTool), 
                        _self.m_xSelectedOepObject)) {
                            iSelectIndex = xUtils.constants.default.DEFAULT_WRONG_VALUE;
                            break;
                        }
                        if (1 != isHover && __xDo.didHitTestForExecutionObject && (_self.m_xSelectedOepObject = __xDo.didHitTestForExecutionObject(posval, hitTestTool), 
                        _self.m_xSelectedOepObject)) {
                            iSelectIndex = xUtils.constants.default.DEFAULT_WRONG_VALUE;
                            break;
                        }
                        for (var __nLSCount = __xDo.m_arrTrendlineObjlist.length, idxTrend = 0; idxTrend < __nLSCount; idxTrend++) {
                            var objLSObj = __xDo.m_arrTrendlineObjlist[idxTrend];
                            if (_self.m_selectTrendlineObj = objLSObj.didHitTest(posval, hitTestTool), _self.m_selectTrendlineObj) {
                                iSelectIndex = xUtils.constants.default.DEFAULT_WRONG_VALUE;
                                break;
                            }
                        }
                        if (_self.m_selectTrendlineObj) break;
                    }
                    if (!0 === xEnv.System.ContainerSelect && !0 === xEnv.System.IndicatorSelect && !_self.m_xSelectedOepObject && !_self.m_selectTrendlineObj) {
                        var SelectObj = null;
                        for (idx = __nObjectCount - 1; idx >= 0; idx--) {
                            var __xDo = _self.m_arrChartObjlist[idx];
                            if (!0 !== __xDo.m_bPrice) {
                                if (__xDo.didHitTest(posval, hitTestTool)) {
                                    iSelectIndex = idx, SelectObj = _self.m_arrChartObjlist[idx];
                                    break;
                                }
                            }
                        }
                        iSelectIndex > -1 && (_self.m_arrChartObjlist.splice(iSelectIndex, 1), _self.m_arrChartObjlist.push(SelectObj));
                    }
                    return hitTestTool.closeHitTest(!0), hitTestTool = {}, iSelectIndex;
                }, this.DrawText = function(stStyle) {
                    stStyle.context.fillText(stStyle.text, stStyle.left, stStyle.top);
                }, this.GetRelativePostionX = function(argAbsolutePostionX) {
                    return _self.m_drawWrapper.GetRelativePostionX(argAbsolutePostionX);
                }, this.GetRelativePostionY = function(argAbsolutePostionY, bFlag) {
                    return !0 === bFlag ? _self.m_drawWrapper.GetRelativePostionY(argAbsolutePostionY) : _self.m_drawWrapper.GetRelativePostionY(argAbsolutePostionY) - _self.m_chartdraw.offsetTop;
                }, this.GetRelativePositionXInfo = function(argAbsolutePostionX) {
                    return _self.m_drawWrapper.GetRelativePositionXInfo(argAbsolutePostionX);
                }, this.GetRelativePositionInPanel = function(argAbsolutePostionX, argAbsolutePostionY) {
                    var __xPosInfo = _self.GetRelativePositionXInfo(argAbsolutePostionX), __yPos = _self.GetRelativePostionY(argAbsolutePostionY);
                    return {
                        x: {
                            pos: __xPosInfo.pos,
                            idx: __xPosInfo.idx
                        },
                        y: __yPos
                    };
                }, this.didGetBaseCoordinate = function() {
                    return {
                        x: 0,
                        y: _self.m_iBaseOriginY,
                        width: _self.m_drawWrapper.GetChartFrameAreaWidth(),
                        height: _self.m_iBaseHeight,
                        rh: _self.m_iGridWidth,
                        rv: _self.m_iGridHeight
                    };
                }, this.didGetRatioHorizontal = function(baseIsPixel) {
                    return _self.m_drawWrapper.didGetRatioHorizontal(baseIsPixel);
                }, this.didGetLastChartObject = function() {
                    var __nObjectCount = _self.m_arrChartObjlist.length;
                    return void 0 === __nObjectCount || __nObjectCount < 1 ? null : _self.didGetChartObjectAt(__nObjectCount - 1);
                }, this.didGetChartObjectAt = function(argIndex) {
                    var __nObjIdx = void 0 === argIndex ? 0 : argIndex, __nObjectCount = _self.m_arrChartObjlist.length;
                    return void 0 === __nObjectCount || __nObjectCount < 1 || __nObjIdx < 0 || __nObjIdx >= __nObjectCount ? null : _self.m_arrChartObjlist[argIndex];
                }, this.didGetSelectionMarkRadius = function() {
                    return _self.m_iGridWidth < 8 ? 3 : 4;
                }, this.didGetPriceDatas = function() {
                    return _self.m_drawWrapper.didGetPriceDatas();
                }, this.didGetReferencedPriceDatas = function() {
                    return _self.m_drawWrapper.didGetReferencedPriceDatas();
                }, this.didClearIndicatorDatas = function() {
                    for (var __nObjectCount = _self.m_arrChartObjlist.length, ii = 0; ii < __nObjectCount; ii++) {
                        var __xDo = _self.m_arrChartObjlist[ii];
                        void 0 !== __xDo.didClearIndicatorDatas && __xDo.didClearIndicatorDatas();
                    }
                }, this.didGetScaleUnit = function(isRef) {
                    return !0 === isRef ? _self.m_xScaleInfo.current : xUtils.didClone(_self.m_xScaleInfo.current);
                }, this.didGetYAxisInfo = function(argDo) {
                    var xScaleUnit = _self.didGetScaleUnit(), xYai = {
                        min: xScaleUnit.minMaxScreen.minValue,
                        max: xScaleUnit.minMaxScreen.maxValue,
                        axis: _self
                    };
                    if (void 0 !== argDo && null != argDo) {
                        var xDoSu = argDo.didGetScaleUnit();
                        !0 === argDo.m_bPriceType && !0 === _self.m_bMainFrame || (xYai.min = xDoSu.minMaxScreen.minValue, 
                        xYai.max = xDoSu.minMaxScreen.maxValue, xYai.axis = argDo);
                    }
                    return xYai;
                }, this.GetXPos = function(argLocalIdx) {
                    return _self.m_drawWrapper.GetXPos(argLocalIdx);
                }, this.didConvertHorizontalLocalIndexToPos = function(nScrIdx) {
                    return _self.m_drawWrapper.didConvertHorizontalLocalIndexToPos(nScrIdx);
                }, this.didConvertHorizontalPosToDataIndex = function(argPosX) {
                    return _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(argPosX);
                }, this.didConvertScreenIndexToDataIndex = function(argScrIdx) {
                    return _self.m_drawWrapper.didConvertScreenIndexToDataIndex(argScrIdx);
                }, this.GetYPos = function(strPrice) {
                    var xScaleUnit = _self.m_xScaleInfo.current, __base = _self.didGetBaseCoordinate(), __nPriceDiff = xUtils.didConvertToPrice(strPrice) - xScaleUnit.minMaxScreen.minValue;
                    return xUtils.axis.didGetLocalYPos(__base, __nPriceDiff);
                }, this.GetYValToPos = function(strPrice) {
                    return _self.GetYPos(strPrice);
                }, this.GetYPosToVal = function(argLocalPosY) {
                    var __xAxisY = _didGetAxisYObject();
                    if (void 0 !== __xAxisY && null != __xAxisY) return __xAxisY.GetYPosToVal(argLocalPosY);
                    var __xVci = _self.didGetVerticalConvertInfo(argLocalPosY);
                    return Math.round(__xVci.min + __xVci.offset * __xVci.ratioPv);
                }, this.GetYPixelToVal = function(argOffset) {
                    var __xAxisY = _didGetAxisYObject();
                    if (void 0 !== __xAxisY && null != __xAxisY) return __xAxisY.GetYPixelToVal(argOffset);
                    var __xVci = _self.didGetVerticalConvertInfo(0);
                    return xUtils.didRoundPrice(argOffset * __xVci.ratioPv);
                }, this.SetXPosition = function(argScrPosInfo) {
                    var scrPosInfo = argScrPosInfo, nLocalIdx = (scrPosInfo.pos, scrPosInfo.idx);
                    return _self.didConvertHorizontalLocalIndexToPos(nLocalIdx);
                }, this.didGetCrosslinePoint = function() {
                    return _self.m_drawWrapper.didGetCrosslinePoint();
                }, this.didGetDrawingWidth = function(isCalc) {
                    return 1 == isCalc ? _self.m_rectInfo.width - (_self.m_rectInfo.lw + _self.m_rectInfo.rw) : _self.m_rectInfo.width;
                }, this.didGetDrawingHeight = function() {
                    return _self.m_rectInfo.height;
                }, this.didSetStautsForDetailInfo = function() {
                    if (_self.m_initParam.btnDetailInfo && 1 == _self.m_bMainFrame) {
                        1 == _self.didGetEnvInfo().DetailViewStatusIsShown ? _self.m_initParam.btnDetailInfo.disabled = !0 : _self.m_initParam.btnDetailInfo.disabled = !1;
                    }
                }, this.didSetStautsForLegendInfo = function() {
                    if (_self.m_initParam.btnLegendInfo) {
                        var nCount = _self.m_arrChartObjlist.length, bShow = !1;
                        if (nCount > 0) for (var ii = 0; ii < nCount; ii++) {
                            var xDo = _self.m_arrChartObjlist[ii];
                            if (xDo && xDo.hasObjectToShow && 1 == xDo.hasObjectToShow()) {
                                bShow = !0;
                                break;
                            }
                        }
                        _self.m_initParam.btnLegendInfo.style.visibility = 1 == bShow ? "visible" : "hidden";
                    }
                };
            }, exports.createPanel = function(chartWrapper, drawWrapper) {
                return new this.panelBase(chartWrapper, drawWrapper);
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDrawFrameBase = loadModule(global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartUtil, global.WGC_CHART.chartDOFactory) : module.exports = loadModule(__webpack_require__(1), __webpack_require__(0), __webpack_require__(2));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc, doPriceBaseClass, doExtraFactory) {
            return function() {
                var _self = this;
                this.prototype = new doPriceBaseClass(), doPriceBaseClass.apply(this, arguments), 
                this.m_xTooltipHigh, this.m_xTooltipLow, this.m_arrOrders = [], this.m_arrPosits = [], 
                this.m_arrAlerts = [], this.m_arrExecutions = [], this.m_xAskBid = {
                    validFlag: !1,
                    ask: void 0,
                    bid: void 0
                };
                var _DeselectAllOrders = function() {
                    for (var nCount = _self.m_arrOrders.length, ii = 0; ii < nCount; ii++) {
                        var xDoo = _self.m_arrOrders[ii];
                        xDoo && xDoo.DeselectAllObject && xDoo.DeselectAllObject();
                    }
                }, _DeselectAllPosits = function() {
                    for (var nCount = _self.m_arrPosits.length, ii = 0; ii < nCount; ii++) {
                        var xDop = _self.m_arrPosits[ii];
                        xDop && xDop.DeselectAllObject && xDop.DeselectAllObject();
                    }
                }, _DeselectAllAlerts = function() {
                    for (var nCount = _self.m_arrAlerts.length, ii = 0; ii < nCount; ii++) {
                        var xDoo = _self.m_arrAlerts[ii];
                        xDoo && xDoo.DeselectAllObject && xDoo.DeselectAllObject();
                    }
                }, _DeselectAllExecutions = function() {
                    for (var nCount = _self.m_arrExecutions.length, ii = 0; ii < nCount; ii++) {
                        var xDop = _self.m_arrExecutions[ii];
                        xDop && xDop.DeselectAllObject && xDop.DeselectAllObject();
                    }
                };
                this.DeslectAllRest = function() {
                    _DeselectAllOrders(), _DeselectAllPosits(), _DeselectAllAlerts(), _DeselectAllExecutions();
                }, this.didGetDataSize = function() {
                    return _self.m_arrData.length;
                }, this.didGetMinMaxAtRange = function(range) {
                    if (void 0 !== range && null != range) {
                        for (var nTDSize = _self.didGetDataSize(), nStartDIdx = range.location, nLoopEnd = nStartDIdx + range.length < nTDSize ? nStartDIdx + range.length : nTDSize, result = {
                            nLIdx: nStartDIdx,
                            nHIdx: nStartDIdx,
                            dHigh: -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE,
                            dLow: 1 * xUtils.constants.default.DEFAULT_WRONG_VALUE
                        }, __dataIndex = nStartDIdx; __dataIndex < nLoopEnd; __dataIndex++) {
                            var __stPrice = _self.didGetDataAt(__dataIndex, !1);
                            if (void 0 !== __stPrice && null !== __stPrice && 0 !== parseInt(__stPrice.close)) {
                                var __high = (xUtils.didConvertToPrice(__stPrice.close), xUtils.didConvertToPrice(__stPrice.open), 
                                xUtils.didConvertToPrice(__stPrice.high)), __low = xUtils.didConvertToPrice(__stPrice.low);
                                result.dHigh < __high && (result.dHigh = __high, result.nHIdx = __dataIndex), result.dLow > __low && (result.dLow = __low, 
                                result.nLIdx = __dataIndex);
                            }
                        }
                        return result;
                    }
                }, this.didDrawExtraObjects = function() {
                    _self.didDrawAskBid(), _self.didDrawTrendLines(), _self.didDrawAlertExecution(), 
                    _self.didDrawOrderPosit(), _self.didDrawHighLowObject();
                }, this.didUpdateAskBidData = function(hide, ask, bid, validFlag) {
                    try {
                        if (void 0 !== hide && null != hide) {
                            _self.didGetEnvInfo().HideAskBid = hide;
                        } else _self.m_xAskBid = {}, _self.m_xAskBid.validFlag = validFlag, _self.m_xAskBid.ask = ask, 
                        _self.m_xAskBid.bid = bid;
                        return !0;
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didDrawAskBid = function() {
                    if (_self.m_xAskBid) {
                        var xEnv = _self.didGetEnvInfo();
                        if (!0 !== xEnv.HideAskBid) {
                            var context = (_self.m_drawWrapper.GetChartFrameAreaRect(), _self.m_context), font = xEnv.Font, drawTextParam = {
                                context: context,
                                pt: {
                                    x: 0,
                                    y: 0
                                },
                                text: "",
                                font: font,
                                fillStyle: "",
                                useMultiline: !1,
                                useBox: !1
                            }, xAxisY = _self.didGetAxisY(), verpos = _self.didGetPointValue(), strAsk = "", strBid = "", nYPosAsk = 0, nYPosBid = 0, rectAsk = {};
                            _self.m_xAskBid.ask && (strAsk = xUtils.number.didGetPointedValue(_self.m_xAskBid.ask, verpos), 
                            drawTextParam.text = strAsk, gxDc.DrawText(drawTextParam, !0, rectAsk), nYPosAsk = xAxisY.GetYPos(_self.m_xAskBid.ask));
                            var rectBid = {};
                            _self.m_xAskBid.bid && (strBid = xUtils.number.didGetPointedValue(_self.m_xAskBid.bid, verpos), 
                            drawTextParam.text = strAsk, gxDc.DrawText(drawTextParam, !0, rectBid), nYPosBid = xAxisY.GetYPos(_self.m_xAskBid.bid));
                            var width = rectAsk.width ? rectAsk.width : 0;
                            width = rectBid.width ? Math.max(rectBid.width, width) : width;
                            var drawTriangleParam = {
                                context: context,
                                pt1: {
                                    x: 0,
                                    y: 0
                                },
                                pt2: {
                                    x: 0,
                                    y: 0
                                },
                                pt3: {
                                    x: 0,
                                    y: 0
                                },
                                lineWidth: 1,
                                lineColor: "",
                                fillColor: ""
                            }, xAxisX = _self.didGetAxisX(), __dataIndex = Math.max(0, _self.didGetDataSize()), xBarInfos = {}, rigthAnchorPos = (xAxisX.GetIndex2Pixel(__dataIndex, xBarInfos), 
                            Math.round(width + xEnv.PriceStyleConfig.AskBid.shapeGap + xEnv.PriceStyleConfig.AskBid.shapeHorzSize + xBarInfos.pos)), shapeHorzSize = xEnv.PriceStyleConfig.AskBid.shapeHorzSize, shapeVertSize = Math.round(xEnv.PriceStyleConfig.AskBid.shapeVertSize / 2);
                            _self.m_xAskBid.ask && (drawTriangleParam.pt2.x = drawTriangleParam.pt3.x = rigthAnchorPos - width - xEnv.PriceStyleConfig.AskBid.shapeGap, 
                            drawTriangleParam.pt1.x = drawTriangleParam.pt2.x - shapeHorzSize, drawTriangleParam.pt1.y = nYPosAsk, 
                            drawTriangleParam.pt2.y = drawTriangleParam.pt1.y - shapeVertSize, drawTriangleParam.pt3.y = drawTriangleParam.pt1.y + shapeVertSize, 
                            drawTriangleParam.lineColor = xEnv.PriceStyleConfig.AskBid.askStrokeColor, drawTriangleParam.fillColor = !0 === _self.m_xAskBid.validFlag ? xEnv.PriceStyleConfig.AskBid.askColor : xEnv.PriceStyleConfig.AskBid.invalidColor, 
                            gxDc.Triangle(drawTriangleParam), drawTextParam.text = strAsk, drawTextParam.pt.x = drawTriangleParam.pt2.x + xEnv.PriceStyleConfig.AskBid.textGap, 
                            drawTextParam.pt.y = nYPosAsk - 1 - shapeVertSize, drawTextParam.fillStyle = drawTriangleParam.fillColor, 
                            gxDc.TextOut(drawTextParam)), _self.m_xAskBid.bid && (drawTriangleParam.pt2.x = drawTriangleParam.pt3.x = rigthAnchorPos - width - xEnv.PriceStyleConfig.AskBid.shapeGap, 
                            drawTriangleParam.pt1.x = drawTriangleParam.pt2.x - shapeHorzSize, drawTriangleParam.pt1.y = nYPosBid, 
                            drawTriangleParam.pt2.y = drawTriangleParam.pt1.y - shapeVertSize, drawTriangleParam.pt3.y = drawTriangleParam.pt1.y + shapeVertSize, 
                            drawTriangleParam.lineColor = xEnv.PriceStyleConfig.AskBid.bidStrokeColor, drawTriangleParam.fillColor = !0 === _self.m_xAskBid.validFlag ? xEnv.PriceStyleConfig.AskBid.bidColor : xEnv.PriceStyleConfig.AskBid.invalidColor, 
                            gxDc.Triangle(drawTriangleParam), drawTextParam.text = strBid, drawTextParam.pt.x = drawTriangleParam.pt2.x + xEnv.PriceStyleConfig.AskBid.textGap, 
                            drawTextParam.pt.y = nYPosBid - 1 + shapeVertSize, drawTextParam.fillStyle = drawTriangleParam.fillColor, 
                            gxDc.TextOut(drawTextParam));
                        }
                    }
                }, this.didDrawTrendLines = function() {
                    for (var xScaleUnit = _self.m_xScaleInfo.current, nLSCount = _self.m_arrTrendlineObjlist.length, ii = 0; ii < nLSCount; ii++) {
                        _self.m_arrTrendlineObjlist[ii].DrawObj(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue);
                    }
                }, this.didDrawSelf = function(posval) {
                    var __nTType = _self.m_symbolInfo.nTType, __nTTGap = _self.m_symbolInfo.nTGap, __xEnv = _self.didGetEnvInfo();
                    if (!0 === __xEnv.System.TickJustLine && __nTType == xUtils.constants.timeType.tick && __nTTGap < 2) _self.DrawLineChart(posval); else switch (__xEnv.ChartType) {
                      case xUtils.constants.chartTypeCode.candle:
                        _self.DrawCandleChart(posval);
                        break;

                      case xUtils.constants.chartTypeCode.transCandle:
                        _self.DrawTransCandleChart(posval);
                        break;

                      case xUtils.constants.chartTypeCode.bar_ohlc:
                        _self.DrawBarOHLCChart(posval);
                        break;

                      case xUtils.constants.chartTypeCode.bar_hlc:
                        _self.DrawBarHLCChart(posval);
                        break;

                      case xUtils.constants.chartTypeCode.line:
                        _self.DrawLineChart(posval);
                        break;

                      case xUtils.constants.chartTypeCode.equiVolume:
                        _self.DrawEquiVolumeChart(posval);
                        break;

                      case xUtils.constants.chartTypeCode.longVolume:
                        _self.DrawLongVolumeChart(posval);
                        break;

                      case xUtils.constants.chartTypeCode.averageCandle:
                        _self.DrawAverageCandleChart(posval);
                        break;

                      case xUtils.constants.chartTypeCode.compareChart:
                        _self.DrawCompareChart(posval);
                        break;

                      default:
                        _self.DrawCandleChart(posval);
                    }
                }, this.didDrawDataView = function(argDtp, argDataIndex) {
                    return argDtp;
                }, this.didDrawDataViewForSubItems = function(argDtp, argDataIndex) {
                    return argDtp;
                }, this.willBeReceivedData = function(symbolInfo, receivedDatas) {
                    return !0;
                }, this.didReceiveData = function(symbolInfo, receivedDatas) {
                    return _self.m_symbolInfo = xUtils.didClone(symbolInfo), _self.m_strChartName = _self.m_symbolInfo.strName, 
                    _self.m_point = _self.m_symbolInfo.nPValCrt, _self.m_symbolInfo.strDispTab && "" != _self.m_symbolInfo.strDispTab && (_self.m_strChartName = _self.m_symbolInfo.strDispTab), 
                    _self.m_arrData = receivedDatas.datas, _self.m_arrTimeData = receivedDatas.times, 
                    _self.m_arrTickNo = receivedDatas.tnos, xUtils.dataConverter.didCalcAverageCandle(_self.m_arrData, !0), 
                    _self.didProcRestAfterReceivingData(), !0;
                }, this.willBeReceivedRealData = function(receivedData) {}, this.didReceiveRealData = function(receivedData) {
                    if (void 0 === receivedData || null == receivedData) return !1;
                    var bAdd = receivedData.isAdd, stPrice = receivedData.stPrice, nDataCount = _self.m_arrData.length;
                    nDataCount < 1 && (nDataCount = 0, bAdd = !0);
                    var nLastIndex = nDataCount - 1;
                    if (!0 === bAdd) {
                        var __priceDatas = receivedData.priceDatas;
                        void 0 !== __priceDatas && null != __priceDatas && __priceDatas.length > 0 && xUtils.didAppendEmptyDatas(_self.m_arrData, _self.m_arrTimeData, _self.m_arrTickNo, __priceDatas);
                        var __stPrice = xUtils.didClone(stPrice);
                        __stPrice.open = __stPrice.high = __stPrice.low = __stPrice.close, _self.m_arrData.push(__stPrice);
                        var __strTimeVal = xUtils.dateTime.convertNumberDatetimeToTimelineData(__stPrice.ymd, __stPrice.hms);
                        _self.m_arrTimeData.push(__strTimeVal);
                        var __tno = 0;
                        if (_self.m_symbolInfo.nTType === xUtils.constants.timeType.tick && nLastIndex > 0) {
                            var preIdx = nLastIndex - 1, preTimeVal = _self.m_arrTimeData[preIdx], preTickNo = _self.m_arrTickNo[preIdx];
                            parseInt(preTimeVal) === parseInt(__strTimeVal) && (__tno = preTickNo + 1);
                        }
                        _self.m_arrTickNo.push(__tno);
                    } else {
                        var __stPrice = xUtils.didClone(stPrice), stLastData = _self.m_arrData[nDataCount - 1];
                        _self.m_arrData[nDataCount - 1] = xUtils.dataConverter.didMergePriceDataWithRealData(stLastData, __stPrice);
                    }
                    return xUtils.dataConverter.didCalcAverageCandle(_self.m_arrData, !1), !0;
                }, this.CreateTrendlineObj = function(lsName, posval, trendLineInfo, skipStore) {
                    return _self.didCreateTrendlineObj(lsName, posval, trendLineInfo, skipStore);
                };
                var _didClearOepaObjects = function(argObjects) {
                    if (void 0 !== argObjects && null != argObjects) {
                        for (var nObjectCount = argObjects.length, ii = nObjectCount - 1; ii >= 0; ii--) argObjects[ii].didDestroy(), 
                        delete argObjects[ii];
                        return argObjects = [], !0;
                    }
                }, _didClearOrderPositObjects = function(argObjects) {
                    return _didClearOepaObjects(argObjects);
                }, _didReceiveOrderPositData = function(isOrderOrPosit, receiveData) {
                    if (void 0 !== receiveData && null != receiveData) {
                        for (var doOPObjects = !0 === isOrderOrPosit ? _self.m_arrOrders : _self.m_arrPosits, nOPCount = doOPObjects.length, ii = 0; ii < nOPCount; ii++) {
                            var doOPObj = doOPObjects[ii];
                            if (void 0 !== doOPObj && null != doOPObj && !0 === doOPObj.didUpdateData(receiveData)) return !0;
                        }
                        return _didAddOrderPositData(isOrderOrPosit, receiveData);
                    }
                }, _didAddOrderPositData = function(isOrderOrPosit, receiveData) {
                    if (void 0 !== receiveData && null != receiveData) {
                        var bOrderOrPosit = isOrderOrPosit, doOPObject = doExtraFactory.didCreateOrderPositObject(bOrderOrPosit, _self.m_chartFrame, _self.m_drawWrapper, _self, receiveData);
                        return void 0 !== doOPObject && null != doOPObject ? (!0 === bOrderOrPosit ? _self.m_arrOrders.push(doOPObject) : _self.m_arrPosits.push(doOPObject), 
                        !0) : void 0;
                    }
                }, _didDrawOrderPositObjects = function(argObjects) {
                    if (void 0 !== argObjects && null != argObjects) for (var xScaleUnit = _self.m_xScaleInfo.current, nObjectCount = argObjects.length, ii = 0; ii < nObjectCount; ii++) argObjects[ii].DrawObj(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue);
                };
                this.didClearOrderPositObjects = function(isOrder, isPosit) {
                    return !0 === isOrder && (_didClearOrderPositObjects(_self.m_arrOrders), _self.m_arrOrders = []), 
                    !0 === isPosit && (_didClearOrderPositObjects(_self.m_arrPosits), _self.m_arrPosits = []), 
                    !0;
                }, this.didDrawOrderPosit = function() {
                    _didDrawOrderPositObjects(_self.m_arrOrders);
                    var doPosits = _self.didGetDoPositions();
                    _didDrawOrderPositObjects(doPosits);
                }, this.willBeReceivedOrderPositData = function(isOrderOrPosit, receivedDatas) {
                    return !0;
                }, this.didReceiveOrderPositData = function(isOrderOrPosit, receivedDatas) {
                    if (void 0 !== receivedDatas && null != receivedDatas) {
                        for (var nRecvLen = receivedDatas.length, ii = 0; ii < nRecvLen; ii++) _didReceiveOrderPositData(isOrderOrPosit, receivedDatas[ii]);
                        return !0;
                    }
                }, this.didSetLoadInfoForTheLineTools = function(argLoadInfos) {
                    if (_self.didClearLineStudyObject(), void 0 === argLoadInfos || null == argLoadInfos) return !0;
                    var xLoadInfos;
                    xLoadInfos = "string" == typeof argLoadInfos ? JSON.parse(argLoadInfos) : argLoadInfos;
                    var xLoadInfo, nCount = 0;
                    if (xLoadInfos.length && xLoadInfos.length > 0 ? (xLoadInfo = xLoadInfos[0], nCount = xLoadInfos.length) : xLoadInfo = xLoadInfos, 
                    void 0 === xLoadInfo || null == xLoadInfo) return !0;
                    _self.didCreateTrendlineObj(xLoadInfo.c, null, xLoadInfo);
                    for (var ii = 1; ii < nCount; ii++) xLoadInfo = xLoadInfos[ii], _self.didCreateTrendlineObj(xLoadInfo.c, null, xLoadInfo);
                    return !0;
                }, this.didGetSaveInfoOfTheLineTools = function() {
                    for (var nCount = _self.m_arrTrendlineObjlist.length, xSaveInfos = {
                        symbol: _self.m_symbolInfo.strCode,
                        lss: []
                    }, ii = 0; ii < nCount; ii++) {
                        var xDoLs = _self.m_arrTrendlineObjlist[ii];
                        try {
                            xDoLs && xDoLs.didGetObjectSaveInfo && xSaveInfos.lss.push(xDoLs.didGetObjectSaveInfo());
                        } catch (e) {
                            console.error(e);
                        }
                    }
                    return xSaveInfos;
                }, this.didGetDisplayTitle = function(isSimple) {
                    return _self.m_strChartName;
                }, this.didGetDataViewDataAtPos = function(argLocalXPos) {
                    var xEnv = _self.didGetEnvInfo();
                    if (!(xEnv.System.NoDisplayAtOutOfArea && argLocalXPos < 0)) {
                        var xViewData = {
                            isPrice: !0,
                            display: _self.didGetDisplayTitle(),
                            datas: []
                        }, dataIndex = _self.GetXIndex(argLocalXPos), stPrice = _self.didGetDataAt(dataIndex, !1), isAvg = xEnv.ChartType === xUtils.constants.chartTypeCode.averageCandle, isValid = !0;
                        void 0 === stPrice || null === stPrice || 0 === stPrice.close ? isValid = !1 : !0 !== isAvg || stPrice.avgClose && stPrice.avgOpen || (isValid = !1);
                        var xData, target, xViewItem = {
                            display: "",
                            value: xUtils.constants.text.dataView.invalid
                        }, xDatetime = _self.m_drawWrapper.didGetTimedataAt(dataIndex, !1, !0), __nTType = _self.m_symbolInfo.nTType;
                        return !0 === isValid ? (xDatetime && (xViewData.dateTime = xDatetime.dateTime), 
                        __nTType == xUtils.constants.timeType.tick ? (xData = xUtils.didClone(xViewItem), 
                        target = "close", xData.display = "TICK", xData.value = xUtils.didGetPriceDisplay(target, stPrice, _self.m_point, !0), 
                        xViewData.datas.push(xData)) : (xData = xUtils.didClone(xViewItem), target = !0 === isAvg ? "avgOpen" : "open", 
                        xData.display = xUtils.didGetDataViewItemTitle(target), xData.value = xUtils.didGetPriceDisplay(target, stPrice, _self.m_point, !0), 
                        xViewData.datas.push(xData), xData = xUtils.didClone(xViewItem), target = "high", 
                        xData.display = xUtils.didGetDataViewItemTitle(target), xData.value = xUtils.didGetPriceDisplay(target, stPrice, _self.m_point, !0), 
                        xViewData.datas.push(xData), xData = xUtils.didClone(xViewItem), target = "low", 
                        xData.display = xUtils.didGetDataViewItemTitle(target), xData.value = xUtils.didGetPriceDisplay(target, stPrice, _self.m_point, !0), 
                        xViewData.datas.push(xData), xData = xUtils.didClone(xViewItem), target = !0 === isAvg ? "avgClose" : "close", 
                        xData.display = xUtils.didGetDataViewItemTitle(target), xData.value = xUtils.didGetPriceDisplay(target, stPrice, _self.m_point, !0), 
                        xViewData.datas.push(xData))) : (xEnv.System.DisplayEmptyInDetailViewWhenInvalid && xDatetime && (xViewData.dateTime = xDatetime.dateTime), 
                        __nTType == xUtils.constants.timeType.tick ? (xData = xUtils.didClone(xViewItem), 
                        target = "close", xData.display = "TICK", xViewData.datas.push(xData)) : (xData = xUtils.didClone(xViewItem), 
                        target = "open", xData.display = xUtils.didGetDataViewItemTitle(target), xViewData.datas.push(xData), 
                        xData = xUtils.didClone(xViewItem), target = "high", xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xViewData.datas.push(xData), xData = xUtils.didClone(xViewItem), target = "low", 
                        xData.display = xUtils.didGetDataViewItemTitle(target), xViewData.datas.push(xData), 
                        xData = xUtils.didClone(xViewItem), target = "close", xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xViewData.datas.push(xData))), xViewData;
                    }
                }, this.DrawLastValue = function(argDrawParam, dataIndex) {
                    try {
                        if (void 0 === argDrawParam || null == argDrawParam) return;
                        _self.didDrawLastValueForOep(argDrawParam, dataIndex);
                    } catch (e) {}
                }, this.didDrawLastValueForOep = function(argDrawParam, dataIndex) {
                    try {
                        if (void 0 === argDrawParam || null == argDrawParam) return;
                        _self.didGetEnvInfo();
                        argDrawParam.axis = _self.didGetAxisY(), function(argDrawParam, dataIndex) {
                            for (var nCount = _self.m_arrAlerts.length, ii = 0; ii < nCount; ii++) {
                                var xDoa = _self.m_arrAlerts[ii];
                                xDoa && xDoa.didDrawLastValue && xDoa.didDrawLastValue(argDrawParam, dataIndex);
                            }
                        }(argDrawParam, dataIndex), function(argDrawParam, dataIndex) {
                            for (var nCount = _self.m_arrOrders.length, ii = 0; ii < nCount; ii++) {
                                var xDoo = _self.m_arrOrders[ii];
                                xDoo && xDoo.didDrawLastValue && xDoo.didDrawLastValue(argDrawParam, dataIndex);
                            }
                        }(argDrawParam, dataIndex), function(argDrawParam, dataIndex) {
                            for (var nCount = _self.m_arrPosits.length, ii = 0; ii < nCount; ii++) {
                                var xDop = _self.m_arrPosits[ii];
                                xDop && xDop.didDrawLastValue && xDop.didDrawLastValue(argDrawParam, dataIndex);
                            }
                        }(argDrawParam, dataIndex);
                    } catch (e) {}
                }, this.didDrawPriceOnFullMode = function(pstDp) {
                    var __nLocalXPos1, __nLocalYPos1, __stPrice1, ncCnt = _self.didGetDataSize();
                    if (ncCnt < 1) return void console.debug("[D] LDPF_DrawPriceOnFullMode : no data\n");
                    var xEnv = _self.didGetEnvInfo(), rcDraw = pstDp.rcDraw;
                    pstDp.margin;
                    xUtils.shapes.InflateRect(rcDraw, 0, -3);
                    for (var nWidth = rcDraw.width, nHeight = rcDraw.height, dMin = 1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, dMax = -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, ii = 0; ii < ncCnt; ii++) {
                        var __stPrice = _self.didGetDataAt(ii, !1);
                        dMin = Math.min(dMin, __stPrice.close), dMax = Math.max(dMax, __stPrice.close);
                    }
                    var dDiff = dMax - dMin, pY = null;
                    if (dDiff < 0) return void console.debug("[D] LDPF_DrawPriceOnFullMode : wrong min(" + dMin + ") & max(" + dMax + ")\n");
                    0 == dDiff && (pY = Math.round(rcDraw.y + rcDraw.height / 2));
                    var nTotalSize = _self.m_drawWrapper.m_xScrollInfo.range.length, dRatioX = nWidth / nTotalSize, dRatioY = nHeight / dDiff, __nScrSize = nTotalSize, __nLoopEnd = __nScrSize, lineWidth = xEnv.PriceStyleConfig.Line.strokeWeight, lineColor = xEnv.PriceStyleConfig.Line.strokeColor, fillColor = lineColor, __context = pstDp.context;
                    __context.translate(.5, .5);
                    var __drawLinesParam = {
                        context: __context,
                        pts: [],
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }, __drawPolygonParam = {
                        context: __context,
                        pt1s: [],
                        pt2s: [],
                        lineWidth: lineWidth,
                        lineColor: lineColor,
                        fillColor: fillColor,
                        fillAlpha: xEnv.TrendlineFillAlpha
                    }, __tempHeight = rcDraw.height + 10;
                    xEnv.ZSBConfig && (__drawPolygonParam.grad = {
                        colors: [ xEnv.ZSBConfig.BgColor2, xEnv.ZSBConfig.BgColor1 ],
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: __tempHeight
                        }
                    }, __drawLinesParam.lineColor = xEnv.ZSBConfig.LineColor);
                    for (var ptStart, ptEnd, bFirst = !0, __nLocalIdx = 0; __nLocalIdx < __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = _self.m_drawWrapper.didConvertLocalIndexToDataIndex(__nLocalIdx, !0), __stPrice1 = _self.didGetDataAt(__dataIndex, !1);
                        if (!0 === xUtils.validator.isValidPrice(__stPrice1)) {
                            __nLocalXPos1 = Math.round(rcDraw.x + dRatioX * __nLocalIdx), __nLocalYPos1 = void 0 !== pY && null != pY ? pY : Math.round(rcDraw.y + rcDraw.height - dRatioY * (__stPrice1.close - dMin));
                            var pt = {
                                x: __nLocalXPos1,
                                y: __nLocalYPos1
                            };
                            bFirst && (ptStart = xUtils.didClone(pt), bFirst = !1), ptEnd = xUtils.didClone(pt), 
                            __drawPolygonParam.pt1s.push(pt), __drawLinesParam.pts.push(pt);
                        }
                    }
                    ptStart && ptEnd && (ptEnd.y = ptStart.y = rcDraw.y + __tempHeight, __drawPolygonParam.pt2s.push(ptStart), 
                    __drawPolygonParam.pt2s.push(ptEnd), gxDc.PolygonGradient(__drawPolygonParam)), 
                    gxDc.Lines(__drawLinesParam), __context.translate(-.5, -.5);
                }, this.didPrintDebugData = function(isAvg) {
                    for (var pointValue = _self.didGetPointValue(), nCount = (Math.pow(pointValue), 
                    _self.m_arrData.length), ii = 0; ii < nCount; ii++) {
                        var stPrice = _self.m_arrData[ii], strPrint = xUtils.number.formatAsfillSize(ii, " ", 5) + ":\t";
                        isAvg ? (stPrice.avgOpen ? strPrint += "avg.o(" + xUtils.didGetPriceDisplay("avgOpen", stPrice, pointValue) + ")," : strPrint += "avg.o(null),", 
                        strPrint += "h(" + xUtils.didGetPriceDisplay("high", stPrice, pointValue) + "),", 
                        strPrint += "l(" + xUtils.didGetPriceDisplay("low", stPrice, pointValue) + "),", 
                        stPrice.avgClose ? strPrint += "avg.c(" + xUtils.didGetPriceDisplay("avgClose", stPrice, pointValue) + ")," : strPrint += "avg.c(null),") : (strPrint += "o(" + xUtils.didGetPriceDisplay("open", stPrice, pointValue) + "),", 
                        strPrint += "h(" + xUtils.didGetPriceDisplay("high", stPrice, pointValue) + "),", 
                        strPrint += "l(" + xUtils.didGetPriceDisplay("low", stPrice, pointValue) + "),", 
                        strPrint += "c(" + xUtils.didGetPriceDisplay("close", stPrice, pointValue) + "),"), 
                        xUtils.debug.log(strPrint);
                    }
                };
                var _didInitHighLowTooltipUnit = function() {
                    var xEnv = _self.didGetEnvInfo();
                    _self.didClearSubObjects();
                    var lsId = xUtils.constants.trendLineCodes.tooltipText, posval = {
                        XPos: 100,
                        YPos: 100
                    };
                    _self.m_xTooltipHigh || (_self.m_xTooltipHigh = _self.CreateTrendlineObj(lsId, posval, null, !0), 
                    _self.m_xTooltipHigh.didSetState({
                        hide: !0,
                        nonTouch: !0
                    }), _self.m_xTooltipHigh.didApplySimpleAttribute(void 0, "High\nText", !0, xEnv.TooltipLabelStyle.background, xEnv.TooltipLabelStyle.lineColor, xEnv.TooltipLabelStyle.fontColor)), 
                    _self.m_xTooltipLow || (_self.m_xTooltipLow = _self.CreateTrendlineObj(lsId, posval, null, !0), 
                    _self.m_xTooltipLow.didSetState({
                        hide: !0,
                        nonTouch: !0
                    }), _self.m_xTooltipLow.didApplySimpleAttribute(void 0, "Low\nText", !1, xEnv.TooltipLabelStyle.background, xEnv.TooltipLabelStyle.lineColor, xEnv.TooltipLabelStyle.fontColor)), 
                    _self.m_xTooltipHigh.didSetState({
                        hide: !1
                    }), _self.m_xTooltipLow.didSetState({
                        hide: !1
                    });
                };
                this.didInitSubObjects = function(chartFrame, drawWrapper) {}, this.didClearSubObjects = function() {
                    _self.m_xTooltipHigh && (_self.m_xTooltipHigh.didDestroy(), _self.m_xTooltipHigh = null), 
                    _self.m_xTooltipLow && (_self.m_xTooltipLow.didDestroy(), _self.m_xTooltipLow = null);
                }, this.didProcRestAfterReceivingData = function() {
                    _didInitHighLowTooltipUnit();
                }, this.didClearSubObjectDatas = function() {
                    _self.m_xAskBid = void 0, _self.m_xTooltipHigh && _self.m_xTooltipHigh.didSetState({
                        hide: !0
                    }), _self.m_xTooltipLow && _self.m_xTooltipLow.didSetState({
                        hide: !0
                    });
                }, this.didConvertDatetimeStringFromPriceData = function(stPrice, timeType) {
                    try {
                        var xEnv = _self.didGetEnvInfo(), date = stPrice.ymd, time = stPrice.hms, retStr = "";
                        return timeType > xUtils.constants.timeType.week ? retStr = xUtils.dateTime.convertNumberToDateString(date, xEnv.LabelFormat.dateFormat3) : timeType > xUtils.constants.timeType.hour ? retStr = xUtils.dateTime.convertNumberToDateString(date, xEnv.LabelFormat.dateFormat2) : timeType > xUtils.constants.timeType.tick ? (retStr = xUtils.dateTime.convertNumberToDateString(date, xEnv.LabelFormat.dateFormat1), 
                        retStr += " " + xUtils.dateTime.convertNumberToTimeString(time, xEnv.LabelFormat.timeFormat1)) : retStr = xUtils.dateTime.convertNumberToTimeString(time, xEnv.LabelFormat.timeFormat0), 
                        retStr;
                    } catch (e) {
                        console.error(e);
                    }
                    return "";
                }, this.didProcForAfterCalculatingMinMax = function() {
                    var xScaleUnit = _self.m_xScaleInfo.current, xHighValue = (_self.didGetAxisX(), 
                    _self.didGetAxisY(), xScaleUnit.minMaxScreen.maxValue), xHighIndex = xScaleUnit.minMaxScreen.maxIndex, stHPrice = _self.didGetDataAt(xHighIndex, !1), xLowValue = xScaleUnit.minMaxScreen.minValue, xLowIndex = xScaleUnit.minMaxScreen.minIndex, stLPrice = _self.didGetDataAt(xLowIndex, !1), __nTType = _self.m_symbolInfo.nTType, verpos = _self.didGetPointValue(), xDataInfo = {
                        datas: {}
                    }, isDwm = xUtils.timeZone.didCheckTimeType(__nTType).isDwm;
                    if (_self.m_xTooltipHigh && stHPrice) {
                        var __strDisp = _self.didConvertDatetimeStringFromPriceData(stHPrice, __nTType);
                        __strDisp += " ", __strDisp += xUtils.number.didGetPointedValue(xHighValue, verpos);
                        var __strTimeVal = xUtils.dateTime.convertNumberDatetimeToTimelineData(stHPrice.ymd, stHPrice.hms);
                        1 == isDwm && (__strTimeVal = xUtils.dateTime.convertNumberDatetimeToTimelineData(stHPrice.ymd, 9e4));
                        var xDiHigh = {
                            x: __strTimeVal,
                            y: xHighValue,
                            t: stHPrice.tno
                        };
                        xDataInfo.datas[1] = xDiHigh, _self.m_xTooltipHigh.didSetDatas(xDataInfo), _self.m_xTooltipHigh.didApplySimpleAttribute(null, __strDisp);
                    }
                    if (_self.m_xTooltipLow && stLPrice) {
                        var __strDisp = _self.didConvertDatetimeStringFromPriceData(stLPrice, __nTType);
                        __strDisp += " ", __strDisp += xUtils.number.didGetPointedValue(xLowValue, verpos);
                        var __strTimeVal = xUtils.dateTime.convertNumberDatetimeToTimelineData(stLPrice.ymd, stLPrice.hms);
                        1 == isDwm && (__strTimeVal = xUtils.dateTime.convertNumberDatetimeToTimelineData(stLPrice.ymd, 9e4));
                        var xDiLow = {
                            x: __strTimeVal,
                            y: xLowValue,
                            t: stLPrice.tno
                        };
                        xDataInfo.datas[1] = xDiLow, _self.m_xTooltipLow.didSetDatas(xDataInfo), _self.m_xTooltipLow.didApplySimpleAttribute(null, __strDisp);
                    }
                }, this.didDrawHighLowObject = function() {
                    if (!0 === _self.didGetEnvInfo().MinMaxTooltipShow) {
                        var xScaleUnit = _self.m_xScaleInfo.current;
                        _self.m_xTooltipHigh && _self.m_xTooltipHigh.DrawObj(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue), 
                        _self.m_xTooltipLow && _self.m_xTooltipLow.DrawObj(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue);
                    }
                }, this.didDrawAlertExecution = function() {
                    _didDrawAlertExecutionObjects(_self.m_arrAlerts);
                    var doExecutions = _self.didGetDoExecutions();
                    _didDrawAlertExecutionObjects(doExecutions);
                };
                var _didDrawAlertExecutionObjects = function(argObjects) {
                    if (void 0 !== argObjects && null != argObjects) for (var xScaleUnit = _self.m_xScaleInfo.current, nObjectCount = argObjects.length, ii = 0; ii < nObjectCount; ii++) argObjects[ii].DrawObj(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue);
                }, _didReceiveAlertExecutionData = function(isAlertOrExecution, receiveData) {
                    if (void 0 !== receiveData && null != receiveData) {
                        for (var doObjects = !0 === isAlertOrExecution ? _self.m_arrAlerts : _self.m_arrExecutions, nCount = doObjects.length, ii = 0; ii < nCount; ii++) {
                            var doObj = doObjects[ii];
                            if (void 0 !== doObj && null != doObj && !0 === doObj.didUpdateData(receiveData)) return !0;
                        }
                        return _didAddAlertExecutionData(isAlertOrExecution, receiveData);
                    }
                }, _didAddAlertExecutionData = function(isAlertOrExecution, receiveData) {
                    if (void 0 !== receiveData && null != receiveData) {
                        var doObject, bAlertOrExecution = isAlertOrExecution;
                        return doObject = 1 == isAlertOrExecution ? doExtraFactory.didCreateAlertObject(_self.m_chartFrame, _self.m_drawWrapper, _self, receiveData) : doExtraFactory.didCreateExecutionObject(_self.m_chartFrame, _self.m_drawWrapper, _self, receiveData), 
                        void 0 !== doObject && null != doObject ? (!0 === bAlertOrExecution ? _self.m_arrAlerts.push(doObject) : _self.m_arrExecutions.push(doObject), 
                        !0) : void 0;
                    }
                };
                this.willBeReceivedAlertExecutionData = function(isAlertOrExecution, receivedDatas) {
                    return !0;
                }, this.didReceiveAlertExecutionData = function(isAlertOrExecution, receivedDatas) {
                    if (void 0 !== receivedDatas && null != receivedDatas) {
                        for (var nRecvLen = receivedDatas.length, ii = 0; ii < nRecvLen; ii++) _didReceiveAlertExecutionData(isAlertOrExecution, receivedDatas[ii]);
                        return !0;
                    }
                }, this.didClearExecutionObjects = function() {
                    return _didClearOepaObjects(_self.m_arrExecutions), _self.m_arrExecutions = [], 
                    !0;
                }, this.didClearAlertObjects = function() {
                    return _didClearOepaObjects(_self.m_arrAlerts), _self.m_arrAlerts = [], !0;
                }, this.didHitTestForAlertObject = function(posval, hitTestTool) {
                    var xSelectedObject;
                    if (void 0 !== _self.m_arrAlerts && null != _self.m_arrAlerts) for (var __nCount = _self.m_arrAlerts.length, ii = __nCount - 1; ii >= 0; ii--) {
                        var doExtraObj = _self.m_arrAlerts[ii];
                        if (xSelectedObject = doExtraObj.didHitTest(posval, hitTestTool)) return xSelectedObject;
                    }
                }, this.didHitTestForExecutionObject = function(posval, hitTestTool) {
                    var xSelectedObject;
                    if (void 0 !== _self.m_arrExecutions && null != _self.m_arrExecutions) {
                        var doExecutions = _didGetDoExtras(_self.m_arrExecutions);
                        if (doExecutions) for (var __nCount = doExecutions.length, ii = __nCount - 1; ii >= 0; ii--) {
                            var doExtraObj = doExecutions[ii];
                            if (xSelectedObject = doExtraObj.didHitTest(posval, hitTestTool)) return xSelectedObject;
                        }
                    }
                };
                var _didGetDoExtras = function(fromDatas, isOutside) {
                    if (fromDatas) {
                        var xScrollInfo = _self.m_drawWrapper.didGetScrollInfo(!0);
                        if (!xScrollInfo) {
                            if (1 == isOutside) return;
                            return fromDatas;
                        }
                        var xAxisX = _self.didGetAxisX(), __nLocalXIdx1 = xAxisX.didConvertLocalIndexToDataIndex(0), __nLocalXIdx2 = xAxisX.didConvertLocalIndexToDataIndex(xScrollInfo.screenSize), __dateTime1 = _self.m_drawWrapper.didGetTimedataAt(__nLocalXIdx1, !1, !0), __dateTime2 = _self.m_drawWrapper.didGetTimedataAt(__nLocalXIdx2, !1, !0);
                        if (!__dateTime1 || !__dateTime2) {
                            if (1 == isOutside) return;
                            return fromDatas;
                        }
                        for (var nDateTime1 = parseInt(__dateTime1.dateTime), nDateTime2 = parseInt(__dateTime2.dateTime), results = [], nCount = fromDatas.length, ii = 0; ii < nCount; ii++) {
                            var doExtra = fromDatas[ii];
                            if (doExtra && doExtra.m_xObjectInfo) {
                                var doDatetime = parseInt(doExtra.m_xObjectInfo.dateTime);
                                1 == isOutside ? (doDatetime < nDateTime1 || nDateTime2 <= doDatetime) && results.push(doExtra) : doDatetime >= nDateTime1 && nDateTime2 > doDatetime && results.push(doExtra);
                            }
                        }
                        return results;
                    }
                };
                this.didGetDoExecutions = function(isOutside) {
                    return _didGetDoExtras(_self.m_arrExecutions, isOutside);
                }, this.didGetDoPositions = function(isOutside) {
                    return _didGetDoExtras(_self.m_arrPosits, isOutside);
                }, this.didGetDoOrdersWithJointId = function(jointId) {
                    if (jointId && !(jointId.length < 1)) {
                        for (var results = [], nCount = _self.m_arrOrders.length, ii = 0; ii < nCount; ii++) {
                            var doOrder = _self.m_arrOrders[ii];
                            doOrder && doOrder.m_xObjectInfo && doOrder.m_xObjectInfo.orderJointId && doOrder.m_xObjectInfo.orderJointId == jointId && results.push(doOrder);
                        }
                        return results;
                    }
                }, this.didCheckPricePos = function(price) {
                    void 0 !== price && null != price || (price = 0);
                    try {
                        return _self.m_xAskBid.ask <= price ? 1 : _self.m_xAskBid.bid >= price ? -1 : 0;
                    } catch (e) {
                        console.error(e);
                    }
                    return 0;
                }, this.DrawLineChart = function(posval) {
                    _self.SetBackgroundCodeName("");
                    var __nLocalXPos1, __nLocalYPos1, __stPrice1, xEnv = _self.didGetEnvInfo(), __nScrSize = (_self.m_drawWrapper.m_xScrollInfo.pos, 
                    _self.m_drawWrapper.m_xScrollInfo.screenSize), __nLoopStart = 0, __nLoopEnd = __nScrSize, __bHitTest = !1, lineColor = _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Line.strokeColor, fillColor = lineColor, __context = _self.m_context;
                    if (void 0 !== posval) {
                        var __dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1) - 3;
                        __nLoopStart = _self.m_drawWrapper.didConvertDataIndexToLocalIndex(__dataIndexAtPos), 
                        __nLoopEnd = __nLoopStart + xUtils.hitTest.config.size, __bHitTest = !0, fillColor = lineColor = xUtils.hitTest.config.color, 
                        __context = _self.m_memcontext;
                    } else !0 === _self.m_bSelect && (fillColor = lineColor = xEnv.System.SelectedFill.lineColor);
                    var __drawLinesParam = {
                        context: __context,
                        pts: [],
                        lineWidth: 1,
                        lineColor: lineColor
                    }, __drawPolygonParam = {
                        context: __context,
                        pt1s: [],
                        pt2s: [],
                        lineWidth: 1,
                        lineColor: lineColor,
                        fillColor: fillColor,
                        fillAlpha: xEnv.TrendlineFillAlpha
                    }, __tempHeight = _self.didGetPanelHeight();
                    xEnv.MiniChartConfig && (__drawPolygonParam.grad = {
                        colors: [ xEnv.MiniChartConfig.BgColor2, xEnv.MiniChartConfig.BgColor1 ],
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: __tempHeight
                        }
                    }, __drawLinesParam.lineColor = xEnv.MiniChartConfig.LineColor);
                    for (var ptStart, ptEnd, bFirst = !0, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), __nLocalIdx = __nLoopStart - 1; __nLocalIdx <= __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = _self.m_drawWrapper.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice1 = _self.didGetDataAt(__dataIndex, !1);
                        if (!0 === xUtils.validator.isValidPrice(__stPrice1)) {
                            var xBarInfos = {};
                            __nLocalXPos1 = xAxisX.GetIndex2Pixel(__dataIndex, xBarInfos), __nLocalYPos1 = xAxisY.GetYPos(__stPrice1.close);
                            var pt = {
                                x: __nLocalXPos1,
                                y: __nLocalYPos1
                            };
                            bFirst && (ptStart = xUtils.didClone(pt), bFirst = !1), ptEnd = xUtils.didClone(pt), 
                            __drawPolygonParam.pt1s.push(pt), __drawLinesParam.pts.push(pt);
                        }
                    }
                    1 != __bHitTest && 1 == xEnv.System.UseForMiniChart && ptStart && ptEnd && (ptEnd.y = ptStart.y = __tempHeight, 
                    __drawPolygonParam.pt2s.push(ptStart), __drawPolygonParam.pt2s.push(ptEnd), gxDc.PolygonGradient(__drawPolygonParam)), 
                    gxDc.Lines(__drawLinesParam);
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOPriceBarCFD = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartDOPriceBase, global.WGC_CHART.chartDOExtraCFD) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1), __webpack_require__(23), __webpack_require__(25));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc, doBaseClass) {
            return function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.m_symbolInfo = {}, 
                this.m_arrData = [], this.m_arrTimeData = [], this.m_arrTickNo = [], this.m_bPrice = !0, 
                this.didInitParams = function() {}, this.didInitVariables = function(strChartName) {
                    _self.m_bMainChart = !0, _self.m_bPriceType = !0, _self.m_strChartName = "";
                }, this.didClearSelfDatas = function() {
                    _self.m_symbolInfo = {}, _self.m_strChartName = "", _self.m_arrTimeData = [], _self.m_arrData = [], 
                    _self.m_arrTickNo = [], _self.didClearSubObjectDatas();
                }, this.didClearOrderPositObjects = function(isOrder, isPosit) {
                    return !1;
                }, this.didClearExecutionObjects = function() {
                    return !1;
                }, this.didClearAlertObjects = function() {
                    return !1;
                }, this.didClearSubObjects = function() {}, this.didClearSubObjectDatas = function() {}, 
                this.didDestroy = function() {
                    _self.didClearLineStudyObject(), _self.didClearOrderPositObjects(!0, !0), _self.didClearExecutionObjects(), 
                    _self.didClearAlertObjects(), _self.didClearSubObjects(), _self.didClearSubObjectDatas();
                }, this.didDrawTrendLines = function() {}, this.didDrawOrderPosit = function() {}, 
                this.didDrawSelf = function(posval) {}, this.didReceiveDataExt = function() {}, 
                this.willBeReceivedData = function(symbolInfo, receivedDatas) {
                    return !0;
                }, this.didReceiveData = function(symbolInfo, receivedDatas) {
                    return !0;
                }, this.didCalculateData = function() {
                    return !0;
                }, this.didCalculateRealData = function(nStart, nDSize, nSSize) {
                    return !0;
                }, this.CreateTrendlineObj = function(lsName, posval) {
                    return null;
                }, this.didCalcMinMax = function(argScrSIdx, argScrSize, argFlag) {
                    var xEnv = _self.didGetEnvInfo(), xScaleUnit = _self.m_xScaleInfo.current;
                    xUtils.scale.didResetScaleUnit(xScaleUnit);
                    for (var __nLocalIdx = 0; __nLocalIdx < argScrSize; __nLocalIdx++) {
                        var __dataIndex = _self.m_drawWrapper.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice = _self.didGetDataAt(__dataIndex, !1);
                        if (void 0 !== __stPrice && null !== __stPrice && 0 !== parseInt(__stPrice.close)) {
                            var __close = xUtils.didConvertToPrice(__stPrice.close), __open = xUtils.didConvertToPrice(__stPrice.open);
                            if (xEnv.ChartType === xUtils.constants.chartTypeCode.averageCandle) {
                                if (!__stPrice.avgClose || !__stPrice.avgOpen) continue;
                                __close = xUtils.didConvertToPrice(__stPrice.avgClose), __open = xUtils.didConvertToPrice(__stPrice.avgOpen);
                            }
                            var __high = xUtils.didConvertToPrice(__stPrice.high), __low = xUtils.didConvertToPrice(__stPrice.low);
                            _self.m_drawWrapper.m_stEnv.ChartType == xUtils.constants.chartTypeCode.line ? (__close > xScaleUnit.minMaxScreen.maxValue && (xScaleUnit.minMaxScreen.maxValue = __close, 
                            xScaleUnit.minMaxScreen.maxIndex = __dataIndex), __close < xScaleUnit.minMaxScreen.minValue && (xScaleUnit.minMaxScreen.minValue = __close, 
                            xScaleUnit.minMaxScreen.minIndex = __dataIndex)) : _self.m_drawWrapper.isNontimeChartType() ? __close > __open ? (__close > xScaleUnit.minMaxScreen.maxValue && (xScaleUnit.minMaxScreen.maxValue = __close, 
                            xScaleUnit.minMaxScreen.maxIndex = __dataIndex), __open < xScaleUnit.minMaxScreen.minValue && (xScaleUnit.minMaxScreen.minValue = __open, 
                            xScaleUnit.minMaxScreen.minIndex = __dataIndex)) : (__open > xScaleUnit.minMaxScreen.maxValue && (xScaleUnit.minMaxScreen.maxValue = __open, 
                            xScaleUnit.minMaxScreen.maxIndex = __dataIndex), __close < xScaleUnit.minMaxScreen.minValue && (xScaleUnit.minMaxScreen.minValue = __close, 
                            xScaleUnit.minMaxScreen.minIndex = __dataIndex)) : (__high > xScaleUnit.minMaxScreen.maxValue && (xScaleUnit.minMaxScreen.maxValue = __high, 
                            xScaleUnit.minMaxScreen.maxIndex = __dataIndex), __low < xScaleUnit.minMaxScreen.minValue && (xScaleUnit.minMaxScreen.minValue = __low, 
                            xScaleUnit.minMaxScreen.minIndex = __dataIndex));
                        }
                    }
                    xScaleUnit.minMaxScreen.diff = xUtils.scale.didCalcDiff(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue), 
                    xUtils.scale.didBackupScaleInfo(_self.m_xScaleInfo), _self.didProcForAfterCalculatingMinMax();
                }, this.didProcForAfterCalculatingMinMax = function() {}, this.didAdjustReverseMinMax = function(xScaleUnit) {}, 
                this.SetBackgroundCodeName = function(strCodeName) {}, this.DrawCompareChart = function(posval) {
                    _self.DrawCandleChart(posval);
                }, this.DrawCandleChart = function(posval) {
                    _self.SetBackgroundCodeName("");
                    var __nLocalXPos, lineColorVal, fillColorVal, __nScrSize = (_self.m_drawWrapper.m_xScrollInfo.pos, 
                    _self.m_drawWrapper.m_xScrollInfo.screenSize), __nLoopStart = 0, __nLoopEnd = __nScrSize, __bHitTest = !1, __context = _self.m_context;
                    if (void 0 !== posval) {
                        var __dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1) - 3;
                        __nLoopStart = _self.m_drawWrapper.didConvertDataIndexToLocalIndex(__dataIndexAtPos), 
                        __nLoopEnd = __nLoopStart + xUtils.hitTest.config.size, __bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                        fillColorVal = xUtils.hitTest.config.color, __context = _self.m_memcontext;
                    }
                    for (var __drawLineParam = {
                        context: __context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: ""
                    }, __drawRectParam = {
                        context: __context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: "",
                        fillColor: ""
                    }, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), xEnv = _self.didGetEnvInfo(), __nLocalIdx = __nLoopStart; __nLocalIdx < __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = xAxisX.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice = _self.didGetDataAt(__dataIndex, !1);
                        if (!0 === xUtils.validator.isValidPrice(__stPrice) && !0 !== xUtils.validator.isFixedPrice(__stPrice, xEnv)) {
                            var xBarInfos = {};
                            __nLocalXPos = xAxisX.GetIndex2Pixel(__dataIndex, xBarInfos);
                            var iYPosOpen = xAxisY.GetYPos(__stPrice.open), iYPosHigh = xAxisY.GetYPos(__stPrice.high), iYPosLow = xAxisY.GetYPos(__stPrice.low), iYPosClose = xAxisY.GetYPos(__stPrice.close);
                            !0 !== __bHitTest && (!0 === _self.m_bSelect ? (lineColorVal = xEnv.System.SelectedFill.lineColor, 
                            fillColorVal = xEnv.System.SelectedFill.fillColor) : (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeDnColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillDnColor, !0 !== xUtils.dataConverter.isMinusCandleForPriceData(__stPrice) && (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeUpColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillUpColor))), __drawLineParam.pt1.x = __nLocalXPos, 
                            __drawLineParam.pt1.y = iYPosHigh, __drawLineParam.pt2.x = __nLocalXPos, __drawLineParam.pt2.y = iYPosLow, 
                            __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam);
                            var rcX, rcY, rcW, rcH;
                            rcX = xBarInfos.pos, rcW = xBarInfos.width, rcY = iYPosOpen, rcH = iYPosClose - rcY, 
                            parseInt(__stPrice.open) == parseInt(__stPrice.close) ? (__drawLineParam.pt1.x = rcX, 
                            __drawLineParam.pt1.y = rcY, __drawLineParam.pt2.x = rcX + rcW, __drawLineParam.pt2.y = rcY, 
                            __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam)) : (__drawRectParam.rect.x = rcX, 
                            __drawRectParam.rect.y = rcY, __drawRectParam.rect.width = rcW, __drawRectParam.rect.height = rcH, 
                            __drawRectParam.lineColor = lineColorVal, __drawRectParam.fillColor = fillColorVal, 
                            gxDc.Rectangle(__drawRectParam));
                        }
                    }
                }, this.DrawAverageCandleChart = function(posval) {
                    _self.SetBackgroundCodeName("");
                    var __nLocalXPos, lineColorVal, fillColorVal, __nScrSize = (_self.m_drawWrapper.m_xScrollInfo.pos, 
                    _self.m_drawWrapper.m_xScrollInfo.screenSize), __nLoopStart = 0, __nLoopEnd = __nScrSize, __bHitTest = !1, __context = _self.m_context;
                    if (void 0 !== posval) {
                        var __dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1) - 3;
                        __nLoopStart = _self.m_drawWrapper.didConvertDataIndexToLocalIndex(__dataIndexAtPos), 
                        __nLoopEnd = __nLoopStart + xUtils.hitTest.config.size, __bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                        fillColorVal = xUtils.hitTest.config.color, __context = _self.m_memcontext;
                    }
                    for (var __drawLineParam = {
                        context: __context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: ""
                    }, __drawRectParam = {
                        context: __context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: "",
                        fillColor: ""
                    }, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), xEnv = _self.didGetEnvInfo(), __nLocalIdx = __nLoopStart; __nLocalIdx < __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = xAxisX.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice = _self.didGetDataAt(__dataIndex, !1);
                        if (!0 === xUtils.validator.isValidPrice(__stPrice, !0) && !0 !== xUtils.validator.isFixedPrice(__stPrice, xEnv)) {
                            var xBarInfos = {};
                            __nLocalXPos = xAxisX.GetIndex2Pixel(__dataIndex, xBarInfos);
                            var __close = __stPrice.avgClose, __open = __stPrice.avgOpen, iYPosOpen = xAxisY.GetYPos(__close), iYPosHigh = xAxisY.GetYPos(__stPrice.high), iYPosLow = xAxisY.GetYPos(__stPrice.low), iYPosClose = xAxisY.GetYPos(__open);
                            !0 !== __bHitTest && (!0 === _self.m_bSelect ? (lineColorVal = xEnv.System.SelectedFill.lineColor, 
                            fillColorVal = xEnv.System.SelectedFill.fillColor) : (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeDnColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillDnColor, !0 !== xUtils.dataConverter.isMinusCandleForPriceData(__stPrice, !0) && (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeUpColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillUpColor))), __drawLineParam.pt1.x = __nLocalXPos, 
                            __drawLineParam.pt1.y = iYPosHigh, __drawLineParam.pt2.x = __nLocalXPos, __drawLineParam.pt2.y = iYPosLow, 
                            __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam);
                            var rcX, rcY, rcW, rcH;
                            rcX = xBarInfos.pos, rcW = xBarInfos.width, rcY = iYPosOpen, rcH = iYPosClose - rcY, 
                            parseInt(__open) == parseInt(__close) ? (__drawLineParam.pt1.x = rcX, __drawLineParam.pt1.y = rcY, 
                            __drawLineParam.pt2.x = rcX + rcW, __drawLineParam.pt2.y = rcY, __drawLineParam.lineColor = lineColorVal, 
                            gxDc.Line(__drawLineParam)) : (__drawRectParam.rect.x = rcX, __drawRectParam.rect.y = rcY, 
                            __drawRectParam.rect.width = rcW, __drawRectParam.rect.height = rcH, __drawRectParam.lineColor = lineColorVal, 
                            __drawRectParam.fillColor = fillColorVal, gxDc.Rectangle(__drawRectParam));
                        }
                    }
                }, this.DrawTransCandleChart = function(posval) {
                    _self.SetBackgroundCodeName("");
                    var __nLocalXPos, lineColorVal, fillColorVal, __nScrSize = (_self.m_drawWrapper.m_xScrollInfo.pos, 
                    _self.m_drawWrapper.m_xScrollInfo.screenSize), __nLoopStart = 0, __nLoopEnd = __nScrSize, __bHitTest = !1, __context = _self.m_context;
                    if (void 0 !== posval) {
                        var __dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1) - 3;
                        __nLoopStart = _self.m_drawWrapper.didConvertDataIndexToLocalIndex(__dataIndexAtPos), 
                        __nLoopEnd = __nLoopStart + xUtils.hitTest.config.size, __bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                        fillColorVal = xUtils.hitTest.config.color, __context = _self.m_memcontext;
                    }
                    for (var __drawLineParam = {
                        context: __context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: ""
                    }, __drawRectParam = {
                        context: __context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: "",
                        fillColor: ""
                    }, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), xEnv = _self.didGetEnvInfo(), __nLocalIdx = __nLoopStart; __nLocalIdx < __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = xAxisX.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice = _self.didGetDataAt(__dataIndex, !1);
                        if (!0 === xUtils.validator.isValidPrice(__stPrice) && !0 !== xUtils.validator.isFixedPrice(__stPrice, xEnv)) {
                            var xBarInfos = {};
                            __nLocalXPos = xAxisX.GetIndex2Pixel(__dataIndex, xBarInfos);
                            var iYPosOpen = xAxisY.GetYPos(__stPrice.open), iYPosHigh = xAxisY.GetYPos(__stPrice.high), iYPosLow = xAxisY.GetYPos(__stPrice.low), iYPosClose = xAxisY.GetYPos(__stPrice.close);
                            if (!0 !== __bHitTest) if (!0 === _self.m_bSelect) lineColorVal = xEnv.System.SelectedFill.lineColor, 
                            fillColorVal = xEnv.System.SelectedFill.fillColor; else {
                                lineColorVal = xEnv.PriceStyleConfig.Candle.strokeDnColor, fillColorVal = xEnv.PriceStyleConfig.Candle.fillDnColor, 
                                !0 !== xUtils.dataConverter.isMinusCandleForPriceData(__stPrice) && (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeUpColor, 
                                fillColorVal = xEnv.PriceStyleConfig.Candle.fillUpColor);
                                var __stPricePre = _self.didGetDataAt(__dataIndex - 1, !1);
                                void 0 !== __stPricePre && null != __stPricePre && (__stPricePre.close < __stPrice.close ? (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeUpColor, 
                                fillColorVal = xEnv.PriceStyleConfig.Candle.fillUpColor) : __stPricePre.close > __stPrice.close && (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeDnColor, 
                                fillColorVal = xEnv.PriceStyleConfig.Candle.fillDnColor));
                            }
                            __drawLineParam.pt1.x = __nLocalXPos, __drawLineParam.pt1.y = iYPosHigh, __drawLineParam.pt2.x = __nLocalXPos, 
                            __drawLineParam.pt2.y = iYPosLow, __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam);
                            var rcX, rcY, rcW, rcH;
                            rcX = xBarInfos.pos, rcW = xBarInfos.width, rcY = iYPosOpen, rcH = iYPosClose - rcY, 
                            parseInt(__stPrice.open) === parseInt(__stPrice.close) ? (__drawLineParam.pt1.x = rcX, 
                            __drawLineParam.pt1.y = rcY, __drawLineParam.pt2.x = rcX + rcW, __drawLineParam.pt2.y = rcY, 
                            __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam)) : (__drawRectParam.rect.x = rcX, 
                            __drawRectParam.rect.y = rcY, __drawRectParam.rect.width = rcW, __drawRectParam.rect.height = rcH, 
                            __drawRectParam.lineColor = lineColorVal, __drawRectParam.fillColor = fillColorVal, 
                            gxDc.Rectangle(__drawRectParam));
                        }
                    }
                }, this.DrawBarOHLCChart = function(posval) {
                    _self.SetBackgroundCodeName("");
                    var __nLocalXPos, lineColorVal, __nScrSize = (_self.m_drawWrapper.m_xScrollInfo.pos, 
                    _self.m_drawWrapper.m_xScrollInfo.screenSize), __nLoopStart = 0, __nLoopEnd = __nScrSize, __bHitTest = !1, __context = _self.m_context;
                    if (void 0 !== posval) {
                        var __dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1) - 3;
                        __nLoopStart = _self.m_drawWrapper.didConvertDataIndexToLocalIndex(__dataIndexAtPos), 
                        __nLoopEnd = __nLoopStart + xUtils.hitTest.config.size, __bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                        __context = _self.m_memcontext;
                    }
                    for (var __drawLineParam = {
                        context: __context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Line.strokeWeight,
                        lineColor: ""
                    }, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), xEnv = _self.didGetEnvInfo(), __nLocalIdx = __nLoopStart; __nLocalIdx < __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = xAxisX.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice = _self.didGetDataAt(__dataIndex, !1);
                        if (!0 === xUtils.validator.isValidPrice(__stPrice) && !0 !== xUtils.validator.isFixedPrice(__stPrice, xEnv)) {
                            var xBarInfos = {};
                            __nLocalXPos = xAxisX.GetIndex2Pixel(__dataIndex, xBarInfos);
                            var iYPosOpen = xAxisY.GetYPos(__stPrice.open), iYPosHigh = xAxisY.GetYPos(__stPrice.high), iYPosLow = xAxisY.GetYPos(__stPrice.low), iYPosClose = xAxisY.GetYPos(__stPrice.close);
                            !0 !== __bHitTest && (!0 === _self.m_bSelect ? lineColorVal = _self.m_drawWrapper.m_stEnv.System.SelectedFill.lineColor : (lineColorVal = _self.m_drawWrapper.m_stEnv.PriceStyleConfig.OHLC.strokeDnColor, 
                            parseInt(__stPrice.open) <= parseInt(__stPrice.close) && (lineColorVal = _self.m_drawWrapper.m_stEnv.PriceStyleConfig.OHLC.strokeUpColor))), 
                            __drawLineParam.pt1.x = __nLocalXPos, __drawLineParam.pt1.y = iYPosHigh, __drawLineParam.pt2.x = __nLocalXPos, 
                            __drawLineParam.pt2.y = iYPosLow, __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam);
                            var rcX, rcY, rcW;
                            rcX = xBarInfos.pos, rcW = xBarInfos.width, rcY = iYPosOpen, iYPosClose - rcY;
                            var iLeftX = rcX, iRightX = rcX + rcW;
                            __drawLineParam.pt1.x = iLeftX, __drawLineParam.pt1.y = iYPosOpen, __drawLineParam.pt2.x = __nLocalXPos, 
                            __drawLineParam.pt2.y = iYPosOpen, gxDc.Line(__drawLineParam), __drawLineParam.pt1.x = iRightX, 
                            __drawLineParam.pt1.y = iYPosClose, __drawLineParam.pt2.x = __nLocalXPos, __drawLineParam.pt2.y = iYPosClose, 
                            gxDc.Line(__drawLineParam);
                        }
                    }
                }, this.DrawBarHLCChart = function(posval) {
                    _self.SetBackgroundCodeName("");
                    var __nLocalXPos, lineColorVal, __nScrSize = (_self.m_drawWrapper.m_xScrollInfo.pos, 
                    _self.m_drawWrapper.m_xScrollInfo.screenSize), __nLoopStart = 0, __nLoopEnd = __nScrSize, __bHitTest = !1, __context = _self.m_context;
                    if (void 0 !== posval) {
                        var __dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1) - 3;
                        __nLoopStart = _self.m_drawWrapper.didConvertDataIndexToLocalIndex(__dataIndexAtPos), 
                        __nLoopEnd = __nLoopStart + xUtils.hitTest.config.size, __bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                        __context = _self.m_memcontext;
                    }
                    for (var __drawLineParam = {
                        context: __context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Line.strokeWeight,
                        lineColor: ""
                    }, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), xEnv = _self.didGetEnvInfo(), __nLocalIdx = __nLoopStart; __nLocalIdx < __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = xAxisX.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice = _self.didGetDataAt(__dataIndex, !1);
                        if (!0 === xUtils.validator.isValidPrice(__stPrice) && !0 !== xUtils.validator.isFixedPrice(__stPrice, xEnv)) {
                            var xBarInfos = {};
                            __nLocalXPos = xAxisX.GetIndex2Pixel(__dataIndex, xBarInfos);
                            var iYPosOpen = xAxisY.GetYPos(__stPrice.open), iYPosHigh = xAxisY.GetYPos(__stPrice.high), iYPosLow = xAxisY.GetYPos(__stPrice.low), iYPosClose = xAxisY.GetYPos(__stPrice.close);
                            !0 !== __bHitTest && (!0 === _self.m_bSelect ? lineColorVal = _self.m_drawWrapper.m_stEnv.System.SelectedFill.lineColor : (lineColorVal = _self.m_drawWrapper.m_stEnv.PriceStyleConfig.OHLC.strokeDnColor, 
                            parseInt(__stPrice.open) <= parseInt(__stPrice.close) && (lineColorVal = _self.m_drawWrapper.m_stEnv.PriceStyleConfig.OHLC.strokeUpColor))), 
                            __drawLineParam.pt1.x = __nLocalXPos, __drawLineParam.pt1.y = iYPosHigh, __drawLineParam.pt2.x = __nLocalXPos, 
                            __drawLineParam.pt2.y = iYPosLow, __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam);
                            var rcX, rcY, rcW;
                            rcX = xBarInfos.pos, rcW = xBarInfos.width, rcY = iYPosOpen, iYPosClose - rcY;
                            var iRightX = rcX + rcW;
                            __drawLineParam.pt1.x = iRightX, __drawLineParam.pt1.y = iYPosClose, __drawLineParam.pt2.x = __nLocalXPos, 
                            __drawLineParam.pt2.y = iYPosClose, gxDc.Line(__drawLineParam);
                        }
                    }
                }, this.DrawLineChart = function(posval) {
                    _self.SetBackgroundCodeName("");
                    var __nLocalXPos1, __nLocalXPos2, __nLocalYPos1, __nLocalYPos2, __stPrice1, __nScrSize = (_self.m_drawWrapper.m_xScrollInfo.pos, 
                    _self.m_drawWrapper.m_xScrollInfo.screenSize), __nLoopStart = 0, __nLoopEnd = __nScrSize, __bHitTest = !1, lineColorVal = _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Line.strokeColor, __context = _self.m_context;
                    if (void 0 !== posval) {
                        var __dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1) - 3;
                        __nLoopStart = _self.m_drawWrapper.didConvertDataIndexToLocalIndex(__dataIndexAtPos), 
                        __nLoopEnd = __nLoopStart + xUtils.hitTest.config.size, __bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                        __context = _self.m_memcontext;
                    }
                    for (var __drawLineParam = {
                        context: __context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Line.strokeWeight,
                        lineColor: lineColorVal
                    }, __nLocalIdx = __nLoopStart; __nLocalIdx < __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = _self.m_drawWrapper.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice1 = _self.didGetDataAt(__dataIndex, !1), __stPrice2 = _self.didGetDataAt(__dataIndex + 1, !1);
                        !0 === xUtils.validator.isValidPrice(__stPrice1) && !0 === xUtils.validator.isValidPrice(__stPrice2) && (__nLocalXPos1 = _self.m_drawWrapper.GetXPosAtDataIndex(__dataIndex), 
                        __nLocalXPos2 = _self.m_drawWrapper.GetXPosAtDataIndex(__dataIndex + 1), __nLocalYPos1 = _self.GetYPos(__stPrice1.close), 
                        __nLocalYPos2 = _self.GetYPos(__stPrice2.close), !0 !== __bHitTest && (lineColorVal = !0 === _self.m_bSelect ? _self.m_drawWrapper.m_stEnv.System.SelectedFill.lineColor : _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Line.strokeColor), 
                        __drawLineParam.pt1.x = __nLocalXPos1, __drawLineParam.pt1.y = __nLocalYPos1, __drawLineParam.pt2.x = __nLocalXPos2, 
                        __drawLineParam.pt2.y = __nLocalYPos2, gxDc.Line(__drawLineParam));
                    }
                }, this.DrawEquiVolumeChart = function(posval) {
                    _self.SetBackgroundCodeName("");
                    var lineColorVal, fillColorVal, __nScrSize = (_self.m_drawWrapper.m_xScrollInfo.pos, 
                    _self.m_drawWrapper.m_xScrollInfo.screenSize), __nLoopStart = 0, __nLoopEnd = __nScrSize, __bHitTest = !1, __context = _self.m_context;
                    if (void 0 !== posval) {
                        var __dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1) - 3;
                        __nLoopStart = _self.m_drawWrapper.didConvertDataIndexToLocalIndex(__dataIndexAtPos), 
                        __nLoopEnd = __nLoopStart + xUtils.hitTest.config.size, __bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                        fillColorVal = xUtils.hitTest.config.color, __context = _self.m_memcontext;
                    }
                    for (var __drawLineParam = {
                        context: __context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: ""
                    }, __drawRectParam = {
                        context: __context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: "",
                        fillColor: ""
                    }, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), xEnv = _self.didGetEnvInfo(), __nLocalIdx = __nLoopStart; __nLocalIdx < __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = xAxisX.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice = _self.didGetDataAt(__dataIndex, !1);
                        if (!0 === xUtils.validator.isValidPrice(__stPrice) && !0 !== xUtils.validator.isFixedPrice(__stPrice, xEnv)) {
                            var xBarInfos = {};
                            xAxisX.GetIndex2Pixel(__dataIndex, xBarInfos);
                            var iYPosOpen = xAxisY.GetYPos(__stPrice.open), iYPosClose = (xAxisY.GetYPos(__stPrice.high), 
                            xAxisY.GetYPos(__stPrice.low), xAxisY.GetYPos(__stPrice.close));
                            !0 !== __bHitTest && (!0 === _self.m_bSelect ? (lineColorVal = xEnv.System.SelectedFill.lineColor, 
                            fillColorVal = xEnv.System.SelectedFill.fillColor) : (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeDnColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillDnColor, parseInt(__stPrice.open) <= parseInt(__stPrice.close) && (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeUpColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillUpColor)));
                            var rcX, rcY, rcW, rcH;
                            rcX = xBarInfos.pos, rcW = xBarInfos.width, rcY = iYPosOpen, rcH = iYPosClose - rcY, 
                            parseInt(__stPrice.open) == parseInt(__stPrice.close) ? (__drawLineParam.pt1.x = rcX, 
                            __drawLineParam.pt1.y = rcY, __drawLineParam.pt2.x = rcX + rcW, __drawLineParam.pt2.y = rcY, 
                            __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam)) : (__drawRectParam.rect.x = rcX, 
                            __drawRectParam.rect.y = rcY, __drawRectParam.rect.width = rcW, __drawRectParam.rect.height = rcH, 
                            __drawRectParam.lineColor = lineColorVal, __drawRectParam.fillColor = fillColorVal, 
                            gxDc.Rectangle(__drawRectParam));
                        }
                    }
                }, this.DrawLongVolumeChart = function(posval) {
                    _self.SetBackgroundCodeName("");
                    var __nLocalXPos, lineColorVal, fillColorVal, __nScrSize = (_self.m_drawWrapper.m_xScrollInfo.pos, 
                    _self.m_drawWrapper.m_xScrollInfo.screenSize), __nLoopStart = 0, __nLoopEnd = __nScrSize, __bHitTest = !1, __context = _self.m_context;
                    if (void 0 !== posval) {
                        var __dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1) - 3;
                        __nLoopStart = _self.m_drawWrapper.didConvertDataIndexToLocalIndex(__dataIndexAtPos), 
                        __nLoopEnd = __nLoopStart + xUtils.hitTest.config.size, __bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                        fillColorVal = xUtils.hitTest.config.color, __context = _self.m_memcontext;
                    }
                    for (var __drawLineParam = {
                        context: __context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: ""
                    }, __drawRectParam = {
                        context: __context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: _self.m_drawWrapper.m_stEnv.PriceStyleConfig.Candle.strokeWeight,
                        lineColor: "",
                        fillColor: ""
                    }, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), xEnv = _self.didGetEnvInfo(), __nLocalIdx = __nLoopStart; __nLocalIdx < __nLoopEnd; __nLocalIdx++) {
                        var __dataIndex = xAxisX.didConvertLocalIndexToDataIndex(__nLocalIdx), __stPrice = _self.didGetDataAt(__dataIndex, !1);
                        if (!0 === xUtils.validator.isValidPrice(__stPrice) && !0 !== xUtils.validator.isFixedPrice(__stPrice, xEnv)) {
                            var xBarInfos = {};
                            __nLocalXPos = xAxisX.GetIndex2Pixel(__dataIndex, xBarInfos);
                            var iYPosOpen = xAxisY.GetYPos(__stPrice.open), iYPosHigh = xAxisY.GetYPos(__stPrice.high), iYPosLow = xAxisY.GetYPos(__stPrice.low), iYPosClose = xAxisY.GetYPos(__stPrice.close);
                            !0 !== __bHitTest && (!0 === _self.m_bSelect ? (lineColorVal = xEnv.System.SelectedFill.lineColor, 
                            fillColorVal = xEnv.System.SelectedFill.fillColor) : (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeDnColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillDnColor, parseInt(__stPrice.open) <= parseInt(__stPrice.close) && (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeUpColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillUpColor))), __drawLineParam.pt1.x = __nLocalXPos, 
                            __drawLineParam.pt1.y = iYPosHigh, __drawLineParam.pt2.x = __nLocalXPos, __drawLineParam.pt2.y = iYPosLow, 
                            __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam);
                            var rcX, rcY, rcW, rcH;
                            rcX = xBarInfos.pos, rcW = xBarInfos.width, rcY = iYPosOpen, rcH = iYPosClose - rcY, 
                            parseInt(__stPrice.open) == parseInt(__stPrice.close) ? (__drawLineParam.pt1.x = rcX, 
                            __drawLineParam.pt1.y = rcY, __drawLineParam.pt2.x = rcX + rcW, __drawLineParam.pt2.y = rcY, 
                            __drawLineParam.lineColor = lineColorVal, gxDc.Line(__drawLineParam)) : (__drawRectParam.rect.x = rcX, 
                            __drawRectParam.rect.y = rcY, __drawRectParam.rect.width = rcW, __drawRectParam.rect.height = rcH, 
                            __drawRectParam.lineColor = lineColorVal, __drawRectParam.fillColor = fillColorVal, 
                            gxDc.Rectangle(__drawRectParam));
                        }
                    }
                }, this.DrawThreeBreakLineChart = function() {}, this.DrawPointFigureChart = function() {}, 
                this.didGetSymbolInfo = function() {
                    return _self.m_symbolInfo;
                }, this.didGetPriceDatas = function(id) {
                    return _self.m_arrData;
                }, this.didGetTimeDatas = function(id) {
                    return _self.m_arrTimeData;
                }, this.didGetTickNos = function(id) {
                    return _self.m_arrTickNo;
                }, this.didCalcVolumeAtRange = function(argRange) {
                    var result = {
                        rangeVolume: 0,
                        fullVolume: 0
                    };
                    if (void 0 === argRange || null == argRange) return result;
                    for (var nCount = _self.m_arrData.length, ii = 0; ii < nCount; ii++) {
                        var stPrice = _self.m_arrData[ii];
                        result.fullVolume += xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.volume);
                    }
                    for (var nLoopEnd = Math.min(nCount, argRange.position + argRange.length), ii = argRange.position; ii < nLoopEnd; ii++) {
                        var stPrice = _self.m_arrData[ii];
                        result.rangeVolume += xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.volume);
                    }
                    return result;
                }, this.didGetDataIndexOfTime = function(strTime, tickNo) {
                    var __timeIndex = void 0;
                    __timeIndex = _self.m_arrTimeData.indexOf(strTime);
                    var nTemp = parseInt(tickNo);
                    return !0 !== isNaN(nTemp) && (__timeIndex += nTemp), __timeIndex;
                }, this.didGetDataAt = function(at, bScreen) {
                    var __nDataCount = 0, __xDatas = _self.m_arrData;
                    void 0 !== __xDatas && null != __xDatas && (__nDataCount = __xDatas.length);
                    var __dataIndex = !0 === bScreen ? _self.didConvertLocalIndexToDataIndex(at) : at;
                    return __nDataCount < 1 || __dataIndex < 0 || __dataIndex >= __nDataCount ? null : __xDatas[__dataIndex];
                }, this.SetThreeBreakLine = function(iIndex, stPrice) {}, this.SetPointFigure = function(iIndex, stPrice) {}, 
                this.GetLastDataIndex = function(nIdx) {
                    return nIdx;
                }, this.didGetAxisX = function() {
                    return _self.m_drawWrapper.didGetAxisX();
                }, this.didGetAxisY = function() {
                    return _self;
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOPriceBase = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartDOContainerBase) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1), __webpack_require__(8));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc, doBaseClass) {
            var _doLsTrendline = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest);
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawLineParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        pt2: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    };
                    gxDc.Line(drawLineParam), _self.didDrawSelectedMark(isHitTest);
                };
            }, _doLsHorizontalLine = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = 0, _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.m_xData2.curPos.x = __xPanelRect.width, _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawLineParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        pt2: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    };
                    gxDc.Line(drawLineParam), _self.didDrawSelectedMark(isHitTest, {
                        isHorz: !0
                    });
                };
            }, _doLsVerticalLine = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData1.curPos.y = 0, _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = __xPanelRect.height;
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawLineParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        pt2: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    };
                    gxDc.Line(drawLineParam), _self.didDrawSelectedMark(isHitTest, {
                        isVert: !0
                    });
                };
            }, _doLsCrossLine = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData1.curPos.y = 0, _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawLineParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        pt2: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    };
                    drawLineParam.pt1.x = 0, drawLineParam.pt1.y = _self.m_xData2.curPos.y, drawLineParam.pt2.x = __xPanelRect.width, 
                    drawLineParam.pt2.y = _self.m_xData2.curPos.y, gxDc.Line(drawLineParam), drawLineParam.pt1.x = _self.m_xData2.curPos.x, 
                    drawLineParam.pt1.y = 0, drawLineParam.pt2.x = _self.m_xData2.curPos.x, drawLineParam.pt2.y = __xPanelRect.height, 
                    gxDc.Line(drawLineParam);
                    var ptCenter = {
                        x: _self.m_xData2.curPos.x,
                        y: _self.m_xData2.curPos.y
                    };
                    _self.didDrawSelectedMark(isHitTest, {
                        targets: [ ptCenter ]
                    });
                };
            }, _doLsRectangle = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest);
                    _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), fillColor = _self.didGetFillColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                    fillColor = _self.m_clrHitTestColor) : (context = _self.m_context, fillColor = lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawRectParam = {
                        context: context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor,
                        fillColor: fillColor,
                        fillAlpha: xEnv.TrendlineFillAlpha
                    };
                    drawRectParam.rect.x = _self.m_xData1.curPos.x, drawRectParam.rect.y = _self.m_xData1.curPos.y, 
                    drawRectParam.rect.width = _self.m_xData2.curPos.x - _self.m_xData1.curPos.x, drawRectParam.rect.height = _self.m_xData2.curPos.y - _self.m_xData1.curPos.y, 
                    gxDc.Rectangle(drawRectParam), _self.didDrawSelectedMark(isHitTest);
                };
            }, _doLsTriangle = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didInitRemainCount = function() {
                    _self.m_nRemainCount = 3;
                }, this.didInitExtraPoint = function() {
                    _self.m_bExtraPoint = !0;
                }, this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest);
                    _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), _self.m_bCreating ? (_self.m_xData3.curPos.x = _self.m_xData2.curPos.x, 
                    _self.m_xData3.curPos.y = _self.m_xData1.curPos.y) : (_self.m_xData3.curPos.x = _self.GetXValToPos(_self.m_xData3.curValue.x, _self.m_xData3.curValue.t), 
                    _self.m_xData3.curPos.y = _self.GetYValToPos(_self.m_xData3.curValue.y));
                    var pt3 = {
                        x: _self.m_xData3.curPos.x,
                        y: _self.m_xData3.curPos.y
                    }, xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), fillColor = _self.didGetFillColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                    fillColor = _self.m_clrHitTestColor) : (context = _self.m_context, fillColor = lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        pt2: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        pt3: pt3,
                        lineWidth: lineWidth,
                        lineColor: lineColor,
                        fillColor: fillColor,
                        fillAlpha: xEnv.TrendlineFillAlpha
                    };
                    gxDc.Triangle(drawParam), _self.didDrawSelectedMark(isHitTest);
                };
            }, _doLsCircle = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest);
                    _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), fillColor = _self.didGetFillColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                    fillColor = _self.m_clrHitTestColor) : (context = _self.m_context, fillColor = lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var __size = {
                        cx: _self.m_xData1.curPos.x - _self.m_xData1.curPos.x,
                        cy: _self.m_xData1.curPos.y - _self.m_xData1.curPos.y
                    }, __radius = Math.round(Math.sqrt(Math.pow(__size.cx, 2) + Math.pow(__size.cy, 2))), __drawCircleParam = {
                        context: context,
                        pt: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        radius: __radius,
                        lineWeight: lineWidth,
                        lineColor: lineColorr,
                        fillColor: fillColor,
                        fillAlpha: xEnv.TrendlineFillAlpha
                    };
                    gxDc.Circle(__drawCircleParam), _self.didDrawSelectedMark(isHitTest);
                };
            }, _doLsFibRetracement = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    for (var iHeight = Math.abs(_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), ratios = [ .618, .5, .382, .236, 0 ], adjustHeights = [], ii = 0; ii < ratios.length; ii++) adjustHeights.push(Math.round(iHeight * ratios[ii]));
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor)), 
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor);
                    var drawLineParam = {
                        context: context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    };
                    drawLineParam.pt1.x = _self.m_xData1.curPos.x, drawLineParam.pt1.y = _self.m_xData1.curPos.y, 
                    drawLineParam.pt2.x = _self.m_xData2.curPos.x, drawLineParam.pt2.y = _self.m_xData2.curPos.y, 
                    gxDc.Line(drawLineParam);
                    var nPosXLeft = 0, nPosYTop = 0, nPosYBottom = 0;
                    _self.m_xData1.curPos.x < _self.m_xData2.curPos.x ? (nPosXLeft = _self.m_xData1.curPos.x, 
                    _self.m_xData2.curPos.x) : (nPosXLeft = _self.m_xData2.curPos.x, _self.m_xData1.curPos.x), 
                    _self.m_xData1.curPos.y < _self.m_xData2.curPos.y ? (nPosYTop = _self.m_xData1.curPos.y, 
                    nPosYBottom = _self.m_xData2.curPos.y) : (nPosYTop = _self.m_xData2.curPos.y, nPosYBottom = _self.m_xData1.curPos.y), 
                    drawLineParam.pt1.x = nPosXLeft, drawLineParam.pt2.x = __xPanelRect.width, drawLineParam.pt1.y = drawLineParam.pt2.y = nPosYTop, 
                    gxDc.Line(drawLineParam);
                    for (var ii = 0; ii < adjustHeights.length; ii++) drawLineParam.pt1.y = drawLineParam.pt2.y = nPosYBottom - adjustHeights[ii], 
                    gxDc.Line(drawLineParam);
                    _self.didDrawSelectedMark(isHitTest);
                };
            }, _doLsFibTimezone = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData1.curPos.y = 0, _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var iXStartIdx, iXIdx, iXPos, arrFiboTime = [ 1, 2, 3, 5, 8, 13, 21, 34, 58, 89, 144, 233, 377, 610, 987 ];
                    iXStartIdx = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(_self.m_xData2.curPos.x, !0);
                    var iTotCount = _self.m_drawWrapper.GetBaseDataCount(), xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    for (var drawLineParam = {
                        context: context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: __xPanelRect.height
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }, ii = 0; ii < arrFiboTime.length && !((iXIdx = iXStartIdx + (arrFiboTime[ii] - 1)) > iTotCount - 1); ii++) {
                        iXPos = _self.m_drawWrapper.GetXPosAtDataIndex(iXIdx);
                        _self.m_drawWrapper.GetXPosAtDataIndex(iXIdx);
                        drawLineParam.pt1.x = drawLineParam.pt2.x = iXPos, gxDc.Line(drawLineParam);
                    }
                    _self.didDrawSelectedMark(isHitTest, {
                        isVert: !0
                    });
                };
            }, _doLsFibFan = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var ratios = [ .618, .5, .382, .236 ], xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawLineParam = {
                        context: context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: __xPanelRect.height
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    };
                    drawLineParam.pt1.x = _self.m_xData1.curPos.x, drawLineParam.pt1.y = _self.m_xData1.curPos.y, 
                    drawLineParam.pt2.x = _self.m_xData2.curPos.x, drawLineParam.pt2.y = _self.m_xData2.curPos.y, 
                    gxDc.Line(drawLineParam);
                    _self.m_xData1.curPos.x < _self.m_xData2.curPos.x ? (_self.m_xData1.curPos.x, _self.m_xData2.curPos.x) : (_self.m_xData2.curPos.x, 
                    _self.m_xData1.curPos.x), _self.m_xData1.curPos.y < _self.m_xData2.curPos.y ? (_self.m_xData1.curPos.y, 
                    _self.m_xData2.curPos.y) : (_self.m_xData2.curPos.y, _self.m_xData1.curPos.y);
                    var nYDiff = _self.m_xData2.curPos.y - _self.m_xData1.curPos.y, nXDiff = Math.abs(_self.m_xData2.curPos.x - _self.m_xData1.curPos.x);
                    if (0 != nXDiff) if (_self.m_xData1.curPos.x < _self.m_xData2.curPos.x) {
                        drawLineParam.pt2.x = __xPanelRect.width;
                        for (var nXDiff1 = Math.abs(_self.m_xData1.curPos.x - drawLineParam.pt2.x), ii = 0; ii < ratios.length; ii++) {
                            var temp1 = _self.m_xData1.curPos.y + nXDiff1 * nYDiff * ratios[ii] / nXDiff;
                            drawLineParam.pt2.y = Math.round(temp1), gxDc.Line(drawLineParam);
                        }
                    } else {
                        drawLineParam.pt2.x = 0;
                        for (var nXDiff1 = Math.abs(_self.m_xData1.curPos.x - drawLineParam.pt2.x), ii = 0; ii < ratios.length; ii++) {
                            var temp1 = _self.m_xData1.curPos.y + nXDiff1 * nYDiff * ratios[ii] / nXDiff;
                            drawLineParam.pt2.y = Math.round(temp1), gxDc.Line(drawLineParam);
                        }
                    }
                    _self.didDrawSelectedMark(isHitTest);
                };
            }, _doLsFibArc = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest);
                    _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = (_self.didGetFillColor(xEnv), 
                    _self.m_nLineWeight), context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                    _self.m_clrHitTestColor) : (context = _self.m_context, lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawLineParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        pt2: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }, drawArcParam = {
                        context: context,
                        pt: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        radius: 0,
                        anticlockwise: !0,
                        degree: {
                            from: 0,
                            to: 0
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }, ratios = [ .618, .5, .382, .236 ];
                    drawLineParam.pt1.x = _self.m_xData1.curPos.x, drawLineParam.pt1.y = _self.m_xData1.curPos.y, 
                    drawLineParam.pt2.x = _self.m_xData2.curPos.x, drawLineParam.pt2.y = _self.m_xData2.curPos.y, 
                    gxDc.Line(drawLineParam);
                    _self.m_xData1.curPos.x < _self.m_xData2.curPos.x ? (_self.m_xData1.curPos.x, _self.m_xData2.curPos.x) : (_self.m_xData2.curPos.x, 
                    _self.m_xData1.curPos.x), _self.m_xData1.curPos.y < _self.m_xData2.curPos.y ? (_self.m_xData1.curPos.y, 
                    _self.m_xData2.curPos.y) : (_self.m_xData2.curPos.y, _self.m_xData1.curPos.y);
                    var nYDiff = _self.m_xData2.curPos.y - _self.m_xData1.curPos.y, nXDiff = _self.m_xData2.curPos.x - _self.m_xData1.curPos.x, nRadius = Math.round(Math.sqrt(Math.pow(nXDiff, 2) + Math.pow(nYDiff, 2)));
                    if (drawArcParam.radius = nRadius, drawArcParam.degree.from = 0, drawArcParam.degree.to = 180, 
                    0 != nXDiff) if (_self.m_xData1.curPos.y < _self.m_xData2.curPos.y) {
                        drawArcParam.anticlockwise = !1;
                        for (var ii = 0; ii < ratios.length; ii++) drawArcParam.radius = Math.round(nRadius * ratios[ii]), 
                        gxDc.Arc(drawArcParam);
                    } else {
                        drawArcParam.anticlockwise = !0;
                        for (var ii = 0; ii < ratios.length; ii++) drawArcParam.radius = Math.round(nRadius * ratios[ii]), 
                        gxDc.Arc(drawArcParam);
                    }
                    _self.didDrawSelectedMark(isHitTest);
                };
            }, _doLsTrenlineByAngle = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest);
                    _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = (_self.didGetFillColor(xEnv), 
                    _self.m_nLineWeight), context = _self.m_context, font = xEnv.Font, radius = (xEnv.FontColor, 
                    30);
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                    _self.m_clrHitTestColor) : (context = _self.m_context, lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        pt2: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }, drawArcParam = {
                        context: context,
                        pt: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        radius: 0,
                        anticlockwise: !0,
                        degree: {
                            from: 0,
                            to: 0
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }, drawTextParam = {
                        context: context,
                        pt: {
                            x: 0,
                            y: 0
                        },
                        text: "",
                        font: font,
                        fillStyle: lineColor
                    };
                    gxDc.Line(drawParam);
                    var nLineLength = Math.sqrt(Math.pow(_self.m_xData2.curPos.x - _self.m_xData1.curPos.x, 2) + Math.pow(_self.m_xData1.curPos.y - _self.m_xData2.curPos.y, 2));
                    drawParam.pt2.x = _self.m_xData1.curPos.x + nLineLength, drawParam.pt2.y = _self.m_xData1.curPos.y, 
                    drawParam.lineStyle = gxDc.penstyle.dash, gxDc.Line(drawParam);
                    var iRad, iAngle, degreeDisplay, anticlockwise = !0, displayUpside = !0;
                    _self.m_xData1.curPos.x <= _self.m_xData2.curPos.x ? _self.m_xData1.curPos.y >= _self.m_xData2.curPos.y ? (iRad = Math.atan2(_self.m_xData1.curPos.y - _self.m_xData2.curPos.y, _self.m_xData2.curPos.x - _self.m_xData1.curPos.x), 
                    iAngle = -180 * iRad / Math.PI, degreeDisplay = -1 * iAngle, anticlockwise = !0, 
                    drawArcParam.degree.from = 0, drawArcParam.degree.to = iAngle, displayUpside = !0) : _self.m_xData1.curPos.y < _self.m_xData2.curPos.y && (iRad = Math.atan2(_self.m_xData2.curPos.y - _self.m_xData1.curPos.y, _self.m_xData2.curPos.x - _self.m_xData1.curPos.x), 
                    iAngle = 180 * iRad / Math.PI, degreeDisplay = iAngle, anticlockwise = !1, drawArcParam.degree.from = 0, 
                    drawArcParam.degree.to = iAngle, displayUpside = !1) : _self.m_xData1.curPos.y >= _self.m_xData2.curPos.y ? (iRad = Math.atan2(_self.m_xData1.curPos.y - _self.m_xData2.curPos.y, _self.m_xData1.curPos.x - _self.m_xData2.curPos.x), 
                    iAngle = -(180 - 180 * iRad / Math.PI), degreeDisplay = -1 * iAngle, anticlockwise = !0, 
                    drawArcParam.degree.from = 0, drawArcParam.degree.to = iAngle, displayUpside = !0) : _self.m_xData1.curPos.y < _self.m_xData2.curPos.y && (iRad = Math.atan2(_self.m_xData2.curPos.y - _self.m_xData1.curPos.y, _self.m_xData1.curPos.x - _self.m_xData2.curPos.x), 
                    iAngle = 180 - 180 * iRad / Math.PI, degreeDisplay = iAngle, anticlockwise = !1, 
                    drawArcParam.degree.from = 0, drawArcParam.degree.to = iAngle, displayUpside = !1);
                    (radius = Math.min(.37 * nLineLength, radius)) >= 3 && (drawArcParam.radius = radius, 
                    drawArcParam.anticlockwise = anticlockwise, gxDc.Arc(drawArcParam));
                    var title = degreeDisplay.toFixed(2).toString(), titleLen = context.measureText(title).width;
                    drawTextParam.text = title, drawTextParam.pt.x = _self.m_xData1.curPos.x + nLineLength - 1.5 * titleLen, 
                    drawTextParam.pt.y = !0 === displayUpside ? _self.m_xData1.curPos.y - 10 : _self.m_xData1.curPos.y + 10, 
                    gxDc.TextOut(drawTextParam), _self.didDrawSelectedMark(isHitTest);
                };
            }, _doLsGanFanUp = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData1.curPos.y = 0, _self.m_xData2.curPos.x = _self.m_xData1.curPos.x, 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    for (var arrGannFan = [], gannFans = [ 1, .5, 1 / 3, .25, 1 / 8, 2, 3, 4, 8 ], nCount = gannFans.length, nBase = __xPanelRect.width - _self.m_xData1.curPos.x, ii = 0; ii < nCount; ii++) {
                        var nHeight = _self.m_xData2.curPos.y - nBase * gannFans[ii];
                        arrGannFan.push(nHeight);
                    }
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    for (var drawLineParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        pt2: {
                            x: __xPanelRect.width,
                            y: 0
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }, ii = 0; ii < arrGannFan.length; ii++) drawLineParam.pt2.y = parseInt(arrGannFan[ii]), 
                    gxDc.Line(drawLineParam);
                    _self.didDrawSelectedMark(isHitTest, {
                        isVertex: !0
                    });
                };
            }, _doLsGanFanDown = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData1.curPos.y = 0, _self.m_xData2.curPos.x = _self.m_xData1.curPos.x, 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    for (var arrGannFan = [], gannFans = [ 1, .5, 1 / 3, .25, 1 / 8, 2, 3, 4, 8 ], nCount = gannFans.length, nBase = __xPanelRect.width - _self.m_xData1.curPos.x, ii = 0; ii < nCount; ii++) {
                        var nHeight = _self.m_xData2.curPos.y + nBase * gannFans[ii];
                        arrGannFan.push(nHeight);
                    }
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    for (var drawLineParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        pt2: {
                            x: __xPanelRect.width,
                            y: 0
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }, ii = 0; ii < arrGannFan.length; ii++) drawLineParam.pt2.y = parseInt(arrGannFan[ii]), 
                    gxDc.Line(drawLineParam);
                    _self.didDrawSelectedMark(isHitTest, {
                        isVertex: !0
                    });
                };
            }, _doLsText = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.m_strText = xUtils.constants.trendLineDefault.text, 
                this.didSetLoadInfoRest = function(argLoadInfo) {
                    return void 0 !== argLoadInfo && null != argLoadInfo && (void 0 !== argLoadInfo.textInfo && null != argLoadInfo.textInfo ? (argLoadInfo.textInfo.text && (_self.m_strText = argLoadInfo.textInfo.text), 
                    !0) : void 0 !== argLoadInfo.t && null != argLoadInfo.t && (_self.m_strText = argLoadInfo.t, 
                    !0));
                }, this.didAppendRestObjectSaveInfo = function(argSaveInfo, isKv) {
                    return void 0 !== argSaveInfo && null != argSaveInfo && (argSaveInfo.t = _self.m_strText, 
                    !0);
                }, this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), _self.m_xData2.curPos.x = _self.m_xData1.curPos.x, 
                    _self.m_xData2.curPos.y = _self.m_xData1.curPos.y;
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context, font = xEnv.Font;
                    _self.didGetFontColor(xEnv);
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                    _self.m_clrHitTestColor) : (context = _self.m_context, lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawRectParam = (_self.m_xData1.curPos.x, _self.m_xData1.curPos.y, __xPanelRect.width, 
                    {
                        context: context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }), drawTextParam = {
                        context: context,
                        pt: {
                            x: 0,
                            y: 0
                        },
                        text: _self.m_strText,
                        font: font,
                        fillStyle: lineColor,
                        useMultiline: !0
                    }, x1CharInfo = gxDc.MeasureDefaultText(context);
                    x1CharInfo.width, x1CharInfo.height;
                    drawTextParam.pt.x = _self.m_xData1.curPos.x, drawTextParam.pt.y = _self.m_xData1.curPos.y;
                    var outRect = {};
                    gxDc.TextOut(drawTextParam, !1, outRect), drawRectParam.rect.x = outRect.x, drawRectParam.rect.y = outRect.y, 
                    drawRectParam.rect.width = outRect.width, drawRectParam.rect.height = outRect.height, 
                    gxDc.Rectangle(drawRectParam), _self.didDrawSelectedMark(isHitTest, {
                        targets: [ {
                            x: outRect.x,
                            y: outRect.y
                        } ]
                    });
                }, this.didApplySimpleAttribute = function(color, text) {
                    return _self.m_clrLineColor = color, _self.m_clrFillColor = color, _self.m_strText = text, 
                    !0;
                }, this.didGetText = function() {
                    return _self.m_strText;
                };
            }, _doLsTooltipText = function() {
                var _self = this;
                this.prototype = new _doLsText(), _doLsText.apply(this, arguments), this.m_bUp = !0, 
                this.didSetState = function(state) {
                    state && (void 0 !== state.nonTouch && null != state.nonTouch && (_self.m_bNonTouch = state.nonTouch), 
                    void 0 !== state.hide && null != state.hide && (_self.hide = state.hide));
                }, this.didGetFontColor = function(xEnv) {
                    return _self.m_clrFontColor;
                }, this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest);
                    _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), _self.m_xData2.curPos.x = _self.m_xData1.curPos.x, 
                    _self.m_xData2.curPos.y = _self.m_xData1.curPos.y;
                    var xEnv = _self.didGetEnvInfo(), lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context, font = xEnv.Font, fontColor = _self.didGetFontColor(xEnv), fillColor = _self.didGetFillColor(xEnv);
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                    fontColor = _self.m_clrHitTestColor, fillColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    fillColor = _self.didGetSelectedColor(_self.m_bSelect, fillColor, xEnv.System.SelectedFill.fillColor), 
                    fontColor = _self.didGetSelectedColor(_self.m_bSelect, fontColor, xEnv.System.SelectedFill.lineColor), 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawTextParam = {
                        context: context,
                        pt: {
                            x: 0,
                            y: 0
                        },
                        text: _self.m_strText,
                        font: font,
                        fillStyle: fontColor,
                        useMultiline: !0,
                        useBox: !1
                    }, drawPolygonParam = {
                        context: context,
                        pt1s: [],
                        pt2s: [],
                        lineWidth: lineWidth,
                        lineColor: lineColor,
                        fillColor: fillColor
                    };
                    drawTextParam.pt.x = _self.m_xData1.curPos.x, drawTextParam.pt.y = _self.m_xData1.curPos.y;
                    var outRect = {}, textRect = {};
                    gxDc.DrawText(drawTextParam, !0, textRect), textRect.x = _self.m_xData1.curPos.x - parseInt(textRect.width / 2), 
                    _self.m_bUp ? textRect.y = _self.m_xData1.curPos.y - 10 - textRect.height : textRect.y = _self.m_xData1.curPos.y + 10;
                    var pt = {
                        x: 0,
                        y: 0
                    };
                    pt.x = textRect.x, pt.y = textRect.y, _self.m_bUp ? (drawPolygonParam.pt1s.push({
                        x: textRect.x,
                        y: textRect.y
                    }), drawPolygonParam.pt1s.push({
                        x: textRect.x + textRect.width,
                        y: textRect.y
                    }), drawPolygonParam.pt1s.push({
                        x: textRect.x + textRect.width,
                        y: textRect.y + textRect.height
                    }), drawPolygonParam.pt1s.push({
                        x: _self.m_xData1.curPos.x + 5,
                        y: textRect.y + textRect.height
                    }), drawPolygonParam.pt1s.push({
                        x: _self.m_xData1.curPos.x,
                        y: textRect.y + textRect.height + 5
                    }), drawPolygonParam.pt1s.push({
                        x: _self.m_xData1.curPos.x - 5,
                        y: textRect.y + textRect.height
                    }), drawPolygonParam.pt1s.push({
                        x: textRect.x,
                        y: textRect.y + textRect.height
                    }), drawPolygonParam.pt1s.push({
                        x: textRect.x,
                        y: textRect.y
                    })) : (drawPolygonParam.pt1s.push({
                        x: textRect.x,
                        y: textRect.y
                    }), drawPolygonParam.pt1s.push({
                        x: _self.m_xData1.curPos.x - 5,
                        y: textRect.y
                    }), drawPolygonParam.pt1s.push({
                        x: _self.m_xData1.curPos.x,
                        y: _self.m_xData1.curPos.y
                    }), drawPolygonParam.pt1s.push({
                        x: _self.m_xData1.curPos.x + 5,
                        y: textRect.y
                    }), drawPolygonParam.pt1s.push({
                        x: textRect.x + textRect.width,
                        y: textRect.y
                    }), drawPolygonParam.pt1s.push({
                        x: textRect.x + textRect.width,
                        y: textRect.y + textRect.height
                    }), drawPolygonParam.pt1s.push({
                        x: textRect.x,
                        y: textRect.y + textRect.height
                    }), drawPolygonParam.pt1s.push({
                        x: textRect.x,
                        y: textRect.y
                    })), drawTextParam.rect = textRect, gxDc.Polygon(drawPolygonParam), gxDc.DrawText(drawTextParam, !1, outRect);
                }, this.didApplySimpleAttribute = function(color, text, bUp, fillColor, lineColor, fontColor) {
                    return void 0 !== color && null != color && (_self.m_clrLineColor = color, _self.m_clrFillColor = color), 
                    void 0 !== fillColor && null != fillColor && (_self.m_clrFillColor = fillColor), 
                    void 0 !== lineColor && null != lineColor && (_self.m_clrLineColor = lineColor), 
                    void 0 !== fontColor && null != fontColor && (_self.m_clrFontColor = fontColor), 
                    void 0 !== text && null != text && (_self.m_strText = text), void 0 !== bUp && null != bUp && (_self.m_bUp = bUp), 
                    !0;
                };
            }, _doLsOrderLine = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = 0, _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), 
                    _self.m_xData2.curPos.x = __xPanelRect.width, _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y);
                    var xEnv = _self.didGetEnvInfo(), font = xEnv.Font, lineColor = _self.didGetLineColor(xEnv), lineWidth = _self.m_nLineWeight, context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                    lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var fontColor = lineColor, drawLineParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        pt2: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    }, drawTextParam = {
                        context: context,
                        pt: {
                            x: 0,
                            y: 0
                        },
                        text: "",
                        font: font,
                        fillStyle: fontColor
                    }, drawRectParam = {
                        context: context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: 1,
                        lineColor: lineColor,
                        fillColor: "#ffffff"
                    };
                    gxDc.Line(drawLineParam);
                    var textRect = gxDc.CalcRect2("", font);
                    drawRectParam.rect.width = textRect.width + 5, drawRectParam.rect.height = textRect.height, 
                    drawRectParam.rect.x = 5, drawRectParam.rect.y = _self.m_xData2.curPos.y - parseInt(textRect.height / 2), 
                    gxDc.Rectangle(drawRectParam), drawTextParam.text = "", drawTextParam.pt.x = 7, 
                    drawTextParam.pt.y = _self.m_xData2.curPos.y, gxDc.TextOut(drawTextParam), _self.didDrawSelectedMark(isHitTest, {
                        isHorz: !0
                    });
                }, this.isAutoDeleteObject = function() {
                    return !0;
                }, this.didGetNewOrderValue = function() {
                    if (_self.m_doParent) {
                        return {
                            symbol: _self.m_doParent.m_symbolInfo,
                            symbolCode: _self.m_doParent.m_symbolInfo.strCode,
                            price: _self.m_xData2.curValue.y
                        };
                    }
                };
            }, _doLsDoubleTrendline = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments), this.didInitRemainCount = function() {
                    _self.m_nRemainCount = 3;
                }, this.didInitExtraPoint = function() {
                    _self.m_bExtraPoint = !0;
                }, this.SetExtraPoint = function(posval, isSet) {
                    if (void 0 !== posval && null != posval) {
                        var __posInPanel = _self.m_chartFrame.GetRelativePositionInPanel(posval.XPos, posval.YPos);
                        _self.m_xData3.curPos.x = _self.m_chartFrame.SetXPosition(__posInPanel.x), _self.m_xData3.curPos.y = __posInPanel.y;
                        var xTimeData;
                        xTimeData = _self.GetXPosToVal(_self.m_xData3.curPos.x), void 0 !== xTimeData && null != xTimeData && (_self.m_xData3.curValue.x = xTimeData.dateTime, 
                        _self.m_xData3.curValue.t = xTimeData.tickNo), _self.m_xData3.curValue.y = _self.GetYPosToVal(_self.m_xData3.curPos.y), 
                        _self.didProcForRemainCount();
                    } else _self.m_xData3.curPos.x = _self.m_xData2.curPos.x, _self.m_xData3.curPos.y = _self.m_xData2.curPos.y + 30, 
                    _self.m_xData3.curValue.x = _self.m_xData2.curValue.x, _self.m_xData3.curValue.y = _self.GetYPosToVal(_self.m_xData3.curPos.y);
                }, this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest);
                    _self.didGetPanelRect();
                    _self.m_xData1.curPos.x = _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t), 
                    _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), _self.m_xData2.curPos.x = _self.GetXValToPos(_self.m_xData2.curValue.x, _self.m_xData2.curValue.t), 
                    _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData2.curValue.y), _self.m_bCreating ? (_self.m_xData3.curPos.x = _self.m_xData2.curPos.x, 
                    _self.m_xData3.curPos.y = _self.m_xData2.curPos.y + 30) : (_self.m_xData3.curPos.x = _self.GetXValToPos(_self.m_xData3.curValue.x, _self.m_xData3.curValue.t), 
                    _self.m_xData3.curPos.y = _self.GetYValToPos(_self.m_xData3.curValue.y));
                    var xEnv = (_self.m_xData3.curPos.x, _self.m_xData3.curPos.y, _self.didGetEnvInfo()), lineColor = _self.didGetLineColor(xEnv), lineWidth = (_self.didGetFillColor(xEnv), 
                    _self.m_nLineWeight), context = _self.m_context;
                    isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                    _self.m_clrHitTestColor) : (context = _self.m_context, lineColor = _self.didGetSelectedColor(_self.m_bSelect, lineColor, xEnv.System.SelectedFill.lineColor));
                    var drawLineParam = {
                        context: context,
                        pt1: {
                            x: _self.m_xData1.curPos.x,
                            y: _self.m_xData1.curPos.y
                        },
                        pt2: {
                            x: _self.m_xData2.curPos.x,
                            y: _self.m_xData2.curPos.y
                        },
                        lineWidth: lineWidth,
                        lineColor: lineColor
                    };
                    gxDc.Line(drawLineParam), drawLineParam.pt1.x = _self.m_xData3.curPos.x - (_self.m_xData2.curPos.x - _self.m_xData1.curPos.x), 
                    drawLineParam.pt1.y = _self.m_xData3.curPos.y - (_self.m_xData2.curPos.y - _self.m_xData1.curPos.y), 
                    drawLineParam.pt2.x = _self.m_xData3.curPos.x, drawLineParam.pt2.y = _self.m_xData3.curPos.y, 
                    gxDc.Line(drawLineParam), 1 != _self.m_bCreating && !0 !== _self.m_bSelect || (drawLineParam.pt1.x = _self.m_xData2.curPos.x, 
                    drawLineParam.pt1.y = _self.m_xData2.curPos.y, drawLineParam.pt2.x = _self.m_xData3.curPos.x, 
                    drawLineParam.pt2.y = _self.m_xData3.curPos.y, drawLineParam.lineColor = xEnv.System.SelectedFill.lineColor, 
                    drawLineParam.lineStyle = gxDc.penstyle.dash, drawLineParam.lineWeight = 1, gxDc.Line(drawLineParam)), 
                    _self.didDrawSelectedMark(isHitTest);
                };
            }, _exports = {};
            return _exports.didCreateLineStudyInstance = function(argCode, argObjectInfo) {
                var doLsLocal = null;
                return argCode === xUtils.constants.trendLineCodes.trendLine ? doLsLocal = new _doLsTrendline() : argCode === xUtils.constants.trendLineCodes.horzLine ? doLsLocal = new _doLsHorizontalLine() : argCode === xUtils.constants.trendLineCodes.vertLine ? doLsLocal = new _doLsVerticalLine() : argCode === xUtils.constants.trendLineCodes.crossLine ? doLsLocal = new _doLsCrossLine() : argCode === xUtils.constants.trendLineCodes.rectangle ? doLsLocal = new _doLsRectangle() : argCode === xUtils.constants.trendLineCodes.triangle ? doLsLocal = new _doLsTriangle() : argCode === xUtils.constants.trendLineCodes.circle ? doLsLocal = new _doLsCircle() : argCode === xUtils.constants.trendLineCodes.trendLineByAngle ? doLsLocal = new _doLsTrenlineByAngle() : argCode === xUtils.constants.trendLineCodes.fiboArc ? doLsLocal = new _doLsFibArc() : argCode === xUtils.constants.trendLineCodes.fiboFan ? doLsLocal = new _doLsFibFan() : argCode === xUtils.constants.trendLineCodes.fiboRetracement ? doLsLocal = new _doLsFibRetracement() : argCode === xUtils.constants.trendLineCodes.fiboTimezone ? doLsLocal = new _doLsFibTimezone() : argCode === xUtils.constants.trendLineCodes.ganFanUp ? doLsLocal = new _doLsGanFanUp() : argCode === xUtils.constants.trendLineCodes.ganFanDown ? doLsLocal = new _doLsGanFanDown() : argCode === xUtils.constants.trendLineCodes.text ? doLsLocal = new _doLsText() : argCode === xUtils.constants.trendLineCodes.orderLine ? doLsLocal = new _doLsOrderLine() : argCode === xUtils.constants.trendLineCodes.tooltipText ? doLsLocal = new _doLsTooltipText() : argCode === xUtils.constants.trendLineCodes.doubleTrendline && (doLsLocal = new _doLsDoubleTrendline()), 
                doLsLocal;
            }, _exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOLineStudies = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartDOLineStudyBase) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1), __webpack_require__(9));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(gxDc, xUtils, doBaseClassFactory, doExtraUnitFactory) {
            var _doOPContainerBase = doBaseClassFactory.didGetBaseExtraContainerClass(), _doOrderContainerBase = doBaseClassFactory.didGetOrderContainerClass(), _doPositContainerBase = doBaseClassFactory.didGetPositContainerClass(), _doOrderContainerCFD = function() {
                var _self = this;
                this.prototype = new _doOrderContainerBase(), _doOrderContainerBase.apply(this, arguments), 
                this.didGetTooltipText = function(isOnly) {
                    if (!0 !== isOnly && _self.m_xObjectInfo.orderJointId && _self.m_doParent && _self.m_doParent.didGetDoOrdersWithJointId) {
                        var jointOrders = _self.m_doParent.didGetDoOrdersWithJointId(_self.m_xObjectInfo.orderJointId);
                        if (jointOrders && jointOrders.length > 0) {
                            for (var jointTooltipText = "", ii = 0; ii < jointOrders.length; ii++) {
                                var doOrder = jointOrders[ii];
                                if (doOrder) {
                                    var toolTipText = doOrder.didGetTooltipText(!0);
                                    toolTipText && (jointTooltipText += toolTipText + "<br/>");
                                }
                            }
                            if (jointTooltipText.length > 0) return jointTooltipText;
                        }
                    }
                    if (_self.m_xObjectInfo) return _self.m_xObjectInfo.toolTipText;
                }, this.didCreateUnit = function(argUnitInfo) {
                    if (void 0 !== _self.m_xObjectInfo && null != _self.m_xObjectInfo && 1 == _self.m_xObjectInfo.correctableFlag && 1 == _self.m_xObjectInfo.cancelableFlag) {
                        return doExtraUnitFactory.didCreateOrderPositUnit(!0, _self.m_chartFrame, _self.m_drawWrapper, _self.m_doParent, _self, argUnitInfo);
                    }
                }, this.didGetJointObjectInfosWithJointId = function() {
                    var doParent = _self.m_doParent;
                    if (doParent && doParent.didGetDoOrdersWithJointId) try {
                        var jointOrders = doParent.didGetDoOrdersWithJointId(_self.m_xObjectInfo.orderJointId);
                        if (jointOrders && jointOrders.length > 0) {
                            for (var jointObjectInfos, nCount = jointOrders.length, ii = 0; ii < nCount; ii++) {
                                var doOrder = jointOrders[ii];
                                doOrder && 1 == doOrder.m_bOrder && doOrder.m_xObjectInfo && (jointObjectInfos || (jointObjectInfos = []), 
                                jointObjectInfos.push(xUtils.didClone(doOrder.m_xObjectInfo)));
                            }
                            return jointObjectInfos;
                        }
                    } catch (e) {
                        console.error(e);
                    }
                };
            }, _doPositContainerCFD = function() {
                var _self = this;
                this.prototype = new _doPositContainerBase(), _doPositContainerBase.apply(this, arguments), 
                this.didGetTooltipText = function() {
                    if (_self.m_xObjectInfo) return _self.m_xObjectInfo.toolTipText;
                }, this.didCreateUnit = function(argUnitInfo) {
                    return doExtraUnitFactory.didCreateOrderPositUnit(!1, _self.m_chartFrame, _self.m_drawWrapper, _self.m_doParent, _self, argUnitInfo);
                }, this.didHitTest = function(posval, hitTestTool, extraDrawParam) {
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) {
                        var result = _self.m_arrUnits[ii].didHitTest(posval, hitTestTool, extraDrawParam);
                        if (void 0 !== result && null != result) return _self;
                    }
                }, this.didDrawObj = function(posval, extraDrawParam) {
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) {
                        var result = _self.m_arrUnits[ii].didDrawObj(posval, extraDrawParam);
                        if (void 0 !== result && null != result) return _self;
                    }
                }, this.DrawObjAtFixedPosX = function(posval, extraDrawParam) {
                    _self.SetBaseSize(), _self.didDrawObj(posval, extraDrawParam);
                };
            }, _doNonOrderBaseCFD = function() {
                var _self = this;
                this.prototype = new _doOPContainerBase(), _doOPContainerBase.apply(this, arguments), 
                this.m_bOrder = !1, this.isAvailableToCreateDummy = function(posval) {
                    return !1;
                }, this.didGetTooltipText = function() {
                    if (_self.m_xObjectInfo) return _self.m_xObjectInfo.toolTipText;
                };
            }, _doAlertContainerCFD = function() {
                var _self = this;
                this.prototype = new _doNonOrderBaseCFD(), _doNonOrderBaseCFD.apply(this, arguments), 
                this.m_bAlert = !0, this.didCreateUnit = function(argUnitInfo) {
                    return doExtraUnitFactory.didCreateAlertUnit(_self.m_chartFrame, _self.m_drawWrapper, _self.m_doParent, _self, argUnitInfo);
                }, this.isAvailableToCreateDummy = function(posval) {
                    if (_self.m_xObjectInfo && 1 == _self.m_xObjectInfo.availableFlag) {
                        if (posval) {
                            for (var nCount = _self.m_arrUnits.length, ii = 0; ii < nCount; ii++) {
                                var xUnit = _self.m_arrUnits[ii];
                                if (xUnit && xUnit.m_bSelect) {
                                    try {
                                        if (Math.abs(xUnit.m_xData1.curPos.y - posval.YPos) > xUtils.constants.chartConfigConstants.OepAmendLimitPixel) return !0;
                                    } catch (e) {}
                                    break;
                                }
                            }
                            return !1;
                        }
                        return !0;
                    }
                    return !1;
                }, this.isAvailableToMoveObject = function() {
                    return !0;
                };
            }, _doExecutionContainerCFD = function() {
                var _self = this;
                this.prototype = new _doNonOrderBaseCFD(), _doNonOrderBaseCFD.apply(this, arguments), 
                this.m_bExecution = !0, this.didCreateUnit = function(argUnitInfo) {
                    return doExtraUnitFactory.didCreateExecutionUnit(_self.m_chartFrame, _self.m_drawWrapper, _self.m_doParent, _self, argUnitInfo);
                }, this.didDrawObj = function(posval, extraDrawParam) {
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) {
                        var result = _self.m_arrUnits[ii].didDrawObj(posval, extraDrawParam);
                        if (void 0 !== result && null != result) return _self;
                    }
                }, this.didHitTest = function(posval, hitTestTool, extraDrawParam) {
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) {
                        var result = _self.m_arrUnits[ii].didHitTest(posval, hitTestTool, extraDrawParam);
                        if (void 0 !== result && null != result) return _self;
                    }
                }, this.DrawObjAtFixedPosX = function(posval, extraDrawParam) {
                    _self.SetBaseSize(), _self.didDrawObj(posval, extraDrawParam);
                };
            }, _exports = {};
            return _exports.didCreateOrderPositObject = function(bOrderOrPosit, chartFrame, drawWrapper, doParent, argObjectInfo) {
                var doLocal = null;
                return doLocal = !0 === bOrderOrPosit ? new _doOrderContainerCFD() : new _doPositContainerCFD(), 
                void 0 !== doLocal.didInitObject && doLocal.didInitObject(chartFrame, drawWrapper, doParent, argObjectInfo), 
                doLocal;
            }, _exports.didCreateAlertObject = function(chartFrame, drawWrapper, doParent, argObjectInfo) {
                var doLocal = null;
                return doLocal = new _doAlertContainerCFD(), void 0 !== doLocal.didInitObject && doLocal.didInitObject(chartFrame, drawWrapper, doParent, argObjectInfo), 
                doLocal;
            }, _exports.didCreateExecutionObject = function(chartFrame, drawWrapper, doParent, argObjectInfo) {
                var doLocal = null;
                return doLocal = new _doExecutionContainerCFD(), void 0 !== doLocal.didInitObject && doLocal.didInitObject(chartFrame, drawWrapper, doParent, argObjectInfo), 
                doLocal;
            }, _exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOExtraCFD = loadModule(global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartUtil, global.WGC_CHART.chartDOOrderPosit, global.WGC_CHART.chartDOExtraUnitCFD) : module.exports = loadModule(__webpack_require__(1), __webpack_require__(0), __webpack_require__(26), __webpack_require__(27));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(gxDc, xUtils, doOPUnitFactory) {
            var _doOPContainerBase = function() {
                var _self = this;
                this.m_doParent = {}, this.m_chartFrame = {}, this.m_chartdraw = {}, this.m_drawWrapper = null, 
                this.m_bOrder = !0, this.m_arrUnits = [], this.m_xDummyUnit = null, this.m_xObjectInfo = {}, 
                this.didCreateUnit = function(argUnitInfo) {
                    return doOPUnitFactory.didCreateOrderPositUnit(_self.m_bOrder, _self.m_chartFrame, _self.m_drawWrapper, _self.m_doParent, _self, argUnitInfo);
                };
                var _didFindUnitById = function(argId) {
                    if (void 0 !== argId && null != argId) for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) {
                        var doUnit = _self.m_arrUnits[ii];
                        if (void 0 !== doUnit && null != doUnit && doUnit.m_xObjectInfo.id === argId) return {
                            object: doUnit,
                            index: ii
                        };
                    }
                }, _didRemoveUnitAtIndex = function(argIndex) {
                    var nUnitCount = _self.m_arrUnits.length;
                    if (!(nUnitCount < 1 || argIndex < 0 || argIndex >= nUnitCount)) return delete _self.m_arrUnits[argIndex], 
                    _self.m_arrUnits.splice(argIndex, 1), !0;
                }, _didCreateDummyObject = function() {
                    if (void 0 !== _self.m_xDummyUnit && null != _self.m_xDummyUnit && (_self.m_xDummyUnit.didDestroy(), 
                    _self.m_xDummyUnit = null), _self.m_arrUnits.length < 1) return !1;
                    var xDoUnit = _self.m_arrUnits[0];
                    return _self.m_xDummyUnit = _self.didCreateUnit(_self.m_xObjectInfo), _self.m_xDummyUnit.m_xData1 = xUtils.didClone(xDoUnit.m_xData1), 
                    _self.m_xDummyUnit.m_xData2 = xUtils.didClone(xDoUnit.m_xData2), _self.m_xDummyUnit.m_xData3 = xUtils.didClone(xDoUnit.m_xData3), 
                    _self.m_xDummyUnit.m_posSelectVal = xUtils.didClone(xDoUnit.m_posSelectVal), _self.m_xDummyUnit.m_bDummyObject = !0, 
                    !0;
                };
                this.DeselectAllObject = function() {
                    for (var nCount = _self.m_arrUnits.length, ii = 0; ii < nCount; ii++) _self.m_arrUnits[ii].m_bSelect = !1;
                }, this.didRemoveUnitById = function(argId) {
                    var unitFound = _didFindUnitById(argId);
                    if (void 0 !== unitFound && null != unitFound) return _didRemoveUnitAtIndex(unitFound.index);
                }, this.didUpdateData = function(receiveData) {
                    if (void 0 !== receiveData && null != receiveData) {
                        var id = receiveData.id, unitFound = _didFindUnitById(id);
                        return void 0 !== unitFound && null != unitFound ? (!0 === receiveData.deleted ? _didRemoveUnitAtIndex(unitFound.index) : unitFound.object.didSetObjectInfo(receiveData), 
                        !0) : void 0;
                    }
                }, this.didInitObject = function(chartFrame, drawWrapper, doParent, argObjectInfo) {
                    _self.m_drawWrapper = drawWrapper, _self.m_doParent = doParent, _self.ReSetFrame(chartFrame), 
                    _self.didSetObjectInfo(argObjectInfo);
                }, this.didSetObjectInfo = function(argObjectInfo) {
                    if (void 0 !== argObjectInfo && null != argObjectInfo) {
                        _self.m_xObjectInfo = xUtils.didClone(argObjectInfo);
                        var doOPUnit = _self.didCreateUnit(_self.m_xObjectInfo);
                        void 0 !== doOPUnit && null != doOPUnit && _self.m_arrUnits.push(doOPUnit);
                    }
                };
                var _didDestroyDummyUnit = function() {
                    void 0 !== _self.m_xDummyUnit && null != _self.m_xDummyUnit && (_self.m_xDummyUnit.didDestroy(), 
                    _self.m_xDummyUnit = null);
                };
                this.didDestroyUnits = function() {
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) _self.m_arrUnits[ii].didDestroy(), 
                    delete _self.m_arrUnits[ii];
                    _self.m_arrUnits = [], _didDestroyDummyUnit();
                }, this.didDestroy = function() {
                    _self.m_doParent = {}, _self.m_chartFrame = {}, _self.m_chartdraw = {}, _self.m_drawWrapper = null, 
                    _self.didDestroyUnits();
                }, this.ReSetFrame = function(chartFrame) {
                    _self.m_chartFrame = chartFrame;
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) _self.m_arrUnits[ii].ReSetFrame(chartFrame);
                }, this.didDrawObj = function(posval) {
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) {
                        var result = _self.m_arrUnits[ii].didDrawObj(posval);
                        if (void 0 !== result && null != result) return _self;
                    }
                }, this.didDrawSelf = function(bHitTest) {}, this.DrawSelectObj = function(posval) {
                    return _self.didDrawObj(posval);
                }, this.didHitTest = function(posval, hitTestTool) {
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) {
                        var result = _self.m_arrUnits[ii].didHitTest(posval, hitTestTool);
                        if (void 0 !== result && null != result) return _self;
                    }
                }, this.DrawObj = function(iMaxPrice, iMinPrice, posval) {
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) _self.m_arrUnits[ii].DrawObj(iMaxPrice, iMinPrice, posval);
                    void 0 !== _self.m_xDummyUnit && null != _self.m_xDummyUnit && _self.m_xDummyUnit.DrawObj(iMaxPrice, iMinPrice);
                }, this.ReceiveData = function() {}, this.SetBaseSize = function() {
                    return !0;
                }, this.isAvailableToCreateDummy = function(posval) {
                    return !1;
                }, this.isAvailableToMoveObject = function() {}, this.SetTrendlineMove = function(posval) {
                    if (!0 === _self.isAvailableToCreateDummy(posval) && (void 0 !== _self.m_xDummyUnit && null != _self.m_xDummyUnit || _didCreateDummyObject(), 
                    void 0 !== _self.m_xDummyUnit && null != _self.m_xDummyUnit)) {
                        _self.m_xDummyUnit.m_strTrendlineName = "Dummy", _self.m_xDummyUnit.SetMovePoint(posval);
                        return _self.didGetEnvInfo().CrossLine.hide = !0, !0;
                    }
                }, this.didStopEditMode = function(posval, argEvent) {
                    var xEnv = _self.didGetEnvInfo();
                    1 != xEnv.System.DontUseAutoShowOepChange && (xEnv.CrossLine.hide = !1);
                    var xOepData = {
                        symbol: _self.m_doParent.m_symbolInfo,
                        symbolCode: _self.m_doParent.m_symbolInfo.strCode
                    };
                    if (void 0 === _self.m_xDummyUnit || null == _self.m_xDummyUnit) {
                        if (!0 !== xEnv.System.UseOneClickOepMode) return;
                        var reflector = _self.m_drawWrapper && _self.m_drawWrapper.m_chartWrapper ? _self.m_drawWrapper.m_chartWrapper : void 0;
                        return void (reflector && _self.m_xObjectInfo && (!0 === _self.m_bOrder && !0 === _self.m_xObjectInfo.cancelableFlag ? reflector.didReflectCallForCancelOrder && (xOepData.event = xUtils.didClone(argEvent), 
                        xOepData.objectInfo = xUtils.didClone(_self.m_xObjectInfo), xOepData.isCancel = !0, 
                        _self.m_drawWrapper.m_chartWrapper.didReflectCallForCancelOrder(xOepData)) : !0 !== _self.m_bOrder && !0 === _self.m_xObjectInfo.checkSettlementFlag && reflector.didReflectCallForExecutionOrder && (xOepData.event = xUtils.didClone(argEvent), 
                        xOepData.objectInfo = xUtils.didClone(_self.m_xObjectInfo), xOepData.isPosit = !0, 
                        _self.m_drawWrapper.m_chartWrapper.didReflectCallForExecutionOrder(xOepData))));
                    }
                    return xOepData.objectInfo = xUtils.didClone(_self.m_xDummyUnit.m_xObjectInfo), 
                    xOepData.isAmend = !0, xOepData.price = _self.m_xDummyUnit.m_xData1.curValue.y, 
                    xOepData.isOrder = _self.m_bOrder, _self.didGetJointObjectInfosWithJointId && (xOepData.jointObjectInfos = _self.didGetJointObjectInfosWithJointId()), 
                    _didDestroyDummyUnit(), xOepData;
                }, this.didGetOepObjectInfo = function() {
                    if (_self.m_doParent) for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) {
                        var xUnit = _self.m_arrUnits[ii];
                        if (xUnit && xUnit.m_bSelect) {
                            var xOepObjectInfo = xUnit.didGetOepObjectInfo();
                            return _self.didGetJointObjectInfosWithJointId && xOepObjectInfo && (xOepObjectInfo.jointObjectInfos = _self.didGetJointObjectInfosWithJointId()), 
                            xOepObjectInfo;
                        }
                    }
                }, this.didGetEnvInfo = function() {
                    return _self.m_doParent.didGetEnvInfo();
                }, this.didDrawLastValue = function(argDrawParam, dataIndex) {
                    for (var nUnitCount = _self.m_arrUnits.length, ii = 0; ii < nUnitCount; ii++) {
                        var xUnit = _self.m_arrUnits[ii];
                        xUnit && xUnit.didDrawLastValue && xUnit.didDrawLastValue(argDrawParam, dataIndex);
                    }
                    _self.m_xDummyUnit && _self.m_xDummyUnit.didDrawLastValue && _self.m_xDummyUnit.didDrawLastValue(argDrawParam, dataIndex);
                };
            }, _doOrderContainer = function() {
                var _self = this;
                this.prototype = new _doOPContainerBase(), _doOPContainerBase.apply(this, arguments), 
                this.m_bOrder = !0, this.isAvailableToCreateDummy = function(posval) {
                    if (_self.m_xObjectInfo && !0 === _self.m_xObjectInfo.correctableFlag) {
                        if (posval) {
                            for (var nCount = _self.m_arrUnits.length, ii = 0; ii < nCount; ii++) {
                                var xUnit = _self.m_arrUnits[ii];
                                if (xUnit && xUnit.m_bSelect) {
                                    try {
                                        if (Math.abs(xUnit.m_xData1.curPos.y - posval.YPos) > xUtils.constants.chartConfigConstants.OepAmendLimitPixel) return !0;
                                    } catch (e) {}
                                    break;
                                }
                            }
                            return !1;
                        }
                        return !0;
                    }
                    return !1;
                }, this.isAvailableToMoveObject = function() {
                    return !0;
                };
            }, _doPositContainer = function() {
                this.prototype = new _doOPContainerBase(), _doOPContainerBase.apply(this, arguments), 
                this.m_bOrder = !1, this.isAvailableToCreateDummy = function(posval) {
                    return !1;
                };
            }, _exports = {};
            return _exports.didCreateOrderPositObject = function(bOrderOrPosit, chartFrame, drawWrapper, doParent, argObjectInfo) {
                var doLocal = null;
                return doLocal = !0 === bOrderOrPosit ? new _doOrderContainer() : new _doPositContainer(), 
                void 0 !== doLocal.didInitObject && doLocal.didInitObject(chartFrame, drawWrapper, doParent, argObjectInfo), 
                doLocal;
            }, _exports.didGetBaseExtraContainerClass = function() {
                return _doOPContainerBase;
            }, _exports.didGetOrderContainerClass = function() {
                return _doOrderContainer;
            }, _exports.didGetPositContainerClass = function() {
                return _doPositContainer;
            }, _exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOOrderPosit = loadModule(global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartUtil, global.WGC_CHART.chartDOOrderPositUnit) : module.exports = loadModule(__webpack_require__(1), __webpack_require__(0), __webpack_require__(10));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc, doBaseClassFactory) {
            var _doOPUnitBase = doBaseClassFactory.didGetBaseExtraUnitClass(), _doOpeaUnitBaseCFD = function() {
                var _self = this;
                this.prototype = new _doOPUnitBase(), _doOPUnitBase.apply(this, arguments), this.didDrawLastValue = function(argDrawParam, dataIndex) {
                    if (_self.m_bDummyObject) {
                        if (void 0 === argDrawParam || null == argDrawParam) return;
                        var xEnv = _self.didGetEnvInfo();
                        argDrawParam.price = {}, argDrawParam.price.verpos = _self.didGetPointValue(), argDrawParam.price.value = _self.m_xData1.curValue.y;
                        var xStyleInfo = _self.didGetStyleInfo();
                        void 0 !== xStyleInfo && null != xStyleInfo && (_self.m_bSelect && 1 == xEnv.UseOepSelectedColor ? argDrawParam.price.color = xEnv.System.SelectedFill.lineColor : !0 === _self.m_xObjectInfo.ask ? void 0 === xStyleInfo.ask.cloneColor || null == xStyleInfo.ask.cloneColor ? argDrawParam.price.color = xStyleInfo.ask.strokeColor : argDrawParam.price.color = xStyleInfo.ask.cloneColor : !1 === _self.m_xObjectInfo.ask ? void 0 === xStyleInfo.bid.cloneColor || null == xStyleInfo.bid.cloneColor ? argDrawParam.price.color = xStyleInfo.bid.strokeColor : argDrawParam.price.color = xStyleInfo.bid.cloneColor : argDrawParam.price.color = xStyleInfo.default.strokeColor), 
                        xUtils.axis.didDrawLastValueOnYAxis(argDrawParam);
                    }
                };
            }, _doOpeaLineUnitBaseCFD = function() {
                var _self = this;
                this.prototype = new _doOpeaUnitBaseCFD(), _doOpeaUnitBaseCFD.apply(this, arguments), 
                this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    if (_self.m_xData1.curPos.x = 0, _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = __xPanelRect.width, _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_bDummyObject, !(_self.m_xData1.curPos.y < 0 || _self.m_xData1.curPos.y > __xPanelRect.height)) {
                        var context = _self.m_context, lineColor = (_self.m_drawWrapper.m_stEnv.Font, _self.m_clrLineColor), lineWidth = _self.m_nLineWeight, lineStyle = _self.m_nLineStyle, xStyleInfo = _self.didGetStyleInfo();
                        void 0 !== xStyleInfo && null != xStyleInfo && (!0 === _self.m_bDummyObject ? (lineColor = xStyleInfo.dummy.strokeColor, 
                        lineWidth = xStyleInfo.dummy.strokeWeight, lineStyle = xStyleInfo.dummy.strokeStyle, 
                        !0 === _self.m_xObjectInfo.ask ? lineColor = void 0 === xStyleInfo.ask.cloneColor || null == xStyleInfo.ask.cloneColor ? xStyleInfo.ask.strokeColor : xStyleInfo.ask.cloneColor : !1 === _self.m_xObjectInfo.ask && (lineColor = void 0 === xStyleInfo.bid.cloneColor || null == xStyleInfo.bid.cloneColor ? xStyleInfo.bid.strokeColor : xStyleInfo.bid.cloneColor)) : !0 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.ask.strokeColor, 
                        lineWidth = xStyleInfo.ask.strokeWeight, lineStyle = xStyleInfo.ask.strokeStyle) : !1 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.bid.strokeColor, 
                        lineWidth = xStyleInfo.bid.strokeWeight, lineStyle = xStyleInfo.bid.strokeStyle) : (lineColor = xStyleInfo.default.strokeColor, 
                        lineWidth = xStyleInfo.default.strokeWeight, lineStyle = xStyleInfo.default.strokeStyle));
                        var xEnv = _self.didGetEnvInfo();
                        isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                        _self.m_bSelect && 1 == xEnv.UseOepSelectedColor && (lineColor = xEnv.System.SelectedFill.lineColor));
                        var drawLineParam = {
                            context: context,
                            pt1: {
                                x: _self.m_xData1.curPos.x,
                                y: _self.m_xData1.curPos.y
                            },
                            pt2: {
                                x: _self.m_xData2.curPos.x,
                                y: _self.m_xData2.curPos.y
                            },
                            lineWidth: lineWidth,
                            lineColor: lineColor,
                            lineStyle: lineStyle
                        }, ptMark = {
                            x: 0,
                            y: _self.m_xData2.curPos.y
                        };
                        if (_self.m_xObjectInfo.extraPrice && 1 != _self.m_bDummyObject && (ptMark.y = drawLineParam.pt2.y = drawLineParam.pt1.y = _self.GetYValToPos(_self.m_xObjectInfo.extraPrice)), 
                        gxDc.Line(drawLineParam), !0 !== isHitTest) {
                            var iXPos = _self.didGetPanelHalfWidth(), pts = [ {
                                x: iXPos,
                                y: ptMark.y
                            } ];
                            _self.DrawSelectionMark(pts);
                        }
                    }
                };
            }, _doOpeaMarkUnitBaseCFD = function() {
                var _self = this;
                this.prototype = new _doOpeaUnitBaseCFD(), _doOpeaUnitBaseCFD.apply(this, arguments), 
                this.didDrawSelf = function(bHitTest) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    if (_self.m_xData1.curPos.x = 0, _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = __xPanelRect.width, _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_bDummyObject, !(_self.m_xData1.curPos.y < 0 || _self.m_xData1.curPos.y > __xPanelRect.height)) {
                        var pt1 = {
                            x: _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t),
                            y: _self.GetYValToPos(_self.m_xData1.curValue.y)
                        }, context = _self.m_context, lineColor = (_self.m_drawWrapper.m_stEnv.Font, _self.m_clrLineColor), lineWidth = _self.m_nLineWeight, xStyleInfo = (_self.m_nLineStyle, 
                        _self.didGetStyleInfo()), bFill = !0;
                        void 0 !== xStyleInfo && null != xStyleInfo && (!0 === _self.m_bDummyObject ? (lineColor = xStyleInfo.dummy.strokeColor, 
                        lineWidth = xStyleInfo.dummy.strokeWeight, xStyleInfo.dummy.strokeStyle, !0 === _self.m_xObjectInfo.ask ? lineColor = xStyleInfo.ask.strokeColor : !1 === _self.m_xObjectInfo.ask && (lineColor = xStyleInfo.bid.strokeColor)) : !0 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.ask.strokeColor, 
                        lineWidth = xStyleInfo.ask.strokeWeight, xStyleInfo.ask.strokeStyle) : !1 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.bid.strokeColor, 
                        lineWidth = xStyleInfo.bid.strokeWeight, xStyleInfo.bid.strokeStyle) : (lineColor = xStyleInfo.default.strokeColor, 
                        lineWidth = xStyleInfo.default.strokeWeight, xStyleInfo.default.strokeStyle), !0 === xStyleInfo.noFill && (bFill = !1));
                        var xEnv = _self.didGetEnvInfo();
                        isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor) : (context = _self.m_context, 
                        _self.m_bSelect && 1 == xEnv.UseOepSelectedColor && (lineColor = xEnv.System.SelectedFill.lineColor));
                        var fillColor = 1 == bFill ? lineColor : void 0, drawParam = {
                            context: context,
                            pt1: pt1,
                            pt2: {
                                x: 0,
                                y: 0
                            },
                            pt3: {
                                x: 0,
                                y: 0
                            },
                            lineWidth: lineWidth,
                            lineColor: lineColor,
                            fillColor: fillColor
                        };
                        if (1 != _self.m_xObjectInfo.ask ? (drawParam.pt2.x = pt1.x - 5, drawParam.pt2.y = pt1.y + 5, 
                        drawParam.pt3.x = pt1.x + 5, drawParam.pt3.y = pt1.y + 5) : (drawParam.pt2.x = pt1.x - 5, 
                        drawParam.pt2.y = pt1.y - 5, drawParam.pt3.x = pt1.x + 5, drawParam.pt3.y = pt1.y - 5), 
                        gxDc.Triangle(drawParam), !0 !== isHitTest) {
                            _self.didGetPanelHalfWidth();
                        }
                    }
                };
            }, _doOrderUnitCFD = function() {
                var _self = this;
                this.prototype = new _doOpeaLineUnitBaseCFD(), _doOpeaLineUnitBaseCFD.apply(this, arguments), 
                this.m_bOrder = !0, this.didGetStyleInfo = function() {
                    return _self.m_drawWrapper.m_stEnv.OrderStyleConfig;
                };
            }, _doPositUnitCFD = function() {
                var _self = this;
                this.prototype = new _doOpeaMarkUnitBaseCFD(), _doOpeaMarkUnitBaseCFD.apply(this, arguments), 
                this.m_bOrder = !1, this.didGetStyleInfo = function() {
                    return _self.m_drawWrapper.m_stEnv.PositStyleConfig;
                }, this.didDrawSelf = function(bHitTest, extraDrawParam) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    if (_self.m_xData1.curPos.x = 0, _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = __xPanelRect.width, _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_bDummyObject, !(_self.m_xData1.curPos.y < 0 || _self.m_xData1.curPos.y > __xPanelRect.height)) {
                        var pt1 = {
                            x: _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t),
                            y: _self.GetYValToPos(_self.m_xData1.curValue.y)
                        }, bSelect = _self.m_bSelect;
                        extraDrawParam && 1 == extraDrawParam.offSelect && (bSelect = !1);
                        var context = _self.m_context, lineColor = (_self.m_drawWrapper.m_stEnv.Font, _self.m_clrLineColor), lineWidth = _self.m_nLineWeight, fillColor = (_self.m_nLineStyle, 
                        lineColor), xStyleInfo = _self.didGetStyleInfo(), bFill = !0, lineColor2 = _self.m_clrLineColor;
                        void 0 !== xStyleInfo && null != xStyleInfo && (!0 === _self.m_bDummyObject ? (lineColor = xStyleInfo.dummy.strokeColor, 
                        lineWidth = xStyleInfo.dummy.strokeWeight, xStyleInfo.dummy.strokeStyle, lineColor2 = lineColor, 
                        !0 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.ask.strokeColor, lineColor2 = xStyleInfo.ask.strokeColor2) : !1 === _self.m_xObjectInfo.ask && (lineColor = xStyleInfo.bid.strokeColor, 
                        lineColor2 = xStyleInfo.bid.strokeColor2)) : !0 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.ask.strokeColor, 
                        lineWidth = xStyleInfo.ask.strokeWeight, xStyleInfo.ask.strokeStyle, lineColor2 = xStyleInfo.ask.strokeColor2) : !1 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.bid.strokeColor, 
                        lineWidth = xStyleInfo.bid.strokeWeight, xStyleInfo.bid.strokeStyle, lineColor2 = xStyleInfo.bid.strokeColor2) : (lineColor = xStyleInfo.default.strokeColor, 
                        lineWidth = xStyleInfo.default.strokeWeight, xStyleInfo.default.strokeStyle, lineColor2 = lineColor), 
                        !0 === xStyleInfo.noFill && (bFill = !1));
                        var xEnv = _self.didGetEnvInfo();
                        isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                        lineColor2 = lineColor) : (context = _self.m_context, bSelect && 1 == xEnv.UseOepSelectedColor && (lineColor = xEnv.System.SelectedFill.lineColor, 
                        lineColor2 = lineColor)), extraDrawParam && (context = isHitTest ? extraDrawParam.memcontext : extraDrawParam.context, 
                        pt1.x = extraDrawParam.pt.x);
                        var fillColor = 1 == bFill ? lineColor : void 0, fillColor2 = 1 == bFill ? lineColor2 : void 0, drawParam = {
                            context: context,
                            pt1: pt1,
                            pt2: {
                                x: 0,
                                y: 0
                            },
                            pt3: {
                                x: 0,
                                y: 0
                            },
                            lineWidth: lineWidth,
                            lineColor: lineColor,
                            fillColor: fillColor
                        }, triHalfWidth = 7, triHeight = 12;
                        if (1 != _self.m_xObjectInfo.ask ? (drawParam.pt2.x = pt1.x - triHalfWidth, drawParam.pt2.y = pt1.y + triHeight, 
                        drawParam.pt3.x = pt1.x + triHalfWidth, drawParam.pt3.y = pt1.y + triHeight) : (drawParam.pt2.x = pt1.x - triHalfWidth, 
                        drawParam.pt2.y = pt1.y - triHeight, drawParam.pt3.x = pt1.x + triHalfWidth, drawParam.pt3.y = pt1.y - triHeight), 
                        gxDc.Triangle(drawParam), triHalfWidth -= lineWidth, triHeight -= 2 * lineWidth, 
                        1 != _self.m_xObjectInfo.ask ? (pt1.y += lineWidth + 1, drawParam.pt1.y = pt1.y, 
                        drawParam.pt2.x = pt1.x - triHalfWidth, drawParam.pt2.y = pt1.y + triHeight, drawParam.pt3.x = pt1.x + triHalfWidth, 
                        drawParam.pt3.y = pt1.y + triHeight) : (pt1.y -= lineWidth + 1, drawParam.pt1.y = pt1.y, 
                        drawParam.pt2.x = pt1.x - triHalfWidth, drawParam.pt2.y = pt1.y - triHeight, drawParam.pt3.x = pt1.x + triHalfWidth, 
                        drawParam.pt3.y = pt1.y - triHeight), drawParam.lineColor = lineColor2, drawParam.fillColor = fillColor2, 
                        gxDc.Triangle(drawParam), !0 !== isHitTest) {
                            _self.didGetPanelHalfWidth(), pt1.x, pt1.y;
                        }
                    }
                };
            }, _doAlertUnitCFD = function() {
                var _self = this;
                this.prototype = new _doOpeaLineUnitBaseCFD(), _doOpeaLineUnitBaseCFD.apply(this, arguments), 
                this.m_bOrder = !1, this.m_bAlert = !0, this.didGetStyleInfo = function() {
                    return _self.didGetEnvInfo().AlertStyleConfig;
                }, this.didGetOepObjectInfo = function() {
                    if (_self.m_doParent) {
                        return {
                            origin: xUtils.didClone(_self.m_xObjectInfo),
                            symbol: _self.m_doParent.m_symbolInfo,
                            symbolCode: _self.m_doParent.m_symbolInfo.strCode,
                            price: _self.m_xData2.curValue.y,
                            isAlert: !0
                        };
                    }
                };
            }, _doExecutionUnitCFD = function() {
                var _self = this;
                this.prototype = new _doOpeaMarkUnitBaseCFD(), _doOpeaMarkUnitBaseCFD.apply(this, arguments), 
                this.m_bOrder = !1, this.m_bExecution = !0, this.didGetStyleInfo = function() {
                    return _self.didGetEnvInfo().ExecutionStyleConfig;
                }, this.didGetOepObjectInfo = function() {
                    if (_self.m_doParent) {
                        return {
                            origin: xUtils.didClone(_self.m_xObjectInfo),
                            symbol: _self.m_doParent.m_symbolInfo,
                            symbolCode: _self.m_doParent.m_symbolInfo.strCode,
                            price: _self.m_xData2.curValue.y,
                            isExecution: !0
                        };
                    }
                }, this.didDrawSelf = function(bHitTest, extraDrawParam) {
                    var isHitTest = !(void 0 === bHitTest || !bHitTest), __xPanelRect = _self.didGetPanelRect();
                    if (_self.m_xData1.curPos.x = 0, _self.m_xData1.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_xData2.curPos.x = __xPanelRect.width, _self.m_xData2.curPos.y = _self.GetYValToPos(_self.m_xData1.curValue.y), 
                    _self.m_bDummyObject, !(_self.m_xData1.curPos.y < 0 || _self.m_xData1.curPos.y > __xPanelRect.height)) {
                        var pt1 = {
                            x: _self.GetXValToPos(_self.m_xData1.curValue.x, _self.m_xData1.curValue.t),
                            y: _self.GetYValToPos(_self.m_xData1.curValue.y)
                        }, bSelect = _self.m_bSelect;
                        extraDrawParam && 1 == extraDrawParam.offSelect && (bSelect = !1);
                        var context = _self.m_context, lineColor = (_self.m_drawWrapper.m_stEnv.Font, _self.m_clrLineColor), lineWidth = _self.m_nLineWeight, xStyleInfo = (_self.m_nLineStyle, 
                        _self.didGetStyleInfo()), bFill = !0, lineColor2 = _self.m_clrLineColor;
                        void 0 !== xStyleInfo && null != xStyleInfo && (!0 === _self.m_bDummyObject ? (lineColor = xStyleInfo.dummy.strokeColor, 
                        lineWidth = xStyleInfo.dummy.strokeWeight, xStyleInfo.dummy.strokeStyle, lineColor2 = lineColor, 
                        !0 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.ask.strokeColor, lineColor2 = xStyleInfo.ask.strokeColor2) : !1 === _self.m_xObjectInfo.ask && (lineColor = xStyleInfo.bid.strokeColor, 
                        lineColor2 = xStyleInfo.bid.strokeColor2)) : !0 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.ask.strokeColor, 
                        lineWidth = xStyleInfo.ask.strokeWeight, xStyleInfo.ask.strokeStyle, lineColor2 = xStyleInfo.ask.strokeColor2) : !1 === _self.m_xObjectInfo.ask ? (lineColor = xStyleInfo.bid.strokeColor, 
                        lineWidth = xStyleInfo.bid.strokeWeight, xStyleInfo.bid.strokeStyle, lineColor2 = xStyleInfo.bid.strokeColor2) : (lineColor = xStyleInfo.default.strokeColor, 
                        lineWidth = xStyleInfo.default.strokeWeight, xStyleInfo.default.strokeStyle, lineColor2 = lineColor), 
                        !0 === xStyleInfo.noFill && (bFill = !1));
                        var xEnv = _self.didGetEnvInfo();
                        isHitTest ? (context = _self.m_memcontext, lineColor = _self.m_clrHitTestColor, 
                        lineColor2 = lineColor) : (context = _self.m_context, bSelect && 1 == xEnv.UseOepSelectedColor && (lineColor = xEnv.System.SelectedFill.lineColor, 
                        lineColor2 = lineColor)), extraDrawParam && (context = isHitTest ? extraDrawParam.memcontext : extraDrawParam.context, 
                        pt1.x = extraDrawParam.pt.x);
                        var fillColor = 1 == bFill ? lineColor : void 0, fillColor2 = 1 == bFill ? lineColor2 : void 0, drawParam = {
                            context: context,
                            pt1: pt1,
                            pt2: {
                                x: 0,
                                y: 0
                            },
                            pt3: {
                                x: 0,
                                y: 0
                            },
                            lineWidth: lineWidth,
                            lineColor: lineColor,
                            fillColor: fillColor
                        }, triHalfWidth = 7, triHeight = 12;
                        if (1 != _self.m_xObjectInfo.ask ? (drawParam.pt2.x = pt1.x - triHalfWidth, drawParam.pt2.y = pt1.y + triHeight, 
                        drawParam.pt3.x = pt1.x + triHalfWidth, drawParam.pt3.y = pt1.y + triHeight) : (drawParam.pt2.x = pt1.x - triHalfWidth, 
                        drawParam.pt2.y = pt1.y - triHeight, drawParam.pt3.x = pt1.x + triHalfWidth, drawParam.pt3.y = pt1.y - triHeight), 
                        gxDc.Triangle(drawParam), triHalfWidth -= lineWidth, triHeight -= 2 * lineWidth, 
                        1 != _self.m_xObjectInfo.ask ? (pt1.y += lineWidth + 1, drawParam.pt1.y = pt1.y, 
                        drawParam.pt2.x = pt1.x - triHalfWidth, drawParam.pt2.y = pt1.y + triHeight, drawParam.pt3.x = pt1.x + triHalfWidth, 
                        drawParam.pt3.y = pt1.y + triHeight) : (pt1.y -= lineWidth + 1, drawParam.pt1.y = pt1.y, 
                        drawParam.pt2.x = pt1.x - triHalfWidth, drawParam.pt2.y = pt1.y - triHeight, drawParam.pt3.x = pt1.x + triHalfWidth, 
                        drawParam.pt3.y = pt1.y - triHeight), drawParam.lineColor = lineColor2, drawParam.fillColor = fillColor2, 
                        gxDc.Triangle(drawParam), !0 !== isHitTest) {
                            _self.didGetPanelHalfWidth(), pt1.x, pt1.y;
                        }
                    }
                };
            }, _exports = {};
            return _exports.didCreateOrderPositUnit = function(bOrderOrPosit, chartFrame, drawWrapper, doParent, doContainer, argUnitInfo) {
                var doLocal = null;
                return doLocal = !0 === bOrderOrPosit ? new _doOrderUnitCFD() : new _doPositUnitCFD(), 
                void 0 !== doLocal.didInitObject && doLocal.didInitObject(chartFrame, drawWrapper, doParent, doContainer, argUnitInfo), 
                doLocal;
            }, _exports.didCreateAlertUnit = function(chartFrame, drawWrapper, doParent, doContainer, argUnitInfo) {
                var doLocal = null;
                return doLocal = new _doAlertUnitCFD(), void 0 !== doLocal.didInitObject && doLocal.didInitObject(chartFrame, drawWrapper, doParent, doContainer, argUnitInfo), 
                doLocal;
            }, _exports.didCreateExecutionUnit = function(chartFrame, drawWrapper, doParent, doContainer, argUnitInfo) {
                var doLocal = null;
                return doLocal = new _doExecutionUnitCFD(), void 0 !== doLocal.didInitObject && doLocal.didInitObject(chartFrame, drawWrapper, doParent, doContainer, argUnitInfo), 
                doLocal;
            }, _exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOExtraUnitCFD = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartDOOrderPositUnit) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1), __webpack_require__(10));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc, doDosBase) {
            var _DOSIndicator = (doDosBase.didGetBasePlotClass(), doDosBase.didGetBaseSeriesClass()), _DOSCFDBase = function() {
                var _self = this;
                this.prototype = new _DOSIndicator(), _DOSIndicator.apply(this, arguments), this.hasObjectToShow = function() {
                    for (var nPlotCount = _self.m_arrPlots.length, nPlotNo = 0; nPlotNo < nPlotCount; nPlotNo++) {
                        var xPlot = _self.m_arrPlots[nPlotNo];
                        if (void 0 !== xPlot && null != xPlot && !0 !== xPlot.hasIgnore() && !0 !== xPlot.hasHide()) return !0;
                    }
                    return !1;
                }, this.DrawLastValue = function(argDrawParam, dataIndex) {}, this.didDrawTitleLabel = function(drawParam) {
                    if (drawParam) {
                        var xEnv = _self.didGetEnvInfo(), font = drawParam.font, ptCur = drawParam.pt, drawTextParam = {
                            context: drawParam.context,
                            pt: {
                                x: 0,
                                y: 0
                            },
                            text: "",
                            font: drawParam.font,
                            fillStyle: drawParam.fillStyle
                        }, drawRectParam = {
                            context: drawParam.context,
                            rect: {
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            },
                            lineWidth: 0,
                            fillColor: ""
                        }, boxSize = xEnv.LabelMarkBoxSize || 12, halfBoxSize = parseInt(boxSize / 2), labelGap = xEnv.LabelMarkGap || 5;
                        if (_self.m_xSeriesInfo.titles) {
                            var nCount = _self.m_xSeriesInfo.titles.length;
                            if (nCount > 0) for (var ii = 0; ii < nCount; ii++) {
                                var xTitle = _self.m_xSeriesInfo.titles[ii];
                                if (xTitle && void 0 !== xTitle.plotNo && null != xTitle.plotNo) {
                                    var xPlotInfo = _self.m_xSeriesInfo.plots[xTitle.plotNo];
                                    if (xPlotInfo && !0 !== xPlotInfo.ignore && 1 != xPlotInfo.hide) {
                                        var xPlot = _self.didGetPlotAt(xTitle.plotNo), strDisp = "", strParamInfo = "", boxColor = xPlot.m_xPlotInfo.color;
                                        strDisp = xTitle.display || xPlot.m_xPlotInfo.alias;
                                        try {
                                            if (xTitle.params) {
                                                var nLinkNoCount = xTitle.params.length;
                                                if (nLinkNoCount > 0) {
                                                    strParamInfo = "(";
                                                    for (var __paramVals = "", ll = 0; ll < nLinkNoCount; ll++) {
                                                        var xParamValue = _self.didGetParamValue(xTitle.params[ll]);
                                                        xParamValue && (__paramVals += xParamValue, __paramVals += ",");
                                                    }
                                                    __paramVals = __paramVals.substring(0, __paramVals.length - 1), strParamInfo = "(", 
                                                    strParamInfo += __paramVals, strParamInfo += ")";
                                                }
                                            }
                                        } catch (e) {
                                            console.warn(e);
                                        }
                                        strDisp += strParamInfo;
                                        var textRect = gxDc.CalcRect2(strDisp, font), nextPos = ptCur.x + boxSize + textRect.width + 2 * labelGap;
                                        nextPos > drawParam.frameWidth && (drawParam.lineNo++, ptCur.x = drawParam.ptBase.x, 
                                        ptCur.y = drawParam.ptBase.y + drawParam.lineNo * drawParam.lineSpace), drawRectParam.rect.x = ptCur.x, 
                                        drawRectParam.rect.y = ptCur.y - halfBoxSize, drawRectParam.rect.width = boxSize, 
                                        drawRectParam.rect.height = boxSize, drawRectParam.lineColor = drawRectParam.fillColor = boxColor, 
                                        gxDc.Rectangle(drawRectParam), ptCur.x = ptCur.x + labelGap + boxSize, drawTextParam.pt.x = ptCur.x, 
                                        drawTextParam.pt.y = ptCur.y, drawTextParam.text = strDisp;
                                        var titleLen = gxDc.TextOut(drawTextParam, !0);
                                        ptCur.x = ptCur.x + labelGap + titleLen;
                                    }
                                }
                            }
                        } else {
                            var nCount = _self.m_xSeriesInfo.plots.length;
                            if (nCount > 0) for (var ii = 0; ii < nCount; ii++) {
                                var xPlotInfo = _self.m_xSeriesInfo.plots[ii];
                                if (xPlotInfo && !0 !== xPlotInfo.ignore && 1 != xPlotInfo.hide) {
                                    var strDisp = "", strParamInfo = "", boxColor = xPlotInfo.color;
                                    strDisp = xPlotInfo.alias;
                                    var xParam;
                                    try {
                                        if (xPlotInfo.paramLinkNos) {
                                            var nLinkNoCount = xPlotInfo.paramLinkNos.length;
                                            if (nLinkNoCount > 0) {
                                                strParamInfo = "(";
                                                for (var __paramVals = "", ll = 0; ll < nLinkNoCount; ll++) {
                                                    var xParamValue = _self.didGetParamValue(xPlotInfo.paramLinkNos[ll]);
                                                    xParamValue && (__paramVals += xParamValue, __paramVals += ",");
                                                }
                                                __paramVals = __paramVals.substring(0, __paramVals.length - 1), strParamInfo = "(", 
                                                strParamInfo += __paramVals, strParamInfo += ")";
                                            }
                                        } else (xParam = _self.m_xSeriesInfo.params[ii]) && (strParamInfo = "(", strParamInfo += xUtils.indicator.didGetParamValueForDisplay(xParam), 
                                        strParamInfo += ")");
                                    } catch (e) {
                                        xParam = null;
                                    }
                                    strDisp += strParamInfo;
                                    var textRect = gxDc.CalcRect2(strDisp, font), nextPos = ptCur.x + boxSize + textRect.width + 2 * labelGap;
                                    nextPos > drawParam.frameWidth && (drawParam.lineNo++, ptCur.x = drawParam.ptBase.x, 
                                    ptCur.y = drawParam.ptBase.y + drawParam.lineNo * drawParam.lineSpace), drawRectParam.rect.x = ptCur.x, 
                                    drawRectParam.rect.y = ptCur.y - halfBoxSize, drawRectParam.rect.width = boxSize, 
                                    drawRectParam.rect.height = boxSize, drawRectParam.lineColor = drawRectParam.fillColor = boxColor, 
                                    gxDc.Rectangle(drawRectParam), ptCur.x = ptCur.x + labelGap + boxSize, drawTextParam.pt.x = ptCur.x, 
                                    drawTextParam.pt.y = ptCur.y, drawTextParam.text = strDisp;
                                    var titleLen = gxDc.TextOut(drawTextParam, !0);
                                    ptCur.x = ptCur.x + labelGap + titleLen;
                                }
                            }
                        }
                        return drawParam;
                    }
                }, this.DrawDataView = function(argLineSeq, argLocalXPos) {
                    var xEnv = _self.didGetEnvInfo(), lineSpace = xEnv.System.LineSpace, textSpace = xEnv.System.TextSpace, dataIndex = _self.GetXIndex(argLocalXPos), context = _self.m_context, startXPos = textSpace, ptDraw = {
                        x: startXPos,
                        y: (argLineSeq + 1) * lineSpace
                    }, font = _self.m_drawWrapper.m_stEnv.Font, fontColor = _self.m_drawWrapper.m_stEnv.FontColor, textSpace = _self.m_drawWrapper.m_stEnv.System.TextSpace, drawTextParam = {
                        context: context,
                        pt: {
                            x: ptDraw.x,
                            y: ptDraw.y
                        },
                        text: "",
                        font: font,
                        fillStyle: fontColor,
                        textSpace: textSpace
                    };
                    _self.didDrawDataView(drawTextParam, dataIndex);
                }, this.didDrawDataView = function(argDtp, argDataIndex) {
                    var drawTextParam = argDtp, drawRectParam = {
                        context: drawTextParam.context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: 0,
                        fillColor: ""
                    }, xEnv = _self.didGetEnvInfo(), boxSize = (xEnv.System.LineSpace, xEnv.System.TextSpace, 
                    xEnv.LabelMarkBoxSize || 12), halfBoxSize = parseInt(boxSize / 2), labelGap = xEnv.LabelMarkGap || 5, nCount = _self.m_xSeriesInfo.plots.length;
                    if (nCount > 0) for (var ii = 0; ii < nCount; ii++) {
                        var xPlot = _self.m_xSeriesInfo.plots[ii];
                        if (xPlot && !0 !== xPlot.ignore) {
                            var strDisp = "", strParamInfo = "", boxColor = xPlot.color;
                            strDisp = xPlot.alias;
                            var xParam;
                            try {
                                xParam = _self.m_xSeriesInfo.params[ii];
                            } catch (e) {
                                xParam = null;
                            }
                            xParam && (strParamInfo = "(", strParamInfo += xUtils.indicator.didGetParamValueForDisplay(xParam), 
                            strParamInfo += ")"), strDisp += strParamInfo, drawRectParam.rect.x = drawTextParam.pt.x, 
                            drawRectParam.rect.y = drawTextParam.pt.y - halfBoxSize, drawRectParam.rect.width = boxSize, 
                            drawRectParam.rect.height = boxSize, drawRectParam.fillColor = boxColor, gxDc.Rectangle(drawRectParam), 
                            drawTextParam.pt.x = drawTextParam.pt.x + labelGap + boxSize, drawTextParam.text = strDisp;
                            var titleLen = gxDc.TextOut(drawTextParam, !0);
                            drawTextParam.pt.x = drawTextParam.pt.x + labelGap + titleLen;
                        }
                    }
                    return drawTextParam;
                }, this.didGetDisplayTitle = function(isSimple) {
                    var strParamInfo = "";
                    if (!0 !== isSimple) {
                        var nParamCount = _self.m_xSeriesInfo.params.length;
                        if (nParamCount > 0) {
                            strParamInfo = "(";
                            for (var ii = 0; ii < nParamCount; ii++) {
                                var xParam = _self.m_xSeriesInfo.params[ii];
                                strParamInfo += xUtils.indicator.didGetParamValueForDisplay(xParam), ii < nParamCount - 1 && (strParamInfo += ",");
                            }
                            strParamInfo += ")";
                        }
                    }
                    return _self.m_strChartName + strParamInfo;
                };
            }, _DOSEMATriple = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                var _nSPeriod = 5, _nMPeriod = 10, _nLPeriod = 20;
                this.m_nPlotLimit = 3;
                var _ProcPlot = function(argPlotNo, nStart, nDSize, nPeriod) {
                    for (var dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(argPlotNo), nLimit = nPeriod - 1 + _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var dSumL = 0, dData = 0, arrData = [], dEMA_1 = 0, nIdx = 0, nIdxP = 0, reg_j = 0, reg_i = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPrice;
                        if (nIdx = reg_i, nIdxP = nIdx - 1, reg_i === nLimit) {
                            arrData = [];
                            var nGo = nIdx - (nPeriod - 1), nStop = nGo + nPeriod;
                            for (reg_j = nGo; reg_j < nStop; reg_j++) stPrice = _self.didGetReferencedBaseDataAt(reg_j, !1), 
                            dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), arrData.push(dData);
                            var xMAEx = xUtils.math.CalcMAEx(arrData, dSumL, nPeriod, xUtils.math.constants.methods.simple, !0, !0);
                            dEMA_1 = xMAEx.ma, dSumL = xMAEx.sum, dData = dEMA_1;
                        } else dEMA_1 = xPlot.didGetDataAt(nIdxP), arrData = [], arrData.push(dEMA_1), stPrice = _self.didGetReferencedBaseDataAt(reg_i, !1), 
                        dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), arrData.push(dData), 
                        dData = xUtils.math.CalcMA(arrData, nPeriod, xUtils.math.constants.methods.exponential);
                        xPlot.didSetData(reg_i, !0, dData);
                    }
                    return nLimit;
                };
                this.didCalculateData = function() {
                    _self.runProcHD();
                }, this.ParamSet = function() {
                    _nSPeriod = _self.didGetPeriod(0), _nMPeriod = _self.didGetPeriod(1), _nLPeriod = _self.didGetPeriod(2);
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset), _ProcPlot(0, nStart, nDSize, _nSPeriod), _ProcPlot(1, nStart, nDSize, _nMPeriod), 
                    _ProcPlot(2, nStart, nDSize, _nLPeriod);
                };
            }, _DOSBollingerBandsTriple = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                this.m_nPlotLimit = 7, this.m_nPeriod = 20;
                var _ProcPlotS = function(nStart, nDSize, nCheck) {
                    for (var dFactor = _self.didGetPriceFactor(), xPlotM = _self.didGetPlotAt(0), xPlotU1 = _self.didGetPlotAt(1), xPlotL1 = _self.didGetPlotAt(2), xPlotU2 = _self.didGetPlotAt(3), xPlotL2 = _self.didGetPlotAt(4), xPlotU3 = _self.didGetPlotAt(5), xPlotL3 = _self.didGetPlotAt(6), nLimit = _self.m_nPeriod - 1 + nCheck + _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlotM.didSetInvalidData(nOffset), 
                    xPlotU1.didSetInvalidData(nOffset), xPlotL1.didSetInvalidData(nOffset), xPlotU2.didSetInvalidData(nOffset), 
                    xPlotL2.didSetInvalidData(nOffset), xPlotU3.didSetInvalidData(nOffset), xPlotL3.didSetInvalidData(nOffset), 
                    nOffset++;
                    var d1SD = 0, dVar = 0, dSum = 0, dSum2 = 0, dSumL = 0, dSumL2 = 0, dTemp = 0, dTempP = 0, dData = 0, reg_i = 0, reg_j = 0, nMulti = 1;
                    if (nOffset >= nLimit && nOffset < nDSize) {
                        var nGo = nOffset - (_self.m_nPeriod - 1), nStop = Math.min(nDSize, nGo + _self.m_nPeriod);
                        for (d1SD = 0, dVar = 0, 0, dSum = 0, dSum2 = 0, dTemp = 0, dTempP = 0, reg_j = nGo; reg_j < nStop; reg_j++) {
                            var stPrice = _self.didGetReferencedBaseDataAt(reg_j, !1);
                            dTemp = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.close, dFactor), 
                            dSum += dTemp, dSum2 += dTemp * dTemp;
                        }
                        for (dSumL = dSum, dSumL2 = dSum2, dVar = (dSum2 - dSum * dSum / _self.m_nPeriod) / _self.m_nPeriod, 
                        dVar < 0 && (dVar = 0), d1SD = Math.sqrt(dVar), dData = dSum / _self.m_nPeriod, 
                        xPlotM.didSetData(nOffset, !0, dData), nMulti = 1, xPlotU1.didSetData(nOffset, !0, dData + d1SD * nMulti), 
                        xPlotL1.didSetData(nOffset, !0, dData - d1SD * nMulti), nMulti = 2, xPlotU2.didSetData(nOffset, !0, dData + d1SD * nMulti), 
                        xPlotL2.didSetData(nOffset, !0, dData - d1SD * nMulti), nMulti = 3, xPlotU3.didSetData(nOffset, !0, dData + d1SD * nMulti), 
                        xPlotL3.didSetData(nOffset, !0, dData - d1SD * nMulti), nGo = nOffset + 1, nStop = nDSize, 
                        reg_i = nGo; reg_i < nStop; reg_i++) {
                            d1SD = 0, dVar = 0, 0, dSum = 0, dSum2 = 0, dTemp = 0;
                            var stPriceP = _self.didGetReferencedBaseDataAt(reg_i - _self.m_nPeriod, !1), stPriceL = _self.didGetReferencedBaseDataAt(reg_i, !1);
                            dTempP = xUtils.didGetPriceValue(stPriceP, xUtils.constants.keywords.price.close, dFactor), 
                            dTemp = xUtils.didGetPriceValue(stPriceL, xUtils.constants.keywords.price.close, dFactor), 
                            dSum = dSumL - dTempP + dTemp, dSum2 = dSumL2 - dTempP * dTempP + dTemp * dTemp, 
                            dSumL = dSum, dSumL2 = dSum2, dVar = (dSum2 - dSum * dSum / _self.m_nPeriod) / _self.m_nPeriod, 
                            dVar < 0 && (dVar = 0), d1SD = Math.sqrt(dVar), dData = dSum / _self.m_nPeriod, 
                            xPlotM.didSetData(reg_i, !0, dData), nMulti = 1, xPlotU1.didSetData(reg_i, !0, dData + d1SD * nMulti), 
                            xPlotL1.didSetData(reg_i, !0, dData - d1SD * nMulti), nMulti = 2, xPlotU2.didSetData(reg_i, !0, dData + d1SD * nMulti), 
                            xPlotL2.didSetData(reg_i, !0, dData - d1SD * nMulti), nMulti = 3, xPlotU3.didSetData(reg_i, !0, dData + d1SD * nMulti), 
                            xPlotL3.didSetData(reg_i, !0, dData - d1SD * nMulti);
                        }
                    }
                    return nLimit;
                };
                this.didCalculateData = function() {
                    _self.runProcHD();
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset), _ProcPlotS(nStart, nDSize, 0);
                }, this.didReceiveData = function(symbolInfo, receivedDatas) {
                    _self.ReceiveData();
                };
            }, _DOSIchimokuKinkouhyou_CFD = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                this.m_nPlotLimit = 6;
                var _nPeriod1 = 9, _nPeriod2 = 26, _nPeriod3 = 26, _nPeriod4 = 52, _nPeriod5 = 26;
                this.ParamSet = function() {
                    _nPeriod1 = _self.didGetPeriod(0), _nPeriod2 = _self.didGetPeriod(1), _nPeriod3 = _self.didGetPeriod(2), 
                    _nPeriod4 = _self.didGetPeriod(3), _nPeriod5 = _self.didGetPeriod(4);
                };
                var _ProcPlotBGSpan = function(nStart, nDSize, nCheck) {
                    for (var dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(4), nLimit = _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var reg_i = 0, dData = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPrice;
                        stPrice = _self.didGetReferencedBaseDataAt(reg_i, !1), dData = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.close, dFactor), 
                        xPlot.didSetData(reg_i, !0, dData);
                    }
                    return nLimit;
                }, _ProcPlotPCL = function(nPPos, nPeriod, nStart, nDSize, nCheck) {
                    for (var xPlot = (_self.didGetPriceFactor(), _self.didGetPlotAt(nPPos)), nLimit = nPeriod - 1 + nCheck + _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var nf_cnt = 0, dHigh = 0, dLow = 0, nSIdx = 0, dData = 0;
                    if (nOffset >= nLimit) {
                        var xDoPb = _self.didGetReferencedPriceObject();
                        for (nf_cnt = nOffset; nf_cnt < nDSize; nf_cnt++) {
                            dHigh = -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, dLow = 1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, 
                            nSIdx = nf_cnt - (nPeriod - 1);
                            var xMinMax = xDoPb.didGetMinMaxAtRange({
                                location: nSIdx,
                                length: nPeriod
                            });
                            void 0 !== xMinMax && null != xMinMax && (dHigh = xMinMax.dHigh, dLow = xMinMax.dLow), 
                            dData = (dHigh + dLow) / 2, xPlot.didSetData(nf_cnt, !0, dData);
                        }
                    }
                    return nLimit;
                }, _ProcPlotPGSpan1 = function(nStart, nDSize, nCheck) {
                    for (var xPlot = (_self.didGetPriceFactor(), _self.didGetPlotAt(2)), xPlotRefT = _self.didGetPlotAt(0), xPlotRefB = _self.didGetPlotAt(1), nLimit = nCheck, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var np_pos = 0, dTData = 0, dBData = 0, dData = 0;
                    if (nOffset >= nLimit) for (np_pos = nOffset; np_pos < nDSize; np_pos++) {
                        var isValidT = xPlotRefT.isValidAt(np_pos), isValidB = xPlotRefB.isValidAt(np_pos);
                        !0 === isValidT && !0 === isValidB ? (dTData = xPlotRefT.didGetDataAt(np_pos), dBData = xPlotRefB.didGetDataAt(np_pos), 
                        dData = (dTData + dBData) / 2, xPlot.didSetData(np_pos, !0, dData)) : xPlot.didSetInvalidData(np_pos);
                    }
                    return nLimit;
                }, _ProcPlotPGSpan2 = function(nStart, nDSize, nCheck) {
                    for (var xPlot = (_self.didGetPriceFactor(), _self.didGetPlotAt(3)), xPlotRef = _self.didGetPlotAt(5), nLimit = nCheck, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var np_pos = 0, dData = 0;
                    if (nOffset >= nLimit) for (np_pos = nOffset; np_pos < nDSize; np_pos++) {
                        var isValid = xPlotRef.isValidAt(np_pos);
                        !0 === isValid ? (dData = xPlotRef.didGetDataAt(np_pos), xPlot.didSetData(np_pos, !0, dData)) : xPlot.didSetInvalidData(np_pos);
                    }
                    return nLimit;
                };
                this.didReceiveData = function(symbolInfo, receivedDatas) {
                    _self.ReceiveData();
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset);
                    var nCheck = 0, nCPG1 = 0, nCPG2 = 0;
                    _ProcPlotBGSpan(nStart, nDSize);
                    var nMCheck = _ProcPlotPCL(5, _nPeriod4, nStart, nDSize, nCheck), nTCheck = _ProcPlotPCL(0, _nPeriod1, nStart, nDSize, nCheck), nBCheck = _ProcPlotPCL(1, _nPeriod2, nStart, nDSize, nCheck);
                    nCheck = Math.max(nTCheck, nBCheck), nCPG2 = _ProcPlotPGSpan2(nStart, nDSize, nMCheck), 
                    nCPG1 = _ProcPlotPGSpan1(nStart, nDSize, nCheck), nCheck = Math.max(nCPG1, nCPG2);
                }, this.didGetShifRightCount = function() {
                    var nShiftCount = 0;
                    _self.m_nMoveShift > 0 && (nShiftCount = Math.abs(_self.m_nMoveShift));
                    for (var nPlotShiftCount = 0, nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                        var nMoveShift = _self.didGetPlotShiftValueAt(ii), nShiftRightCount = xUtils.didGetShifRightCount(nMoveShift);
                        nPlotShiftCount = Math.max(nPlotShiftCount, nShiftRightCount);
                    }
                    return nShiftCount += nPlotShiftCount;
                }, this.didGetShifLeftCount = function() {
                    var nShiftCount = 0;
                    _self.m_nMoveShift < 0 && (nShiftCount = Math.abs(_self.m_nMoveShift));
                    for (var nPlotShiftCount = 0, nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                        var nMoveShift = (_self.m_arrPlots[ii], _self.didGetPlotShiftValueAt(ii)), nShiftLeftCount = xUtils.didGetShifLeftCount(nMoveShift);
                        nPlotShiftCount = Math.max(nPlotShiftCount, nShiftLeftCount);
                    }
                    return nShiftCount += nPlotShiftCount;
                }, this.didGetPlotShiftValueAt = function(argNo) {
                    var nShiftOffset = 0;
                    return nShiftOffset = 1, 4 === argNo ? -1 * (_nPeriod5 - nShiftOffset) : 2 === argNo || 3 === argNo ? 1 * (_nPeriod3 - nShiftOffset) : 0;
                }, this.didGetShiftedDataIndexOfPlotAt = function(argDataIndex, argPlotNo) {
                    var nShiftValue = _self.didGetShiftValue(), xPlot = _self.didGetPlotAt(argPlotNo);
                    return void 0 !== xPlot && null != xPlot && !0 !== xPlot.hasIgnore() && !0 !== xPlot.hasHide() && (nShiftValue += xPlot.didGetShiftValue(!0)), 
                    xUtils.didConvertShiftedIndex(argDataIndex, nShiftValue);
                }, this.didDrawFillPlots = function(isHitTest) {
                    _self.didDrawFillPlotItem({
                        plot1: 2,
                        plot2: 3,
                        colorUp: "#8515C7",
                        colorDn: "#EE687B",
                        alpha: .6
                    }, isHitTest);
                };
            }, _DOSMACD = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                var _nLPeriod = 26, _nSPeriod = 12, _nSigPeriod = 9;
                this.m_nPeriodLimit = 5;
                var _ProcJust = function(nLPos, nLCheck, nRPos, nRCheck, nDPos, nStart, nDSize) {
                    for (var xPlotL = _self.didGetPlotAt(nLPos), xPlotR = _self.didGetPlotAt(nRPos), xPlotD = _self.didGetPlotAt(nDPos), nLimit = Math.max(nLCheck, nRCheck), nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlotD.didSetInvalidData(nOffset), 
                    nOffset++;
                    var dLData = 0, dRData = 0, reg_i = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var calcedValue = xUtils.constants.default.DEFAULT_WRONG_VALUE;
                        !0 === xPlotL.isValidAt(reg_i) && !0 === xPlotR.isValidAt(reg_i) ? (dLData = xPlotL.didGetDataAt(reg_i), 
                        dRData = xPlotR.didGetDataAt(reg_i), !0, calcedValue = dLData - dRData, xPlotD.didSetData(reg_i, !0, calcedValue)) : xPlotD.didSetInvalidData(reg_i);
                    }
                    return nLimit;
                }, _ProcSig_SMA = function(nStart, nDSize, nCheck) {
                    for (var xPlotRef = _self.didGetPlotAt(2), xPlotSig = _self.didGetPlotAt(3), nPeriod = _nSigPeriod, nLimit = nPeriod - 1 + nCheck, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlotSig.didSetInvalidData(nOffset), 
                    nOffset++;
                    var vInput, bFirst = !0, arrData = [], reg_i = 0, reg_j = 0, dSumL = 0, dPreL = 0, dData = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        xUtils.constants.default.DEFAULT_WRONG_VALUE;
                        if (bFirst) {
                            arrData = [];
                            var nGo = reg_i - (nPeriod - 1), nStop = nGo + nPeriod;
                            for (reg_j = nGo; reg_j < nStop; reg_j++) dData = xPlotRef.didGetDataAt(reg_j), 
                            arrData.push(dData);
                            vInput = arrData;
                        } else dData = xPlotRef.didGetDataAt(reg_i), dSumL += dData, dData = xPlotRef.didGetDataAt(reg_i - (nPeriod - 1)), 
                        dPreL = dData, vInput = dPreL;
                        var xMAEx = xUtils.math.CalcMAEx(vInput, dSumL, nPeriod, xUtils.math.constants.methods.simple, bFirst, !0);
                        dData = xMAEx.ma, dSumL = xMAEx.sum, xPlotSig.didSetData(reg_i, !0, dData), bFirst = !1;
                    }
                    return nLimit;
                }, _ProcRefP = function(argPlotNo, nStart, nDSize, nPeriod) {
                    for (var dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(argPlotNo), nLimit = nPeriod - 1 + _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    if (nOffset >= nLimit) {
                        var arrData = [], reg_i = 0, reg_j = 0, dSumL = 0, dData = 0, dEMA_1 = 0, nIdx = 0, nIdxP = 0;
                        for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                            var stPrice, calcedValue = xUtils.constants.default.DEFAULT_WRONG_VALUE;
                            if (nIdx = reg_i, nIdxP = nIdx - 1, reg_i === nLimit) {
                                arrData = [];
                                var nGo = nIdx - (nPeriod - 1), nStop = nGo + nPeriod;
                                for (reg_j = nGo; reg_j < nStop; reg_j++) stPrice = _self.didGetReferencedBaseDataAt(reg_j, !1), 
                                dData = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.close, dFactor), 
                                arrData.push(dData);
                                var xMAEx = xUtils.math.CalcMAEx(arrData, dSumL, nPeriod, xUtils.math.constants.methods.simple, !0, !0);
                                dEMA_1 = xMAEx.ma, dSumL = xMAEx.sum, !0, calcedValue = dEMA_1;
                            } else dEMA_1 = xPlot.didGetDataAt(nIdxP), arrData = [], arrData.push(dEMA_1), stPrice = _self.didGetReferencedBaseDataAt(reg_i, !1), 
                            dData = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.close, dFactor), 
                            arrData.push(dData), dData = xUtils.math.CalcMA(arrData, nPeriod, xUtils.math.constants.methods.exponential), 
                            !0, calcedValue = dData;
                            xPlot.didSetData(reg_i, !0, calcedValue);
                        }
                    }
                    return nLimit;
                };
                this.ParamSet = function() {
                    _nSPeriod = _self.didGetPeriod(0), _nLPeriod = _self.didGetPeriod(1), _nSigPeriod = _self.didGetPeriod(2);
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset);
                    var nSCheck = 0, nLCheck = 0, nSig = 0, nMACD = 0;
                    nSCheck = _ProcRefP(0, nStart, nDSize, _nSPeriod), nLCheck = _ProcRefP(1, nStart, nDSize, _nLPeriod), 
                    nMACD = _ProcJust(0, nSCheck, 1, nLCheck, 2, nStart, nDSize), nSig = _ProcSig_SMA(nStart, nDSize, nMACD);
                    _ProcJust(2, nMACD, 3, nSig, 4, nStart, nDSize);
                }, this.didClearExtraData = function() {};
            }, _DOSRCI = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                var _nSPeriod = 5, _nMPeriod = 20, _nLPeriod = 60;
                this.m_nPlotLimit = 3, this.ParamSet = function() {
                    _nSPeriod = _self.didGetPeriod(0), _nMPeriod = _self.didGetPeriod(1), _nLPeriod = _self.didGetPeriod(2);
                };
                var _CalcRankSum = function(arrOrg) {
                    var nOSize = arrOrg.length;
                    if (nOSize < 2) return 0;
                    var arrDRank = [], arrPRank1 = [], arrPRank2 = [], arrData = [], arrPRankA = [], ii = 0, jj = 0;
                    for (ii = 0; ii < nOSize; ii++) arrData.push(arrOrg[ii]), arrDRank.push(nOSize - ii);
                    var dSwap = 0, nSwap = 0;
                    for (ii = 0; ii < nOSize - 1; ii++) for (jj = ii + 1; jj < nOSize; jj++) arrData[ii], 
                    arrData[jj], arrData[ii] < arrData[jj] && (dSwap = arrData[ii], arrData[ii] = arrData[jj], 
                    arrData[jj] = dSwap, nSwap = arrDRank[ii], arrDRank[ii] = arrDRank[jj], arrDRank[jj] = nSwap);
                    var dPreData = 0, dCurData = 0, nDRank = 0, nPRank = 0, nPRank2 = 0, dPRank = 0, dDPRank = 0, dSum = 0, nSameCnt = 1, nPRIdx = 0, dTemp = 0;
                    for (arrPRankA = [], arrPRank2 = [], arrPRank1 = [], ii = 0; ii < nOSize; ii++) dCurData = arrData[ii], 
                    0 == ii ? (nPRIdx = 0, nPRank = 1, nPRank2 = ii + 1) : (arrPRank1.push(nPRIdx), 
                    dPreData > dCurData ? (dTemp = nSameCnt > 1 ? nPRank / nSameCnt : nPRank2, arrPRankA.push(dTemp), 
                    nPRank = ii + 1, nSameCnt = 1, nPRIdx++, nPRank2 = ii + 1) : (nPRank += ii + 1, 
                    nSameCnt++), ii >= nOSize - 1 && (arrPRank1.push(nPRIdx), dTemp = nSameCnt > 1 ? nPRank / nSameCnt : nPRank2, 
                    arrPRankA.push(dTemp))), arrPRank2.push(nPRank2), dPreData = dCurData;
                    for (nDRank = 0, nPRank = 0, dDPRank = 0, dSum = 0, nPRIdx = 0, ii = 0; ii < nOSize; ii++) nDRank = arrDRank[ii], 
                    nPRIdx = arrPRank1[ii], dPRank = arrPRankA[nPRIdx], dDPRank = nDRank - dPRank, dSum += dDPRank * dDPRank;
                    return dSum;
                }, _ProcPlotRCI = function(argPlotNo, nPeriod, nStart, nDSize, nCheck) {
                    var dPointFactor = _self.didGetPointFactor(), dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(argPlotNo), nLimit = nPeriod - 1 + nCheck, nOffset = nStart;
                    if (void 0 === xPlot || null == xPlot) return nLimit;
                    for (;nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var nGo = 0, nStop = 0, dData = 0, arrData = [], dRCI = 0, reg_j = 0, reg_i = 0, nDiv = nPeriod * (nPeriod * nPeriod - 1);
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPrice;
                        arrData = [], nGo = reg_i - (nPeriod - 1);
                        var nStop = nGo + nPeriod;
                        for (reg_j = nGo; reg_j < nStop; reg_j++) stPrice = _self.didGetReferencedBaseDataAt(reg_j, !1), 
                        dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), arrData.push(dData);
                        dData = _CalcRankSum(arrData), dRCI = dPointFactor * (1 - 6 * dData / nDiv) * 100, 
                        xPlot.didSetData(reg_i, !0, dRCI);
                    }
                    return nLimit;
                };
                this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset);
                    var nCheck = _self.m_nRefSkip;
                    _ProcPlotRCI(0, _nSPeriod, nStart, nDSize, nCheck), _ProcPlotRCI(1, _nMPeriod, nStart, nDSize, nCheck), 
                    _ProcPlotRCI(2, _nLPeriod, nStart, nDSize, nCheck);
                };
            }, _DOSShiftBase = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments), this.didGetShifRightCount = function() {
                    var nShiftCount = 0;
                    _self.m_nMoveShift > 0 && (nShiftCount = Math.abs(_self.m_nMoveShift));
                    for (var nPlotShiftCount = 0, nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                        var nMoveShift = _self.didGetPlotShiftValueAt(ii), nShiftRightCount = xUtils.didGetShifRightCount(nMoveShift);
                        nPlotShiftCount = Math.max(nPlotShiftCount, nShiftRightCount);
                    }
                    return nShiftCount += nPlotShiftCount;
                }, this.didGetShifLeftCount = function() {
                    var nShiftCount = 0;
                    _self.m_nMoveShift < 0 && (nShiftCount = Math.abs(_self.m_nMoveShift));
                    for (var nPlotShiftCount = 0, nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                        var nMoveShift = (_self.m_arrPlots[ii], _self.didGetPlotShiftValueAt(ii)), nShiftLeftCount = xUtils.didGetShifLeftCount(nMoveShift);
                        nPlotShiftCount = Math.max(nPlotShiftCount, nShiftLeftCount);
                    }
                    return nShiftCount += nPlotShiftCount;
                };
            }, _DOSBollingerBandsTriple_Super = function() {
                var _self = this;
                this.prototype = new _DOSShiftBase(), _DOSShiftBase.apply(this, arguments);
                this.m_nPlotLimit = 8, this.m_nPeriod = 21;
                var _nBGSpan = 21, _nMulti1 = 1, _nMulti2 = 2, _nMulti3 = 3;
                this.ParamSet = function() {
                    _self.m_nPeriod = _self.didGetPeriod(0), _nBGSpan = _self.didGetPeriod(1), _nMulti1 = _self.didGetPeriod(2), 
                    _nMulti2 = _self.didGetPeriod(3), _nMulti3 = _self.didGetPeriod(4);
                };
                var _ProcPlotBGSpan = function(nStart, nDSize, nCheck) {
                    for (var dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(1), nLimit = _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var reg_i = 0, dData = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPrice;
                        stPrice = _self.didGetReferencedBaseDataAt(reg_i, !1), dData = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.close, dFactor), 
                        xPlot.didSetData(reg_i, !0, dData);
                    }
                    return nLimit;
                }, _ProcPlotS = function(nStart, nDSize, nCheck) {
                    for (var dFactor = _self.didGetPriceFactor(), xPlotM = _self.didGetPlotAt(0), xPlotU1 = _self.didGetPlotAt(2), xPlotL1 = _self.didGetPlotAt(3), xPlotU2 = _self.didGetPlotAt(4), xPlotL2 = _self.didGetPlotAt(5), xPlotU3 = _self.didGetPlotAt(6), xPlotL3 = _self.didGetPlotAt(7), nLimit = _self.m_nPeriod - 1 + nCheck + _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlotM.didSetInvalidData(nOffset), 
                    xPlotU1.didSetInvalidData(nOffset), xPlotL1.didSetInvalidData(nOffset), xPlotU2.didSetInvalidData(nOffset), 
                    xPlotL2.didSetInvalidData(nOffset), xPlotU3.didSetInvalidData(nOffset), xPlotL3.didSetInvalidData(nOffset), 
                    nOffset++;
                    var d1SD = 0, dVar = 0, dSum = 0, dSum2 = 0, dSumL = 0, dSumL2 = 0, dTemp = 0, dTempP = 0, dData = 0, reg_i = 0, reg_j = 0, nMulti = 1;
                    if (nOffset >= nLimit && nOffset < nDSize) {
                        var nGo = nOffset - (_self.m_nPeriod - 1), nStop = Math.min(nDSize, nGo + _self.m_nPeriod);
                        for (d1SD = 0, dVar = 0, 0, dSum = 0, dSum2 = 0, dTemp = 0, dTempP = 0, reg_j = nGo; reg_j < nStop; reg_j++) {
                            var stPrice = _self.didGetReferencedBaseDataAt(reg_j, !1);
                            dTemp = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.close, dFactor), 
                            dSum += dTemp, dSum2 += dTemp * dTemp;
                        }
                        for (dSumL = dSum, dSumL2 = dSum2, dVar = (dSum2 - dSum * dSum / _self.m_nPeriod) / _self.m_nPeriod, 
                        dVar < 0 && (dVar = 0), d1SD = Math.sqrt(dVar), dData = dSum / _self.m_nPeriod, 
                        xPlotM.didSetData(nOffset, !0, dData), nMulti = _nMulti1, xPlotU1.didSetData(nOffset, !0, dData + d1SD * nMulti), 
                        xPlotL1.didSetData(nOffset, !0, dData - d1SD * nMulti), nMulti = _nMulti2, xPlotU2.didSetData(nOffset, !0, dData + d1SD * nMulti), 
                        xPlotL2.didSetData(nOffset, !0, dData - d1SD * nMulti), nMulti = _nMulti3, xPlotU3.didSetData(nOffset, !0, dData + d1SD * nMulti), 
                        xPlotL3.didSetData(nOffset, !0, dData - d1SD * nMulti), nGo = nOffset + 1, nStop = nDSize, 
                        reg_i = nGo; reg_i < nStop; reg_i++) {
                            d1SD = 0, dVar = 0, 0, dSum = 0, dSum2 = 0, dTemp = 0;
                            var stPriceP = _self.didGetReferencedBaseDataAt(reg_i - _self.m_nPeriod, !1), stPriceL = _self.didGetReferencedBaseDataAt(reg_i, !1);
                            dTempP = xUtils.didGetPriceValue(stPriceP, xUtils.constants.keywords.price.close, dFactor), 
                            dTemp = xUtils.didGetPriceValue(stPriceL, xUtils.constants.keywords.price.close, dFactor), 
                            dSum = dSumL - dTempP + dTemp, dSum2 = dSumL2 - dTempP * dTempP + dTemp * dTemp, 
                            dSumL = dSum, dSumL2 = dSum2, dVar = (dSum2 - dSum * dSum / _self.m_nPeriod) / _self.m_nPeriod, 
                            dVar < 0 && (dVar = 0), d1SD = Math.sqrt(dVar), dData = dSum / _self.m_nPeriod, 
                            xPlotM.didSetData(reg_i, !0, dData), nMulti = _nMulti1, xPlotU1.didSetData(reg_i, !0, dData + d1SD * nMulti), 
                            xPlotL1.didSetData(reg_i, !0, dData - d1SD * nMulti), nMulti = _nMulti2, xPlotU2.didSetData(reg_i, !0, dData + d1SD * nMulti), 
                            xPlotL2.didSetData(reg_i, !0, dData - d1SD * nMulti), nMulti = _nMulti3, xPlotU3.didSetData(reg_i, !0, dData + d1SD * nMulti), 
                            xPlotL3.didSetData(reg_i, !0, dData - d1SD * nMulti);
                        }
                    }
                    return nLimit;
                };
                this.didCalculateData = function() {
                    _self.runProcHD();
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset), _ProcPlotS(nStart, nDSize, 0), _ProcPlotBGSpan(nStart, nDSize);
                }, this.didReceiveData = function(symbolInfo, receivedDatas) {
                    _self.ReceiveData();
                }, this.didGetPlotShiftValueAt = function(argNo) {
                    var nShiftOffset = 0;
                    return nShiftOffset = 1, 1 === argNo ? -1 * (_nBGSpan - nShiftOffset) : 0;
                };
            }, _DOSSMATriple = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                var _nSPeriod = 5, _nMPeriod = 25, _nLPeriod = 75;
                this.m_nPlotLimit = 3, this.ParamSet = function() {
                    _nSPeriod = _self.didGetPeriod(0), _nMPeriod = _self.didGetPeriod(1), _nLPeriod = _self.didGetPeriod(2);
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset), _self.ProcPlotS(0, nStart, nDSize, _nSPeriod), _self.ProcPlotS(1, nStart, nDSize, _nMPeriod), 
                    _self.ProcPlotS(2, nStart, nDSize, _nLPeriod);
                };
            }, _DOSSpanModel = function() {
                var _self = this, _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                this.m_nPlotLimit = 3;
                var _nPeriod1 = 9, _nPeriod2 = 26, _nPeriod3 = 26;
                this.ParamSet = function() {
                    _nPeriod1 = _self.didGetPeriod(0), _nPeriod2 = _self.didGetPeriod(1), _nPeriod3 = _self.didGetPeriod(2);
                };
                var _ProcPlotBGSpan = function(nStart, nDSize, nCheck) {
                    for (var dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(2), nLimit = _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var reg_i = 0, dData = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPrice;
                        stPrice = _self.didGetReferencedBaseDataAt(reg_i, !1), dData = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.close, dFactor), 
                        xPlot.didSetData(reg_i, !0, dData);
                    }
                    return nLimit;
                }, _ProcPlotPCL = function(nPPos, nPeriod, nStart, nDSize, nCheck) {
                    for (var xPlot = (_self.didGetPriceFactor(), _self.didGetPlotAt(nPPos)), nLimit = nPeriod - 1 + nCheck + _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var nf_cnt = 0, dHigh = 0, dLow = 0, nSIdx = 0, dData = 0;
                    if (nOffset >= nLimit) {
                        var xDoPb = _self.didGetReferencedPriceObject();
                        for (nf_cnt = nOffset; nf_cnt < nDSize; nf_cnt++) {
                            dHigh = -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, dLow = 1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, 
                            nSIdx = nf_cnt - (nPeriod - 1);
                            var xMinMax = xDoPb.didGetMinMaxAtRange({
                                location: nSIdx,
                                length: nPeriod
                            });
                            void 0 !== xMinMax && null != xMinMax && (dHigh = xMinMax.dHigh, dLow = xMinMax.dLow), 
                            dData = (dHigh + dLow) / 2, xPlot.didSetData(nf_cnt, !0, dData);
                        }
                    }
                    return nLimit;
                };
                this.didReceiveData = function(symbolInfo, receivedDatas) {
                    _self.ReceiveData();
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset);
                    _ProcPlotPCL(0, _nPeriod1, nStart, nDSize, 0), _ProcPlotPCL(1, _nPeriod2, nStart, nDSize, 0), 
                    _ProcPlotBGSpan(nStart, nDSize);
                }, this.didGetShifRightCount = function() {
                    var nShiftCount = 0;
                    _self.m_nMoveShift > 0 && (nShiftCount = Math.abs(_self.m_nMoveShift));
                    for (var nPlotShiftCount = 0, nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                        var nMoveShift = _self.didGetPlotShiftValueAt(ii), nShiftRightCount = xUtils.didGetShifRightCount(nMoveShift);
                        nPlotShiftCount = Math.max(nPlotShiftCount, nShiftRightCount);
                    }
                    return nShiftCount += nPlotShiftCount;
                }, this.didGetShifLeftCount = function() {
                    var nShiftCount = 0;
                    _self.m_nMoveShift < 0 && (nShiftCount = Math.abs(_self.m_nMoveShift));
                    for (var nPlotShiftCount = 0, nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                        var nMoveShift = (_self.m_arrPlots[ii], _self.didGetPlotShiftValueAt(ii)), nShiftLeftCount = xUtils.didGetShifLeftCount(nMoveShift);
                        nPlotShiftCount = Math.max(nPlotShiftCount, nShiftLeftCount);
                    }
                    return nShiftCount += nPlotShiftCount;
                }, this.didGetPlotShiftValueAt = function(argNo) {
                    var nShiftOffset = 0;
                    return nShiftOffset = 1, 2 === argNo ? -1 * (_nPeriod3 - nShiftOffset) : 0;
                }, this.didGetShiftedDataIndexOfPlotAt = function(argDataIndex, argPlotNo) {
                    var nShiftValue = _self.didGetShiftValue(), xPlot = _self.didGetPlotAt(argPlotNo);
                    return void 0 !== xPlot && null != xPlot && !0 !== xPlot.hasIgnore() && !0 !== xPlot.hasHide() && (nShiftValue += xPlot.didGetShiftValue(!0)), 
                    xUtils.didConvertShiftedIndex(argDataIndex, nShiftValue);
                };
            }, _DOSHeikinAshi = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                this.m_nPlotLimit = 1;
                var _ProcPlot = function(nStart, nDSize, nCheck) {
                    for (var xPlot = (_self.didGetPriceFactor(), _self.didGetPlotAt(0)), nPeriod = _self.m_nPeriod, nLimit = 1 + nCheck + _self.m_nRefSkip, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var open, high, low, close, candle, reg_i = 0, nIdxC = 0, nIdxP = 0, kFactor = 2 / (nPeriod + 1);
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPriceCur, stPricePre;
                        if (nIdxC = reg_i, nIdxP = nIdxC - 1, nIdxC === nLimit) stPriceCur = _self.didGetReferencedBaseDataAt(nIdxC, !1), 
                        stPricePre = _self.didGetReferencedBaseDataAt(nIdxP, !1), open = (stPricePre.open + stPricePre.high + stPricePre.low + stPricePre.close) / 4, 
                        high = stPriceCur.high, low = stPriceCur.low, close = (stPriceCur.open + stPriceCur.high + stPriceCur.low + stPriceCur.close) / 4, 
                        candle = {
                            open: open,
                            high: high,
                            low: low,
                            close: close
                        }; else {
                            var candlePre = xPlot.didGetDataAt(nIdxP);
                            stPriceCur = _self.didGetReferencedBaseDataAt(nIdxC, !1), stPricePre = _self.didGetReferencedBaseDataAt(nIdxP, !1), 
                            open = candlePre.open + kFactor * (candlePre.close - candlePre.open), high = stPriceCur.high, 
                            low = stPriceCur.low, close = (stPriceCur.open + stPriceCur.high + stPriceCur.low + stPriceCur.close) / 4, 
                            candle = {
                                open: open,
                                high: high,
                                low: low,
                                close: close
                            };
                        }
                        xPlot.didSetData(reg_i, !0, candle);
                    }
                    return nLimit;
                };
                this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset), _ProcPlot(nStart, nDSize, 0);
                }, this.didGetPointValue = function() {
                    return _self.m_drawWrapper.didGetReferencedPriceObject().didGetPointValue();
                };
            }, _DOSRSI_TRIPLE = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                this.m_nPlotLimit = 5, this.m_nPrice = xUtils.constants.keywords.price.close;
                var _nPeriodS = 7, _nPeriodM = 14, _nPeriodL = 42;
                this.ParamSet = function() {
                    _nPeriodS = parseInt(_self.didGetParamValue(0)), _nPeriodM = parseInt(_self.didGetParamValue(1)), 
                    _nPeriodL = parseInt(_self.didGetParamValue(2));
                };
                var _ProcGL = function(nStart, nDSize, nCheck) {
                    for (var dFactor = (_self.didGetPointFactor(), _self.didGetPriceFactor()), xPlotG = _self.didGetPlotAt(3), xPlotL = _self.didGetPlotAt(4), nLimit = 1 + nCheck, nOffset = nStart, reg_i = 0, dData = 0, dDataP = 0, dGain = 0, dLoss = 0; nOffset < nLimit && nOffset < nDSize; ) xPlotG.didSetInvalidData(nOffset), 
                    xPlotL.didSetInvalidData(nOffset), nOffset++;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var nIdx = reg_i, nIdxP = reg_i - 1, stPrice = _self.didGetReferencedBaseDataAt(nIdx, !1), stPriceP = _self.didGetReferencedBaseDataAt(nIdxP, !1);
                        dDataP = xUtils.didGetPriceValue(stPriceP, _self.m_nPrice, dFactor), dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), 
                        dDataP < dData ? (dGain = dData - dDataP, dLoss = 0) : dDataP > dData ? (dGain = 0, 
                        dLoss = dDataP - dData) : (dGain = 0, dLoss = 0), xPlotG.didSetData(reg_i, !0, dGain), 
                        xPlotL.didSetData(reg_i, !0, dLoss);
                    }
                    return nLimit;
                }, _ProcRSI = function(plotNoRsi, nStart, nDSize, nCheck, nPeriod) {
                    for (var dPointFactor = _self.didGetPointFactor(), xPlotG = (_self.didGetPriceFactor(), 
                    _self.didGetPlotAt(3)), xPlotL = _self.didGetPlotAt(4), xPlotRSI = _self.didGetPlotAt(plotNoRsi), nLimit = nPeriod - 1 + nCheck, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlotRSI.didSetInvalidData(nOffset), 
                    nOffset++;
                    var reg_i = 0, reg_j = 0, dSumG = 0, dSumL = 0, dRSI = 0, dDiv = 0, dDive = 0;
                    if (nOffset >= nLimit) for (reg_j = nOffset; reg_j < nDSize; reg_j++) {
                        var isValid = !0;
                        dSumG = 0, dSumL = 0;
                        var nGo = reg_j - (nPeriod - 1), nStop = nGo + nPeriod;
                        for (reg_i = nGo; reg_i < nStop; reg_i++) dSumG += xPlotG.didGetDataAt(reg_i), dSumL += xPlotL.didGetDataAt(reg_i);
                        dDiv = dSumG + dSumL, dDive = dSumG, 0 === dDiv ? (isValid = !1, dRSI = 0) : (isValid = !0, 
                        dRSI = dDive / dDiv * 100 * dPointFactor), xPlotRSI.didSetData(reg_j, isValid, dRSI);
                    }
                    return nLimit;
                };
                this.didReceiveData = function(symbolInfo, receivedDatas) {
                    _self.ReceiveData();
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset);
                    var nCheck = _self.m_nRefSkip;
                    nCheck = _ProcGL(nStart, nDSize, nCheck), _ProcRSI(0, nStart, nDSize, nCheck, _nPeriodS), 
                    _ProcRSI(1, nStart, nDSize, nCheck, _nPeriodM), _ProcRSI(2, nStart, nDSize, nCheck, _nPeriodL);
                };
            }, _DOSStochastics_CFD = function() {
                var _self = this;
                this.prototype = new _DOSCFDBase(), _DOSCFDBase.apply(this, arguments);
                this.m_nPlotLimit = 5;
                var _nKPeriod = 9, _nDPeriod = 3, _nSPeriod = 3, _nSlowing = _nSPeriod;
                this.ParamSet = function() {
                    _nKPeriod = parseInt(_self.didGetParamValue(0)), _nDPeriod = parseInt(_self.didGetParamValue(1)), 
                    _nSPeriod = parseInt(_self.didGetParamValue(2)), _nSPeriod = Math.max(1, _nSPeriod), 
                    _nSlowing = _nSPeriod;
                };
                var _ProcK = function(nStart, nDSize, nCheck) {
                    for (var dPointFactor = _self.didGetPointFactor(), dFactor = _self.didGetPriceFactor(), xPlotK = _self.didGetPlotAt(0), xPlotM = _self.didGetPlotAt(3), xPlotN = _self.didGetPlotAt(4), nPeriod = _nKPeriod, nLimit = nPeriod - 1 + nCheck, nOffset = nStart, dHigh = -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, dLow = 1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, dDiv = 0, dDive = 0, dClose = 0, nf_cnt = 0, ns_cnt = 0, dFastK = 0; nOffset < nLimit && nOffset < nDSize; ) xPlotK.didSetInvalidData(nOffset), 
                    xPlotM.didSetInvalidData(nOffset), xPlotN.didSetInvalidData(nOffset), nOffset++;
                    if (nOffset >= nLimit) for (nf_cnt = nOffset; nf_cnt < nDSize; nf_cnt++) {
                        var stPrice;
                        stPrice = _self.didGetReferencedBaseDataAt(nf_cnt, !1), dClose = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.close, dFactor), 
                        dHigh = -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, dLow = 1 * xUtils.constants.default.DEFAULT_WRONG_VALUE;
                        var nGo = nf_cnt - (nPeriod - 1), nStop = nGo + nPeriod;
                        for (ns_cnt = nGo; ns_cnt < nStop; ns_cnt++) {
                            stPrice = _self.didGetReferencedBaseDataAt(ns_cnt, !1);
                            var tempHigh = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.high, dFactor), tempLow = xUtils.didGetPriceValue(stPrice, xUtils.constants.keywords.price.low, dFactor);
                            dHigh = Math.max(dHigh, tempHigh), dLow = Math.min(dLow, tempLow);
                        }
                        dDiv = dHigh - dLow, dDive = dClose - dLow, xPlotM.didSetData(nf_cnt, !0, dDiv), 
                        xPlotN.didSetData(nf_cnt, !0, dDive);
                        var isValidK = !0;
                        dDiv > 0 ? (isValidK = !0, dFastK = dPointFactor * (dDive / dDiv) * 100) : (isValidK = !1, 
                        dFastK = 0), xPlotK.didSetData(nf_cnt, isValidK, dFastK);
                    }
                    return nLimit;
                }, _ProcD = function(nStart, nDSize, nCheck) {
                    for (var dPointFactor = _self.didGetPointFactor(), xPlotD = (_self.didGetPriceFactor(), 
                    _self.didGetPlotAt(1)), xPlotM = _self.didGetPlotAt(3), xPlotN = _self.didGetPlotAt(4), nPeriod = _nDPeriod, nLimit = nPeriod - 1 + nCheck, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlotD.didSetInvalidData(nOffset), 
                    nOffset++;
                    var vInputM, vInputN, bFirst = !0, dSumM = 0, dSumN = 0, dPreM = 0, dPreN = 0, dDataM = 0, dDataN = 0, dMAM = 0, dMAN = 0, arrDataM = [], arrDataN = [], reg_j = 0, reg_i = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        if (bFirst) {
                            arrDataM = [], arrDataN = [];
                            var nGo = reg_i - (nPeriod - 1), nStop = nGo + nPeriod;
                            for (reg_j = nGo; reg_j < nStop; reg_j++) dDataM = xPlotM.didGetDataAt(reg_j), dDataN = xPlotN.didGetDataAt(reg_j), 
                            arrDataM.push(dDataM), arrDataN.push(dDataN);
                            vInputM = arrDataM, vInputN = arrDataN;
                        } else dDataM = xPlotM.didGetDataAt(reg_i), dSumM += dDataM, dDataM = xPlotM.didGetDataAt(reg_i - (nPeriod - 1)), 
                        dPreM = dDataM, dDataN = xPlotN.didGetDataAt(reg_i), dSumN += dDataN, dDataN = xPlotN.didGetDataAt(reg_i - (nPeriod - 1)), 
                        dPreN = dDataN, vInputM = dPreM, vInputN = dPreN;
                        var xSumM = xUtils.math.CalcSum(vInputM, dSumM, bFirst);
                        dMAM = xSumM.ret, dSumM = xSumM.sum;
                        var xSumN = xUtils.math.CalcSum(vInputN, dSumN, bFirst);
                        dMAN = xSumN.ret, dSumN = xSumN.sum;
                        var isValid = !1, dFastD = 0;
                        xUtils.MCR_ISZERO(dMAM) ? (isValid = !!xUtils.MCR_ISZERO(dMAN), dFastD = 0) : (isValid = !0, 
                        dFastD = dPointFactor * (dMAN / dMAM) * 100), xPlotD.didSetData(reg_i, isValid, dFastD), 
                        bFirst = !1;
                    }
                    return nLimit;
                }, _ProcSlowD = function(nStart, nDSize, nCheck) {
                    for (var xPlotS = (_self.didGetPointFactor(), _self.didGetPriceFactor(), _self.didGetPlotAt(2)), xPlotD = _self.didGetPlotAt(1), nPeriod = _nSPeriod, nLimit = nPeriod - 1 + nCheck, nOffset = nStart; nOffset < nLimit && nOffset < nDSize; ) xPlotS.didSetInvalidData(nOffset), 
                    nOffset++;
                    var vInput, bFirst = !0, dSumL = 0, dPreL = 0, dData = 0, arrData = [], reg_j = 0, reg_i = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        if (bFirst) {
                            arrData = [];
                            var nGo = reg_i - (nPeriod - 1), nStop = nGo + nPeriod;
                            for (reg_j = nGo; reg_j < nStop; reg_j++) dData = xPlotD.didGetDataAt(reg_j), arrData.push(dData);
                            vInput = arrData;
                        } else dData = xPlotD.didGetDataAt(reg_i), dSumL += dData, dData = xPlotD.didGetDataAt(reg_i - (nPeriod - 1)), 
                        dPreL = dData, vInput = dPreL;
                        var xMAEx = xUtils.math.CalcMAEx(vInput, dSumL, nPeriod, xUtils.math.constants.methods.simple, bFirst, !0);
                        dData = xMAEx.ma, dSumL = xMAEx.sum, xPlotS.didSetData(reg_i, !0, dData), bFirst = !1;
                    }
                    return nLimit;
                };
                this.didReceiveData = function(symbolInfo, receivedDatas) {
                    _self.ReceiveData();
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {
                    _self.SetRefSkip(bReset);
                    var nCheck = _self.m_nRefSkip;
                    nCheck = _ProcK(nStart, nDSize, nCheck), nCheck = _ProcD(nStart, nDSize, nCheck), 
                    nCheck = _ProcSlowD(nStart, nDSize, nCheck);
                };
            }, exports = {};
            return exports.didCreateSeriesInstance = function(argCode, argObjectInfo) {
                var _dosLocal = null;
                return argCode === xUtils.constants.indicatorCodes.BOLLINGER_BANDS_TRIPLE ? _dosLocal = new _DOSBollingerBandsTriple() : argCode === xUtils.constants.indicatorCodes.MACD ? _dosLocal = new _DOSMACD() : argCode === xUtils.constants.indicatorCodes.EMA_TRIPLE ? _dosLocal = new _DOSEMATriple() : argCode === xUtils.constants.indicatorCodes.RCI ? _dosLocal = new _DOSRCI() : argCode === xUtils.constants.indicatorCodes.ICHIMOKU_CFD ? _dosLocal = new _DOSIchimokuKinkouhyou_CFD() : argCode === xUtils.constants.indicatorCodes.SMA_TRIPLE ? _dosLocal = new _DOSSMATriple() : argCode === xUtils.constants.indicatorCodes.SPANMODEL ? _dosLocal = new _DOSSpanModel() : argCode === xUtils.constants.indicatorCodes.BOLLINGER_BANDS_TRIPLE_SUPER ? _dosLocal = new _DOSBollingerBandsTriple_Super() : argCode === xUtils.constants.indicatorCodes.HEIKINASHI ? _dosLocal = new _DOSHeikinAshi() : argCode === xUtils.constants.indicatorCodes.RSI_TRIPLE ? _dosLocal = new _DOSRSI_TRIPLE() : argCode === xUtils.constants.indicatorCodes.STOCHASTIC_CFD && (_dosLocal = new _DOSStochastics_CFD()), 
                !0 !== _dosLocal.didPrepareObject(argCode, argObjectInfo) && (_dosLocal.didDestroy(), 
                _dosLocal = null), _dosLocal;
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOSeriesCFD = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartDOSeriesBase) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1), __webpack_require__(29));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc, doBaseClass) {
            var _DOPlot = function() {
                var _self = this;
                this.m_xDoParent = null, this.m_strName = "plot", this.m_strDisp = "plot", this.m_point = 2, 
                this.m_arrDatas = [], this.m_arrValid = [], this.m_arrState = [], this.m_nMoveShift = 0, 
                this.m_bSelect = !1, this.m_nMoveShiftParamLink = void 0, this.m_xPlotInfo = {
                    name: "plot",
                    alias: "plot",
                    plotType: xUtils.indicator.plotType.ESDG_PLOTLINE,
                    plotStyle: xUtils.indicator.plotStyle.ESSS_PL_LINE,
                    color: "#ff0000",
                    lineWeight: 1,
                    lineStyle: gxDc.penstyle.solid,
                    ignore: !1,
                    extraDiff: null,
                    targetPrice: 0
                }, this.DeselectAllObject = function() {
                    _self.m_bSelect = !1;
                }, this.didGetEnvInfo = function() {
                    return _self.m_xDoParent.didGetEnvInfo();
                }, this.didClearDatas = function() {
                    _self.m_arrDatas = [], _self.m_arrValid = [], _self.m_arrState = [];
                }, this.didGetReferencedBaseDataAt = function(dataIndex, bScreen) {
                    return _self.m_xDoParent.didGetReferencedBaseDataAt(dataIndex, bScreen);
                }, this.didSetSize = function(argSize, bFlag) {
                    var nDataCount = _self.m_arrDatas.length, nDiff = argSize - nDataCount;
                    if (nDiff > 0) for (var bValid = !1 !== bFlag, dValue = !0 === bFlag ? xUtils.constants.default.DEFAULT_WRONG_VALUE : 0, ii = 0; ii < nDiff; ii++) _self.didAddData(bValid, dValue);
                }, this.didAddData = function(isValid, data, state) {
                    return _self.m_arrValid.push(isValid), _self.m_arrDatas.push(data), _self.m_arrState.push(state), 
                    _self.m_arrDatas.length - 1;
                }, this.didRemoveDataAt = function(argIndex) {
                    var nDataCount = _self.m_arrDatas.length;
                    if (nDataCount < 1 && argIndex < 0 || argIndex >= nDataCount) return !1;
                    _self.m_arrValid.splice(argIndex, 1), _self.m_arrDatas.splice(argIndex, 1), _self.m_arrState.splice(argIndex, 1);
                }, this.didSetInvalidData = function(argIndex) {
                    return _self.didSetData(argIndex, !1, xUtils.constants.default.DEFAULT_WRONG_VALUE);
                }, this.didSetData = function(argIndex, isValid, data, state) {
                    var nDataCount = _self.m_arrDatas.length;
                    if (!(nDataCount < 1 && argIndex < 0 || argIndex >= nDataCount)) return _self.m_arrValid[argIndex] = isValid, 
                    _self.m_arrDatas[argIndex] = data, _self.m_arrState[argIndex] = state, argIndex;
                }, this.didCalcMinMax = function(argDataSIdx, argScrSize, argFlag) {
                    if (!0 !== _self.hasIgnore() && !0 !== _self.hasHide()) {
                        if (!(_self.didGetDataSize() < 1)) {
                            for (var result = {
                                nMaxIndex: -1,
                                nMaxPrice: -xUtils.constants.default.DEFAULT_WRONG_VALUE,
                                nMinIndex: -1,
                                nMinPrice: xUtils.constants.default.DEFAULT_WRONG_VALUE
                            }, ii = 0; ii < argScrSize; ii++) {
                                var dataIndex = argDataSIdx + ii, shiftedIndex = _self.didGetShiftedDataIndex(dataIndex, !1), dataValue = _self.m_arrDatas[shiftedIndex];
                                void 0 === dataValue || dataValue === xUtils.constants.default.DEFAULT_WRONG_VALUE || _self.m_bPriceType && 0 === dataValue || (dataValue > result.nMaxPrice && (result.nMaxPrice = dataValue, 
                                result.nMaxIndex = shiftedIndex), dataValue < result.nMinPrice && (result.nMinPrice = dataValue, 
                                result.nMinIndex = shiftedIndex));
                            }
                            if (_self.m_xPlotInfo.plotStyle === xUtils.indicator.plotStyle.ESSS_PL_STICK) {
                                var nBaseValue = 0, baseValue = _self.m_xPlotInfo.baseValue;
                                void 0 !== baseValue && null != baseValue && (nBaseValue = "number" == typeof baseValue ? baseValue : parseInt(baseValue)), 
                                nBaseValue > result.nMaxPrice && (result.nMaxPrice = nBaseValue), nBaseValue < result.nMinPrice && (result.nMinPrice = nBaseValue);
                            }
                            return result;
                        }
                    }
                }, this.hasIgnore = function() {
                    return !0 === _self.m_xPlotInfo.ignore;
                }, this.hasHide = function() {
                    return !0 === _self.m_xPlotInfo.hide;
                }, this.isValidAt = function(dataIdx) {
                    return _self.m_arrValid[dataIdx];
                }, this.didGetDataSize = function() {
                    return _self.m_arrDatas.length;
                }, this.didGetDataAt = function(dataIdx) {
                    return _self.m_arrDatas[dataIdx];
                }, this.didGetStateAt = function(dataIdx) {
                    return _self.m_arrState[dataIdx];
                }, this.didGetStateColorAt = function(dataIdx) {
                    var xEnv = _self.didGetEnvInfo(), plotStyle = _self.m_xPlotInfo.plotStyle;
                    if (plotStyle === xUtils.indicator.plotStyle.ESSS_PL_STICK) {
                        if (!0 === _self.m_xPlotInfo.usePriceUpDn) {
                            var stPrice = _self.didGetReferencedBaseDataAt(dataIdx, !1);
                            return !0 === xUtils.dataConverter.isMinusCandleForPriceData(stPrice) ? xEnv.PriceStyleConfig.Candle.fillDnColor : xEnv.PriceStyleConfig.Candle.fillUpColor;
                        }
                        if (!0 === _self.m_xPlotInfo.useBarUpDn) {
                            var stPrice = _self.didGetReferencedBaseDataAt(dataIdx, !1);
                            if (!0 === xUtils.dataConverter.isMinusCandleForPriceData(stPrice)) {
                                if (void 0 !== _self.m_xPlotInfo.colorDn && null != _self.m_xPlotInfo.colorDn) return _self.m_xPlotInfo.colorDn;
                            } else if (void 0 !== _self.m_xPlotInfo.colorUp && null != _self.m_xPlotInfo.colorUp) return _self.m_xPlotInfo.colorUp;
                        }
                    } else if (plotStyle === xUtils.indicator.plotStyle.ESSS_PL_POINT) {
                        var plotState = _self.didGetStateAt(dataIdx);
                        if (plotState === xUtils.indicator.plotState.stateUp && void 0 !== _self.m_xPlotInfo.colorUp && null != _self.m_xPlotInfo.colorUp) return _self.m_xPlotInfo.colorUp;
                        if (plotState === xUtils.indicator.plotState.stateDn && void 0 !== _self.m_xPlotInfo.colorDn && null != _self.m_xPlotInfo.colorDn) return _self.m_xPlotInfo.colorDn;
                    }
                    return _self.m_xPlotInfo.color;
                }, this.didGetPointedDataAt = function(argIndex) {
                    return Math.round(_self.didGetDataAt(argIndex));
                }, this.didGetDebugPointedDataAt = function(argIndex, pointValue) {
                    var plotData = _self.didGetDataAt(argIndex);
                    return xUtils.number.didGetPointedValue(plotData, pointValue);
                }, this.didGetShiftValue = function(onlySelf) {
                    var nShiftValue = 0;
                    return !0 !== onlySelf && (nShiftValue = _self.m_xDoParent.didGetShiftValue()), 
                    void 0 !== _self.m_nMoveShiftParamLink && null != _self.m_nMoveShiftParamLink ? nShiftValue += _self.m_xDoParent.didGetPlotShiftValueAt(_self.m_nMoveShiftParamLink) : nShiftValue += _self.m_nMoveShift, 
                    nShiftValue;
                }, this.didGetShifLeftCount = function() {
                    return xUtils.didGetShifLeftCount(_self.m_nMoveShift);
                }, this.didGetShifRightCount = function() {
                    return xUtils.didGetShifRightCount(_self.m_nMoveShift);
                }, this.didSetShiftInfo = function(argInfo) {
                    void 0 !== argInfo.moveShiftParamLink && null != argInfo.moveShiftParamLink && (_self.m_nMoveShiftParamLink = argInfo.moveShiftParamLink), 
                    _self.m_nMoveShift = xUtils.didCalculateShiftInfo(argInfo, xUtils.constants.default.SHIFT_IS_ST);
                }, this.FindValidIdx = function(nSIdx, bNext) {
                    var nDCnt = _self.didGetDataSize();
                    if (!(nDCnt < 1 || nSIdx < 0 || nSIdx >= nDCnt)) {
                        var reg_i = 0;
                        if (bNext) for (reg_i = nSIdx + 1; reg_i < nDCnt; reg_i++) {
                            var isValid = _self.isValidAt(reg_i);
                            if (!0 === isValid) return reg_i;
                        } else for (reg_i = nSIdx - 1; reg_i >= 0; reg_i--) {
                            var isValid = _self.isValidAt(reg_i);
                            if (!0 === isValid) return reg_i;
                        }
                    }
                }, this.didSetPlotInfo = function(argInfo, isChanged) {
                    return void 0 !== argInfo && null != argInfo && (!0 === isChanged ? (_self.m_xPlotInfo.alias = argInfo.alias, 
                    _self.m_xPlotInfo.plotStyle = argInfo.plotStyle, _self.m_xPlotInfo.color = argInfo.color, 
                    _self.m_xPlotInfo.lineWeight = argInfo.lineWeight, _self.m_xPlotInfo.lineStyle = argInfo.lineStyle, 
                    _self.m_xPlotInfo.colorUp = argInfo.colorUp, _self.m_xPlotInfo.colorDn = argInfo.colorDn, 
                    _self.m_xPlotInfo.hide = argInfo.hide) : (_self.m_xPlotInfo = argInfo, _self.m_strName = _self.m_xPlotInfo.name), 
                    _self.m_strDisp = _self.m_xPlotInfo.alias, _self.didSetShiftInfo(argInfo), !0);
                }, this.didDrawSelectedMark = function(argLocalPosX, argLocalPosY) {
                    _self.m_xDoParent.didDrawSelectedMark(argLocalPosX, argLocalPosY);
                }, this.didGetShiftedDataIndex = function(argIndex, onlySelf, toDataIndex) {
                    var nShiftValue = _self.didGetShiftValue(onlySelf);
                    return xUtils.didConvertShiftedIndex(argIndex, nShiftValue, toDataIndex);
                }, this.didGetAxisX = function() {
                    return _self.m_xDoParent.m_drawWrapper;
                }, this.didGetAxisY = function() {
                    return _self.m_xDoParent;
                }, this.didGetContext = function(bHitTest) {
                    return !0 === bHitTest ? _self.m_xDoParent.m_memcontext : _self.m_xDoParent.m_context;
                }, this.didHitTest = function(hitTestTool, dataIndexAtPos) {
                    if (!0 === _self.hasIgnore() || !0 === _self.hasHide()) return !1;
                    if (void 0 === hitTestTool || null == hitTestTool) return !1;
                    hitTestTool.willBeHitTest(), _self.didDrawObj(!0);
                    var result = hitTestTool.didHitTest();
                    return hitTestTool.closeHitTest(), result;
                }, this.didDrawObj = function(isHitTest) {
                    var drawWrapper = _self.m_xDoParent.m_drawWrapper, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), context = _self.didGetContext(), nScrSize = (drawWrapper.m_xScrollInfo.pos, 
                    drawWrapper.m_xScrollInfo.screenSize), bHitTest = !1, bSelected = !1, baseValue = _self.m_xPlotInfo.baseValue, plotStyle = _self.m_xPlotInfo.plotStyle, lineStyle = _self.m_xPlotInfo.lineStyle, lineWeight = _self.m_xPlotInfo.lineWeight, lineColorVal = _self.m_xPlotInfo.color, fillColorVal = _self.m_xPlotInfo.color, colorUp = _self.m_xPlotInfo.colorUp, colorDn = _self.m_xPlotInfo.colorDn;
                    if (!0 === isHitTest) bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                    fillColorVal = xUtils.hitTest.config.color, colorUp = xUtils.hitTest.config.color, 
                    colorDn = xUtils.hitTest.config.color, context = _self.didGetContext(!0); else {
                        var xEnv = _self.didGetEnvInfo();
                        void 0 === xEnv || null == xEnv || !0 !== _self.m_xDoParent.m_bSelect && !0 !== _self.m_bSelect || (bSelected = !0, 
                        lineColorVal = xEnv.System.SelectedFill.lineColor, fillColorVal = xEnv.System.SelectedFill.lineColor, 
                        colorUp = xEnv.System.SelectedFill.lineColor, colorDn = xEnv.System.SelectedFill.lineColor);
                    }
                    var drawLineParam = {
                        context: context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineStyle: lineStyle,
                        lineWidth: lineWeight,
                        lineColor: lineColorVal
                    }, drawRectParam = {
                        context: context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: lineWeight,
                        lineColor: lineColorVal,
                        fillColor: fillColorVal
                    }, drawCircleParam = {
                        context: context,
                        pt: {
                            x: 0,
                            y: 0
                        },
                        radius: 0,
                        lineWidth: lineWeight,
                        lineColor: lineColorVal,
                        fillColor: fillColorVal
                    };
                    if (plotStyle === xUtils.indicator.plotStyle.ESSS_PL_STICK) for (var nDataIdx = 0; nDataIdx < nScrSize; nDataIdx++) {
                        var dataIndex = xAxisX.didConvertLocalIndexToDataIndex(nDataIdx), shiftedIndex = _self.didGetShiftedDataIndex(dataIndex), dataValue = _self.m_arrDatas[shiftedIndex];
                        if (!0 === xUtils.dataValidator.isValidData(dataValue)) {
                            if (!0 === _self.m_xPlotInfo.usePriceUpDn) {
                                if (!0 !== bHitTest && !0 !== bSelected) {
                                    var stPrice = _self.didGetReferencedBaseDataAt(dataIndex, !1);
                                    lineColorVal = fillColorVal = !0 === xUtils.dataConverter.isMinusCandleForPriceData(stPrice) ? xEnv.PriceStyleConfig.Candle.fillDnColor : xEnv.PriceStyleConfig.Candle.fillUpColor;
                                }
                            } else if (!0 === _self.m_xPlotInfo.useBarUpDn && !0 !== bHitTest && !0 !== bSelected) {
                                var stPrice = _self.didGetReferencedBaseDataAt(dataIndex, !1);
                                lineColorVal = fillColorVal = !0 === xUtils.dataConverter.isMinusCandleForPriceData(stPrice) ? colorDn : colorUp;
                            }
                            var xBarInfos = {}, nLocalXPos = xAxisX.GetIndex2Pixel(dataIndex, xBarInfos), nLocalYPos1 = xAxisY.GetYPos(dataValue), nBaseValue = 0;
                            void 0 !== baseValue && null != baseValue && (nBaseValue = "number" == typeof baseValue ? baseValue : parseInt(baseValue));
                            var rcX, rcY, rcW, rcH, nLocalYPos2 = xAxisY.GetYPos(nBaseValue);
                            rcX = xBarInfos.pos, rcW = xBarInfos.width, nLocalYPos1 === nLocalYPos2 ? (rcY = nLocalYPos1, 
                            rcH = 1, drawLineParam.pt1.x = rcX, drawLineParam.pt1.y = rcY, drawLineParam.pt2.x = rcX + rcW, 
                            drawLineParam.pt2.y = rcY, drawLineParam.lineColor = lineColorVal, gxDc.Line(drawLineParam)) : (rcY = nLocalYPos1 > nLocalYPos2 ? nLocalYPos2 : nLocalYPos1, 
                            rcH = Math.abs(nLocalYPos2 - nLocalYPos1), drawRectParam.rect.x = rcX, drawRectParam.rect.y = rcY, 
                            drawRectParam.rect.width = rcW, drawRectParam.rect.height = rcH, drawRectParam.lineColor = lineColorVal, 
                            drawRectParam.fillColor = fillColorVal, gxDc.Rectangle(drawRectParam));
                        }
                    } else if (plotStyle === xUtils.indicator.plotStyle.ESSS_PL_POINT) for (var nDataIdx = 0; nDataIdx < nScrSize; nDataIdx++) {
                        var dataIndex = xAxisX.didConvertLocalIndexToDataIndex(nDataIdx), shiftedIndex = _self.didGetShiftedDataIndex(dataIndex), dataValue = _self.m_arrDatas[shiftedIndex];
                        if (!0 === xUtils.dataValidator.isValidData(dataValue)) {
                            var plotState = _self.didGetStateAt(shiftedIndex);
                            plotState === xUtils.indicator.plotState.stateUp ? lineColorVal = fillColorVal = colorUp : plotState === xUtils.indicator.plotState.stateDn && (lineColorVal = fillColorVal = colorDn);
                            var rcX, rcY, rcW, rcH, xBarInfos = {}, nLocalXPos = xAxisX.GetIndex2Pixel(dataIndex, xBarInfos), nLocalYPos = xAxisY.GetYPos(dataValue);
                            rcX = xBarInfos.pos, rcW = xBarInfos.width;
                            var radius = parseInt(xBarInfos.width / 2);
                            radius < 1 && (radius = 1), drawCircleParam.pt.x = nLocalXPos, drawCircleParam.pt.y = nLocalYPos, 
                            drawCircleParam.radius = radius, drawCircleParam.lineColor = lineColorVal, drawCircleParam.fillColor = fillColorVal, 
                            gxDc.Circle(drawCircleParam);
                        }
                    } else for (var nDataIdx = 0; nDataIdx < nScrSize; nDataIdx++) {
                        var dataIndex1 = xAxisX.didConvertLocalIndexToDataIndex(nDataIdx), shiftedIndex1 = _self.didGetShiftedDataIndex(dataIndex1), dataIndex2 = dataIndex1 + 1, shiftedIndex2 = shiftedIndex1 + 1, dataValue1 = _self.m_arrDatas[shiftedIndex1], dataValue2 = _self.m_arrDatas[shiftedIndex2];
                        if (!0 === xUtils.dataValidator.isValidData(dataValue1) && !0 === xUtils.dataValidator.isValidData(dataValue2)) {
                            var nLocalXPos1 = xAxisX.GetXPosAtDataIndex(dataIndex1), nLocalXPos2 = xAxisX.GetXPosAtDataIndex(dataIndex2), nLocalYPos1 = xAxisY.GetYPos(dataValue1), nLocalYPos2 = xAxisY.GetYPos(dataValue2);
                            drawLineParam.pt1.x = nLocalXPos1, drawLineParam.pt1.y = nLocalYPos1, drawLineParam.pt2.x = nLocalXPos2, 
                            drawLineParam.pt2.y = nLocalYPos2, drawLineParam.lineColor = lineColorVal, gxDc.Line(drawLineParam);
                        }
                    }
                }, this.didDrawDataView = function(argPtDraw, argDataIndex) {
                    if (!0 === _self.hasIgnore() || !0 === _self.hasHide()) return argPtDraw;
                    var drawTextParam = argPtDraw, shiftedIndex = _self.didGetShiftedDataIndex(argDataIndex), plotData = _self.didGetPointedDataAt(shiftedIndex), plotDataValid = _self.isValidAt(shiftedIndex), textSpace = (_self.didGetStateAt(shiftedIndex), 
                    _self.m_xDoParent.m_drawWrapper, _self.m_xDoParent, _self.m_xDoParent, drawTextParam.textSpace), pointValue = _self.m_xDoParent.didGetPointValue();
                    drawTextParam.fillStyle = _self.m_xPlotInfo.color;
                    var strData = xUtils.constants.text.dataView.invalid;
                    !0 === plotDataValid && (strData = xUtils.number.didGetPointedValue(plotData, pointValue));
                    var strDisplay = _self.m_strDisp + "(" + strData + ")";
                    drawTextParam.text = strDisplay;
                    var textLen = gxDc.TextOut(drawTextParam, !0);
                    return drawTextParam.pt.x = drawTextParam.pt.x + textLen + textSpace, drawTextParam;
                }, this.DrawLastValue = function(argDrawParam, dataIndex) {
                    try {
                        if (void 0 === argDrawParam || null == argDrawParam) return;
                        var xEnv = _self.didGetEnvInfo(), colorUp = _self.m_xPlotInfo.colorUp, colorDn = _self.m_xPlotInfo.colorDn, shiftedIndex = _self.didGetShiftedDataIndex(dataIndex), dataValue = _self.m_arrDatas[shiftedIndex];
                        if (!0 !== xUtils.dataValidator.isValidData(dataValue)) return;
                        argDrawParam.price.value = dataValue, argDrawParam.price.color = _self.m_xPlotInfo.color;
                        var plotStyle = _self.m_xPlotInfo.plotStyle;
                        if (plotStyle === xUtils.indicator.plotStyle.ESSS_PL_STICK) {
                            if (!0 === _self.m_xPlotInfo.usePriceUpDn) {
                                var stPrice = _self.didGetReferencedBaseDataAt(dataIndex, !1);
                                !0 === xUtils.dataConverter.isMinusCandleForPriceData(stPrice) ? argDrawParam.price.color = xEnv.PriceStyleConfig.Candle.fillDnColor : argDrawParam.price.color = xEnv.PriceStyleConfig.Candle.fillUpColor;
                            }
                            if (!0 === _self.m_xPlotInfo.useBarUpDn) {
                                var stPrice = _self.didGetReferencedBaseDataAt(dataIndex, !1);
                                !0 === xUtils.dataConverter.isMinusCandleForPriceData(stPrice) ? argDrawParam.price.color = colorDn : argDrawParam.price.color = colorUp;
                            }
                        } else if (plotStyle === xUtils.indicator.plotStyle.ESSS_PL_POINT) {
                            var plotState = _self.didGetStateAt(shiftedIndex);
                            plotState === xUtils.indicator.plotState.stateUp ? argDrawParam.price.color = colorUp : plotState === xUtils.indicator.plotState.stateDn && (argDrawParam.price.color = colorDn);
                        }
                        xUtils.axis.didDrawLastValueOnYAxis(argDrawParam);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didGetDataViewDataAt = function(argDataIndex) {
                    if (!0 !== _self.hasIgnore() && !0 !== _self.hasHide()) {
                        var shiftedIndex = _self.didGetShiftedDataIndex(argDataIndex), plotData = _self.didGetPointedDataAt(shiftedIndex), plotDataValid = _self.isValidAt(shiftedIndex), pointValue = (_self.didGetStateAt(shiftedIndex), 
                        _self.m_xDoParent.didGetPointValue()), strData = xUtils.constants.text.dataView.invalid;
                        !0 === plotDataValid && (strData = xUtils.number.didGetPointedValue(plotData, pointValue));
                        var color = _self.didGetStateColorAt(shiftedIndex);
                        return {
                            display: _self.m_strDisp,
                            value: strData,
                            color: color
                        };
                    }
                }, this.didPrintDebugData = function() {
                    for (var pointValue = _self.m_xDoParent.didGetPointValue(), nDataCount = _self.m_arrDatas.length, ii = 0; ii < nDataCount; ii++) if (!0 !== _self.m_arrValid[ii]) ; else {
                        var plotData = _self.didGetPointedDataAt(ii), plotState = (xUtils.number.didGetPointedValue(plotData, pointValue), 
                        _self.didGetStateAt(shiftedIndex)), strDivide = ":\t";
                        plotState === xUtils.indicator.plotState.stateUp ? strDivide = "[U]" + strDivide : plotState === xUtils.indicator.plotState.stateDn && (strDivide = "[D]" + strDivide);
                    }
                };
            }, _DOPlotSidebar = function() {
                var _self = this;
                this.prototype = new _DOPlot(), _DOPlot.apply(this, arguments), this.didDrawDataView = function(argPtDraw, argDataIndex) {
                    if (!0 === _self.hasIgnore() || !0 === _self.hasHide()) return argPtDraw;
                    var drawTextParam = argPtDraw, plotData = _self.didGetPointedDataAt(argDataIndex), plotDataValid = _self.isValidAt(argDataIndex), textSpace = (_self.m_xDoParent.m_drawWrapper, 
                    _self.m_xDoParent, _self.m_xDoParent, drawTextParam.textSpace), pointValue = _self.m_xDoParent.didGetPointValue();
                    drawTextParam.fillStyle = _self.m_xPlotInfo.color;
                    var strData = xUtils.constants.text.dataView.invalid;
                    !0 === plotDataValid && (strData = xUtils.number.didGetPointedValue(plotData, pointValue));
                    var strDisplay = _self.m_strDisp + "(" + strData + ")";
                    drawTextParam.text = strDisplay;
                    var textLen = gxDc.TextOut(drawTextParam, !0);
                    return drawTextParam.pt.x = drawTextParam.pt.x + textLen + textSpace, drawTextParam;
                }, this.didGetDataViewDataAt = function(argDataIndex) {
                    if (!0 !== _self.hasIgnore() && !0 !== _self.hasHide()) {
                        var shiftedIndex = _self.didGetShiftedDataIndex(argDataIndex), plotData = _self.didGetPointedDataAt(shiftedIndex), plotDataValid = _self.isValidAt(shiftedIndex), pointValue = _self.m_xDoParent.didGetPointValue(), strData = xUtils.constants.text.dataView.invalid;
                        !0 === plotDataValid && (strData = xUtils.number.didGetPointedValue(plotData, pointValue));
                        return {
                            display: _self.m_strDisp,
                            value: strData,
                            color: _self.m_xPlotInfo.color
                        };
                    }
                }, this.didGetAxisX = function() {
                    return _self.m_xDoParent.didGetAxisX();
                }, this.didCalcMinMax = function(argDataSIdx, argScrSize, argFlag) {
                    if (!0 !== _self.hasIgnore() && !0 !== _self.hasHide()) {
                        if (!(_self.didGetDataSize() < 1)) {
                            for (var result = {
                                nMaxIndex: -1,
                                nMaxPrice: -xUtils.constants.default.DEFAULT_WRONG_VALUE,
                                nMinIndex: -1,
                                nMinPrice: xUtils.constants.default.DEFAULT_WRONG_VALUE,
                                nMaxVolIdx: -1,
                                nMaxVolume: -xUtils.constants.default.DEFAULT_WRONG_VALUE,
                                nMinVolIdx: -1,
                                nMinVolume: xUtils.constants.default.DEFAULT_WRONG_VALUE
                            }, nTDSize = _self.m_arrDatas.length, ii = 0; ii < nTDSize; ii++) {
                                var dataIndex = ii, dataValue = _self.m_arrDatas[dataIndex].dValue, dHVal = _self.m_arrDatas[dataIndex].dHVal, dLVal = _self.m_arrDatas[dataIndex].dLVal;
                                dataValue > result.nMaxVolume && (result.nMaxVolume = dataValue, result.nMaxVolIdx = dataIndex), 
                                dataValue < result.nMinVolume && (result.nMinVolume = dataValue, result.nMinVolIdx = dataIndex), 
                                dHVal > result.nMaxPrice && (result.nMaxPrice = dHVal, result.nMaxIndex = dataIndex), 
                                dLVal < result.nMinPrice && (result.nMinPrice = dLVal, result.nMinIndex = dataIndex);
                            }
                            return result;
                        }
                    }
                }, this.didSetInvalidData = function(argIndex) {
                    return _self.didSetData(argIndex, !1, 0);
                }, this.didSetSize = function(argSize, bFlag) {
                    var nDataCount = _self.m_arrDatas.length, nDiff = argSize - nDataCount;
                    if (nDiff > 0) for (var ii = 0; ii < nDiff; ii++) {
                        var bValid = !1 !== bFlag, xDatas = {
                            dValue: 0,
                            dLVal: 0,
                            dHVal: 0
                        };
                        _self.didAddData(bValid, xDatas);
                    }
                }, this.didSetData = function(argIndex, isValid, data, lval, hval) {
                    var nDataCount = _self.m_arrDatas.length;
                    if (!(nDataCount < 1 && argIndex < 0 || argIndex >= nDataCount)) return _self.m_arrValid[argIndex] = isValid, 
                    _self.m_arrDatas[argIndex] = {
                        dValue: data,
                        dLVal: void 0 === lval || null == lval ? data : lval,
                        dHVal: void 0 === hval || null == hval ? -1 * data : hval
                    }, argIndex;
                }, this.didDrawObj = function(isHitTest) {
                    var drawWrapper = _self.m_xDoParent.m_drawWrapper, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), context = _self.didGetContext(), lineWeight = (drawWrapper.m_xScrollInfo.pos, 
                    drawWrapper.m_xScrollInfo.screenSize, _self.m_arrDatas.length, _self.m_xPlotInfo.lineWeight), lineColorVal = _self.m_xPlotInfo.color, fillColorVal = _self.m_xPlotInfo.color;
                    if (!0 === isHitTest) !0, lineColorVal = xUtils.hitTest.config.color, fillColorVal = xUtils.hitTest.config.color, 
                    context = _self.didGetContext(!0); else {
                        var xEnv = _self.didGetEnvInfo();
                        void 0 === xEnv || null == xEnv || !0 !== _self.m_xDoParent.m_bSelect && !0 !== _self.m_bSelect || (lineColorVal = xEnv.System.SelectedFill.lineColor, 
                        fillColorVal = xEnv.System.SelectedFill.lineColor);
                    }
                    for (var drawRectParam = {
                        context: context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: lineWeight,
                        lineColor: lineColorVal,
                        fillColor: fillColorVal,
                        fillAlpha: .5
                    }, nDataCount = _self.didGetDataSize(), nDataIdx = 0; nDataIdx < nDataCount; nDataIdx++) {
                        var xAv = _self.m_arrDatas[nDataIdx], nLocalXPos1 = xAxisX.GetXData2Pixel(xAv.dValue), nLocalXPos2 = xAxisX.GetXData2Pixel(), nLocalYPos1 = xAxisY.GetYPos(xAv.dHVal), nLocalYPos2 = xAxisY.GetYPos(xAv.dLVal), nLocalYCPos = (nLocalYPos1 + nLocalYPos2) / 2, nBar = Math.abs(.8 * (nLocalYPos1 - nLocalYPos2) / 2);
                        drawRectParam.rect.x = nLocalXPos1, drawRectParam.rect.width = nLocalXPos2 - nLocalXPos1 + 1, 
                        drawRectParam.rect.y = nLocalYCPos - nBar, drawRectParam.rect.height = 2 * nBar + 1, 
                        gxDc.Rectangle(drawRectParam);
                    }
                };
            }, _DOPlotCandlebar = function() {
                var _self = this;
                this.prototype = new _DOPlot(), _DOPlot.apply(this, arguments), this.didDrawDataView = function(argPtDraw, argDataIndex) {
                    if (!0 === _self.hasIgnore() || !0 === _self.hasHide()) return argPtDraw;
                    var drawTextParam = argPtDraw, plotData = _self.didGetPointedDataAt(argDataIndex), plotDataValid = _self.isValidAt(argDataIndex), textSpace = (_self.m_xDoParent.m_drawWrapper, 
                    _self.m_xDoParent, _self.m_xDoParent, drawTextParam.textSpace), pointValue = _self.m_xDoParent.didGetPointValue();
                    drawTextParam.fillStyle = _self.m_xPlotInfo.color;
                    var strData = xUtils.constants.text.dataView.invalid;
                    !0 === plotDataValid && (strData = xUtils.number.didGetPointedValue(plotData, pointValue));
                    var strDisplay = _self.m_strDisp + "(" + strData + ")";
                    drawTextParam.text = strDisplay;
                    var textLen = gxDc.TextOut(drawTextParam, !0);
                    return drawTextParam.pt.x = drawTextParam.pt.x + textLen + textSpace, drawTextParam;
                }, this.didGetDataViewDataAt = function(argDataIndex) {
                    if (!0 !== _self.hasIgnore() && !0 !== _self.hasHide()) {
                        var xData, target, shiftedIndex = _self.didGetShiftedDataIndex(argDataIndex), plotData = _self.m_arrDatas[shiftedIndex], plotDataValid = xUtils.validator.isValidPrice(plotData), pointValue = _self.m_xDoParent.didGetPointValue(), xViewDatas = [], xViewItem = {
                            display: "",
                            value: xUtils.constants.text.dataView.invalid
                        };
                        return !0 === plotDataValid ? (xData = xUtils.didClone(xViewItem), target = "open", 
                        xData = xUtils.didClone(xViewItem), xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xData.value = xUtils.didGetPriceDisplay(target, plotData, pointValue, !0), xViewDatas.push(xData), 
                        target = "high", xData = xUtils.didClone(xViewItem), xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xData.value = xUtils.didGetPriceDisplay(target, plotData, pointValue, !0), xViewDatas.push(xData), 
                        target = "low", xData = xUtils.didClone(xViewItem), xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xData.value = xUtils.didGetPriceDisplay(target, plotData, pointValue, !0), xViewDatas.push(xData), 
                        target = "close", xData = xUtils.didClone(xViewItem), xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xData.value = xUtils.didGetPriceDisplay(target, plotData, pointValue, !0), xViewDatas.push(xData)) : (target = "open", 
                        xData = xUtils.didClone(xViewItem), xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xViewDatas.push(xData), target = "high", xData = xUtils.didClone(xViewItem), xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xViewDatas.push(xData), target = "low", xData = xUtils.didClone(xViewItem), xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xViewDatas.push(xData), target = "close", xData = xUtils.didClone(xViewItem), xData.display = xUtils.didGetDataViewItemTitle(target), 
                        xViewDatas.push(xData)), xViewDatas;
                    }
                }, this.DrawLastValue = function(argDrawParam, dataIndex) {
                    try {
                        if (void 0 === argDrawParam || null == argDrawParam) return;
                        var xEnv = _self.didGetEnvInfo(), shiftedIndex = (_self.m_xPlotInfo.colorUp, _self.m_xPlotInfo.colorDn, 
                        _self.didGetShiftedDataIndex(dataIndex)), plotData = _self.m_arrDatas[shiftedIndex];
                        if (!0 !== xUtils.validator.isValidPrice(plotData)) return;
                        argDrawParam.price.value = plotData.close;
                        var color = xEnv.PriceStyleConfig.Candle.fillDnColor;
                        !0 !== xUtils.dataConverter.isMinusCandleForPriceData(plotData) && (color = xEnv.PriceStyleConfig.Candle.fillUpColor), 
                        argDrawParam.price.color = color, xUtils.axis.didDrawLastValueOnYAxis(argDrawParam);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didGetAxisX = function() {
                    return _self.m_xDoParent.didGetAxisX();
                }, this.didCalcMinMax = function(argDataSIdx, argScrSize, argFlag) {
                    if (!0 !== _self.hasIgnore() && !0 !== _self.hasHide()) {
                        if (!(_self.didGetDataSize() < 1)) {
                            for (var result = {
                                nMaxIndex: -1,
                                nMaxPrice: -xUtils.constants.default.DEFAULT_WRONG_VALUE,
                                nMinIndex: -1,
                                nMinPrice: xUtils.constants.default.DEFAULT_WRONG_VALUE,
                                nMaxVolIdx: -1,
                                nMaxVolume: -xUtils.constants.default.DEFAULT_WRONG_VALUE,
                                nMinVolIdx: -1,
                                nMinVolume: xUtils.constants.default.DEFAULT_WRONG_VALUE
                            }, ii = 0; ii < argScrSize; ii++) {
                                var dataIndex = argDataSIdx + ii, shiftedIndex = _self.didGetShiftedDataIndex(dataIndex, !1), stCandle = _self.m_arrDatas[shiftedIndex];
                                if (!0 === xUtils.validator.isValidPrice(stCandle)) {
                                    var dHVal = stCandle.high, dLVal = stCandle.low;
                                    dHVal > result.nMaxPrice && (result.nMaxPrice = dHVal, result.nMaxIndex = dataIndex), 
                                    dLVal < result.nMinPrice && (result.nMinPrice = dLVal, result.nMinIndex = dataIndex);
                                }
                            }
                            return result;
                        }
                    }
                }, this.didSetInvalidData = function(argIndex) {
                    return _self.didSetData(argIndex, !1, void 0);
                }, this.didSetSize = function(argSize, bFlag) {
                    var nDataCount = _self.m_arrDatas.length, nDiff = argSize - nDataCount;
                    if (nDiff > 0) for (var ii = 0; ii < nDiff; ii++) {
                        var bValid = !1 !== bFlag, xDatas = {
                            open: 0,
                            high: 0,
                            low: 0,
                            close: 0
                        };
                        _self.didAddData(bValid, xDatas);
                    }
                }, this.didSetData = function(argIndex, isValid, stPrice) {
                    var nDataCount = _self.m_arrDatas.length;
                    if (!(nDataCount < 1 && argIndex < 0 || argIndex >= nDataCount) && stPrice) return _self.m_arrValid[argIndex] = isValid, 
                    _self.m_arrDatas[argIndex] = xUtils.didClone(stPrice), argIndex;
                }, this.didDrawObj = function(isHitTest) {
                    var drawWrapper = _self.m_xDoParent.m_drawWrapper, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), context = _self.didGetContext(), bHitTest = (drawWrapper.m_xScrollInfo.pos, 
                    drawWrapper.m_xScrollInfo.screenSize, _self.m_arrDatas.length, !1), lineWeight = _self.m_xPlotInfo.lineWeight, lineColorVal = _self.m_xPlotInfo.color, fillColorVal = _self.m_xPlotInfo.color;
                    if (!0 === isHitTest) bHitTest = !0, lineColorVal = xUtils.hitTest.config.color, 
                    fillColorVal = xUtils.hitTest.config.color, context = _self.didGetContext(!0); else {
                        var xEnv = _self.didGetEnvInfo();
                        void 0 === xEnv || null == xEnv || !0 !== _self.m_xDoParent.m_bSelect && !0 !== _self.m_bSelect || (lineColorVal = xEnv.System.SelectedFill.lineColor, 
                        fillColorVal = xEnv.System.SelectedFill.lineColor);
                    }
                    for (var drawLineParam = {
                        context: context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: lineWeight,
                        lineColor: lineColorVal
                    }, drawRectParam = {
                        context: context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: lineWeight,
                        lineColor: lineColorVal,
                        fillColor: fillColorVal
                    }, nDataCount = _self.didGetDataSize(), nDataIdx = 0; nDataIdx < nDataCount; nDataIdx++) {
                        var dataIndex = xAxisX.didConvertLocalIndexToDataIndex(nDataIdx), shiftedIndex = _self.didGetShiftedDataIndex(dataIndex), __stCandle = _self.m_arrDatas[shiftedIndex];
                        if (!0 === xUtils.validator.isValidPrice(__stCandle)) {
                            var xBarInfos = {}, nLocalXPos = xAxisX.GetIndex2Pixel(dataIndex, xBarInfos), iYPosOpen = xAxisY.GetYPos(__stCandle.open), iYPosHigh = xAxisY.GetYPos(__stCandle.high), iYPosLow = xAxisY.GetYPos(__stCandle.low), iYPosClose = xAxisY.GetYPos(__stCandle.close);
                            !0 !== bHitTest && (!0 === _self.m_bSelect ? (lineColorVal = xEnv.System.SelectedFill.lineColor, 
                            fillColorVal = xEnv.System.SelectedFill.fillColor) : (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeDnColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillDnColor, !0 !== xUtils.dataConverter.isMinusCandleForPriceData(__stCandle) && (lineColorVal = xEnv.PriceStyleConfig.Candle.strokeUpColor, 
                            fillColorVal = xEnv.PriceStyleConfig.Candle.fillUpColor))), drawLineParam.pt1.x = nLocalXPos, 
                            drawLineParam.pt1.y = iYPosHigh, drawLineParam.pt2.x = nLocalXPos, drawLineParam.pt2.y = iYPosLow, 
                            drawLineParam.lineColor = lineColorVal, gxDc.Line(drawLineParam);
                            var rcX, rcY, rcW, rcH;
                            rcX = xBarInfos.pos, rcW = xBarInfos.width, rcY = iYPosOpen, rcH = iYPosClose - rcY, 
                            parseInt(__stCandle.open) == parseInt(__stCandle.close) ? (drawLineParam.pt1.x = rcX, 
                            drawLineParam.pt1.y = rcY, drawLineParam.pt2.x = rcX + rcW, drawLineParam.pt2.y = rcY, 
                            drawLineParam.lineColor = lineColorVal, gxDc.Line(drawLineParam)) : (drawRectParam.rect.x = rcX, 
                            drawRectParam.rect.y = rcY, drawRectParam.rect.width = rcW, drawRectParam.rect.height = rcH, 
                            drawRectParam.lineColor = lineColorVal, drawRectParam.fillColor = fillColorVal, 
                            gxDc.Rectangle(drawRectParam));
                        }
                    }
                }, this.didGetDebugPointedDataAt = function(argIndex, pointValue) {
                    var plotData = _self.didGetDataAt(argIndex);
                    return "(o:" + xUtils.number.didGetPointedValue(Math.round(plotData.open), pointValue) + "), (h:" + xUtils.number.didGetPointedValue(Math.round(plotData.high), pointValue) + "), (l:" + xUtils.number.didGetPointedValue(Math.round(plotData.low), pointValue) + "), (c:" + xUtils.number.didGetPointedValue(Math.round(plotData.close), pointValue) + ")";
                };
            }, _DOSIndicator = function() {
                var _self = this;
                this.prototype = new doBaseClass(), doBaseClass.apply(this, arguments);
                var _self = this;
                this.m_strChartName = "", this.m_bMainChart = !1, this.m_bPriceType = !1, this.m_point = 2, 
                this.m_strIndicator = "", this.m_xSeriesInfo = null, this.m_arrPlots = [], this.m_nRefSkip = 0, 
                this.m_nLastIdx = -1, this.m_nPlotLimit = 1, this.m_nPrice = xUtils.constants.keywords.price.close, 
                this.m_nPeriod = 5, this.m_arrCount = [], this.m_arrSum = [], this.m_arrColor = [], 
                this.m_arrPeriod = [], this.m_bNewData = !0, this.m_arrData = [], this.m_arrIndicatorData = [], 
                this.m_bYAxisTypeAdd = !0, this.m_arrPlotName = [], this.didCreatePlotByType = function(argType) {
                    var xPlot;
                    return xUtils.indicator.plotType.ESDG_SIDEBAR === argType ? xPlot = new _DOPlotSidebar() : xUtils.indicator.plotType.ESDG_CANDLEBAR === argType && (xPlot = new _DOPlotCandlebar()), 
                    xPlot;
                }, this.didCreatePlot = function(parent, plotInfo) {
                    if (void 0 !== plotInfo && null != plotInfo) {
                        var xPlot = _self.didCreatePlotByType(plotInfo.type);
                        return void 0 !== xPlot && null != xPlot || (xPlot = new _DOPlot()), xPlot.m_xDoParent = parent, 
                        xPlot.didSetPlotInfo(plotInfo), xPlot;
                    }
                };
                var _didFindParamInfoByName = function(argName) {
                    if (void 0 !== argName && null != argName && void 0 !== _self.m_xSeriesInfo && null != _self.m_xSeriesInfo && void 0 !== _self.m_xSeriesInfo.params && null != _self.m_xSeriesInfo.params) for (var nCount = _self.m_xSeriesInfo.params.length, ii = 0; ii < nCount; ii++) {
                        var xParam = _self.m_xSeriesInfo.params[ii];
                        if (xParam && argName === xParam.name) return xParam;
                    }
                }, _didSetParamInfos = function(argParamInfos) {
                    if (void 0 !== argParamInfos && null != argParamInfos) {
                        for (var bCalc = !1, nCount = argParamInfos.length, ii = 0; ii < nCount; ii++) {
                            var xParam = argParamInfos[ii];
                            if (xParam) {
                                var xParamFind = _didFindParamInfoByName(xParam.name);
                                xParamFind && (xParamFind.value = xParam.value, bCalc = !0);
                            }
                        }
                        return bCalc;
                    }
                }, _didFindPlotByName = function(argName) {
                    if (void 0 !== argName && null != argName) for (var nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                        var xPlot = _self.m_arrPlots[ii];
                        if (xPlot && argName === xPlot.m_strName) return xPlot;
                    }
                }, _didFindLineInfoByName = function(argName) {
                    if (void 0 !== argName && null != argName && void 0 !== _self.m_xSeriesInfo.lines && null != _self.m_xSeriesInfo.lines) for (var xObject = _self.m_xSeriesInfo.lines, nCount = xObject.length, ii = 0; ii < nCount; ii++) {
                        var xLineInfo = xObject[ii];
                        if (xLineInfo && argName === xLineInfo.name) return xLineInfo;
                    }
                }, _didSetPlotInfos = function(argPlotInfos) {
                    if (void 0 !== argPlotInfos && null != argPlotInfos) {
                        for (var nCount = argPlotInfos.length, ii = 0; ii < nCount; ii++) {
                            var xPlotInfo = argPlotInfos[ii];
                            if (xPlotInfo) {
                                var xPlotFind = _didFindPlotByName(xPlotInfo.name);
                                xPlotFind && xPlotFind.didSetPlotInfo && xPlotFind.didSetPlotInfo(xPlotInfo, !0);
                            }
                        }
                        return !0;
                    }
                }, _didSetShiftInfo = function(argExtraDiff) {
                    if (void 0 === argExtraDiff || null == argExtraDiff) return !1;
                    var bChanged = !1, nMoveShift = xUtils.didCalculateShiftValueWithExtraDiff(argExtraDiff, xUtils.constants.default.SHIFT_IS_ST);
                    return void 0 !== nMoveShift && null != nMoveShift || (nMoveShift = 0), nMoveShift !== _self.m_nMoveShift && (_self.m_nMoveShift = nMoveShift, 
                    bChanged = !0), bChanged;
                }, _didSetLineInfos = function(argLineInfos) {
                    if (void 0 !== argLineInfos && null != argLineInfos) {
                        for (var nCount = argLineInfos.length, ii = 0; ii < nCount; ii++) {
                            var xLineInfo = argLineInfos[ii];
                            if (xLineInfo) {
                                var xLineFind = _didFindLineInfoByName(xLineInfo.name);
                                xLineFind && void 0 !== xLineInfo.value && null != xLineInfo.value && (xLineFind.value = xLineInfo.value);
                            }
                        }
                        return !0;
                    }
                };
                this.didApplySetting = function(argSettings, outputChanged) {
                    if (void 0 !== argSettings && null != argSettings) {
                        var xObjectInfo;
                        xObjectInfo = "string" == typeof argSettings ? JSON.parse(argSettings) : argSettings;
                        var hasOutput = !1, isMulti = !1;
                        void 0 !== outputChanged && null != outputChanged && "object" == typeof outputChanged && (isMulti = outputChanged.isMulti, 
                        !0 === isMulti ? (outputChanged.param ? outputChanged.param |= !1 : outputChanged.param = !1, 
                        outputChanged.plot ? outputChanged.plot |= !1 : outputChanged.plot = !1, outputChanged.shift ? outputChanged.shift |= !1 : outputChanged.shift = !1, 
                        outputChanged.line ? outputChanged.line |= !1 : outputChanged.line = !1) : (outputChanged.param = !1, 
                        outputChanged.plot = !1, outputChanged.shift = !1, outputChanged.line = !1), hasOutput = !0);
                        var bParam = _didSetParamInfos(xObjectInfo.params), bPlot = _didSetPlotInfos(xObjectInfo.plots), bShift = _didSetShiftInfo(xObjectInfo.extraDiff), bLine = _didSetLineInfos(xObjectInfo.lines);
                        return bParam && _self.didCalculateData(), !0 === hasOutput && (!0 === isMulti ? (outputChanged.param |= bParam, 
                        outputChanged.plot |= bPlot, outputChanged.shift |= bShift, outputChanged.line |= bLine) : (outputChanged.param = bParam, 
                        outputChanged.plot = bPlot, outputChanged.shift = bShift, outputChanged.line = bLine)), 
                        !0;
                    }
                }, this.didPreparePlots = function(argPlotInfo) {
                    _self.didClearPlots();
                    for (var ii in argPlotInfo) {
                        var plotInfo = argPlotInfo[ii], xPlot = _self.didCreatePlot(_self, plotInfo);
                        _self.m_arrPlots.push(xPlot);
                    }
                }, this.didSetShiftInfo = function(argSeriesInfo) {
                    _self.m_nMoveShift = xUtils.didCalculateShiftInfo(argSeriesInfo, xUtils.constants.default.SHIFT_IS_ST);
                }, this.didPrepareObject = function(argCode, argObjectInfo) {
                    var xInfo;
                    return void 0 !== (xInfo = void 0 === argObjectInfo || null == argObjectInfo ? xUtils.indicator.didGetDefaultInfo(argCode) : xUtils.didClone(argObjectInfo)) && null != xInfo && (_self.m_xSeriesInfo = xInfo, 
                    _self.m_strChartName = _self.m_xSeriesInfo.display, _self.m_strIndicator = _self.m_xSeriesInfo.code, 
                    _self.m_bPriceType = !0 === _self.m_xSeriesInfo.priceType, _self.m_point = void 0 !== _self.m_xSeriesInfo.pointValue ? _self.m_xSeriesInfo.pointValue : _self.m_point, 
                    _self.didSetShiftInfo(xInfo), _self.didPreparePlots(_self.m_xSeriesInfo.plots), 
                    !0);
                }, this.didInitVariables = function(strChartName) {
                    _self.didInitCommonVariables(), _self.didInitSelfVariables();
                }, this.didInitCommonVariables = function() {}, this.didInitSelfVariables = function() {}, 
                this.didDestroyRest = function() {}, this.didDestroy = function() {
                    _self.didClearPlots(), _self.didClearLineStudyObject(), _self.didDestroyRest();
                }, this.didClearPlots = function() {
                    for (var ii = 0; ii < _self.m_arrPlots.length; ii++) delete _self.m_arrPlots[ii];
                    _self.m_arrPlots = [];
                }, this.didGetParamValue = function(argNo) {
                    var nParamCount = _self.m_xSeriesInfo.params.length;
                    if (!(nParamCount < 1 || 0 > argNo || argNo >= nParamCount)) return _self.m_xSeriesInfo.params[argNo].value;
                }, this.didGetParamValueByKey = function(argKey) {
                    if (void 0 === argKey || null == argKey) return "";
                    for (var ii in _self.m_xSeriesInfo.params) {
                        var param = _self.m_xSeriesInfo.params[ii];
                        if (param.name === argKey) return param.value;
                    }
                    return "";
                }, this.didGetPeriod = function(argTarget) {
                    var param;
                    if (void 0 !== (param = "string" == typeof argTarget ? _self.didGetParamValueByKey(argTarget) : _self.didGetParamValue(argTarget)) && null != param) return parseInt(param);
                    var nCount = _self.m_arrPeriod.length;
                    return nCount < 1 || 0 > argTarget || argTarget >= nCount ? 0 : parseInt(_self.m_arrPeriod[argTarget]);
                }, this.didGetShifRightCount = function() {
                    var nShiftCount = 0;
                    _self.m_nMoveShift > 0 && (nShiftCount = Math.abs(_self.m_nMoveShift));
                    for (var nPlotShiftCount = 0, nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                        var xPlot = _self.m_arrPlots[ii], nShiftRightCount = xPlot.didGetShifRightCount();
                        nPlotShiftCount = Math.max(nPlotShiftCount, nShiftRightCount);
                    }
                    return nShiftCount += nPlotShiftCount;
                }, this.didGetShifLeftCount = function() {
                    var nShiftCount = 0;
                    _self.m_nMoveShift < 0 && (nShiftCount = Math.abs(_self.m_nMoveShift));
                    for (var nPlotShiftCount = 0, nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                        var xPlot = _self.m_arrPlots[ii], nShiftRightCount = xPlot.didGetShifLeftCount();
                        nPlotShiftCount = Math.max(nPlotShiftCount, nShiftRightCount);
                    }
                    return nShiftCount += nPlotShiftCount;
                }, this.didGetShiftValue = function(argNo) {
                    return _self.m_nMoveShift;
                }, this.didGetPlotShiftValueAt = function(argNo) {
                    return 3 === argNo ? -1 * _self.didGetPeriod(argNo) : 0;
                }, this.didGetPointValue = function() {
                    if (!0 === _self.m_bPriceType) {
                        return _self.m_drawWrapper.didGetReferencedPriceObject().didGetPointValue();
                    }
                    return _self.m_point;
                }, this.ChartIndicatorType = function(argCode) {}, this.ReSetFrame = function(chartFrame) {
                    _self.m_chartFrame = chartFrame, _self.m_bNewData = !0, _self.m_canvas = chartFrame.m_canvas, 
                    _self.m_canvasLY = chartFrame.m_canvasLY, _self.m_canvasRY = chartFrame.m_canvasRY, 
                    _self.HEIGHT = chartFrame.m_canvas.height, _self.WIDTH = chartFrame.m_canvas.width, 
                    _self.m_context = chartFrame.m_context, _self.m_contextLY = chartFrame.m_contextLY, 
                    _self.m_contextRY = chartFrame.m_contextRY, _self.m_memcanvas = chartFrame.m_memcanvas, 
                    _self.m_memcontext = chartFrame.m_memcontext, _self.didResetMinMax();
                    for (var ii = 0; ii < _self.m_arrTrendlineObjlist.length; ii++) _self.m_arrTrendlineObjlist[ii].ReSetFrame(chartFrame);
                }, this.didClearPlots = function() {
                    for (var ii = 0; ii < _self.m_arrPlots.length; ii++) _self.m_arrPlots[ii].didClearDatas();
                }, this.didClearExtraData = function() {}, this.didClearDatas = function(argType, argName) {
                    _self.m_nRefSkip = 0, _self.m_nLastIdx = -1, _self.ClearIndicatorType(argType, argName), 
                    _self.didResetParam(argType), _self.didResetMinMax(), _self.didClearPlots(), _self.didClearExtraData();
                }, this.didResetParam = function(argType) {
                    0 === argType && (_self.m_arrColor = [], _self.m_arrPeriod = []);
                }, this.ClearIndicatorType = function(argType, strIndicator) {
                    _self.m_arrCount = [ 0 ], _self.m_arrSum = [ [] ], _self.m_arrData = [ [] ], _self.m_arrIndicatorData = [ [] ];
                }, this.didGetAxisX = function() {
                    return _self.m_drawWrapper;
                }, this.didGetAxisY = function() {
                    return _self;
                }, this.didGetContext = function(bHitTest) {
                    return !0 === bHitTest ? _self.m_memcontext : _self.m_context;
                }, this.didDrawSelf = function(posval) {
                    _self.DrawIndicatorChart(posval);
                }, this.didDrawTrendLines = function() {
                    for (var xScaleUnit = _self.m_xScaleInfo.current, nLSCount = _self.m_arrTrendlineObjlist.length, ii = 0; ii < nLSCount; ii++) {
                        _self.m_arrTrendlineObjlist[ii].DrawObj(xScaleUnit.minMaxScreen.maxValue, xScaleUnit.minMaxScreen.minValue);
                    }
                }, this.didReceiveData = function(symbolInfo, receivedDatas) {
                    _self.ReceiveData();
                }, this.didCalculateRealData = function(nStart, nDSize, nSSize) {
                    return _self.runProcRTEx(nStart, nDSize, nSSize);
                }, this.didCalculateData = function() {
                    _self.runProcHD();
                }, this.didCalculateDataEx = function(nStart, nDSize, nSSize) {
                    _self.runProcHDEx(nStart, nDSize, nSSize);
                }, this.ReceiveBlankData = function(iMarginGap) {
                    if (iMarginGap > 0) for (var ii = 0; ii < iMarginGap; ii++) for (idxData = 0; idxData < _self.m_arrIndicatorData.length; idxData++) _self.m_arrIndicatorData[idxData].push(xUtils.constants.default.DEFAULT_WRONG_VALUE); else if (iMarginGap < 0) for (var ii = 0; ii < Math.abs(iMarginGap); ii++) for (var idxData = 0; idxData < _self.m_arrIndicatorData.length; idxData++) _self.m_arrIndicatorData[idxData].splice(_self.m_arrIndicatorData[idxData].length - 1, 1);
                }, this.CreateTrendlineObj = function(lsName, posval) {}, this.didGetShiftedDataIndexOfPlotAt = function(argDataIndex, argPlotNo) {
                    var nShiftValue = _self.didGetShiftValue(), xPlot = _self.didGetPlotAt(argPlotNo);
                    return void 0 !== xPlot && null != xPlot && !0 !== xPlot.hasIgnore() && !0 !== xPlot.hasHide() && (nShiftValue += xPlot.didGetShiftValue(!0)), 
                    xUtils.didConvertShiftedIndex(argDataIndex, nShiftValue);
                }, this.didCalcMinMax = function(argScrSIdx, argScrSize, argFlag) {
                    var xScaleUnit = _self.m_xScaleInfo.current;
                    xUtils.scale.didResetScaleUnit(xScaleUnit);
                    for (var xMMScreen = xScaleUnit.minMaxScreen, nPlotCount = _self.m_arrPlots.length, nDataStartIndex = _self.m_drawWrapper.didConvertLocalIndexToDataIndex(0), nPlotNo = 0; nPlotNo < nPlotCount; nPlotNo++) {
                        var xPlot = _self.didGetPlotAt(nPlotNo), xMinMax = xPlot.didCalcMinMax(nDataStartIndex, argScrSize, argFlag);
                        void 0 !== xMinMax && null != xMinMax && (xMinMax.nMaxPrice > xMMScreen.maxValue && (xMMScreen.maxValue = xMinMax.nMaxPrice, 
                        xMMScreen.maxIndex = xMinMax.nMaxIndex), xMinMax.nMinPrice < xMMScreen.minValue && (xMMScreen.minValue = xMinMax.nMinPrice, 
                        xMMScreen.minIndex = xMinMax.nMinIndex));
                    }
                    _self.didCalcMinMaxForBaselines(xMMScreen), xUtils.scale.didCalcScaleUnit(xScaleUnit);
                }, this.didCalcMinMaxForBaselines = function(argMMScreen) {
                    var xEnv = _self.didGetEnvInfo();
                    try {
                        if (!argMMScreen) return;
                        if (!0 !== xEnv.System.UseBaselineToScale) return;
                        if (void 0 === _self.m_xSeriesInfo.lines || null == _self.m_xSeriesInfo.lines) return;
                        var nCount = _self.m_xSeriesInfo.lines.length;
                        if (nCount < 1) return;
                        for (var xObject = _self.m_xSeriesInfo.lines, ii = 0; ii < nCount; ii++) {
                            var xBi = xObject[ii];
                            if (xBi && !0 !== xBi.hide) {
                                var dLineValue = _self.didCalcBaselineValue(xBi);
                                void 0 !== dLineValue && null != dLineValue && (dLineValue > argMMScreen.maxValue && (argMMScreen.maxValue = dLineValue), 
                                dLineValue < argMMScreen.minValue && (argMMScreen.minValue = dLineValue));
                            }
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didDrawFillPlots = function(isHitTest) {}, this.didDrawFillPlotItem = function(argFillItem, isHitTest) {
                    if (void 0 !== argFillItem && null != argFillItem) {
                        var xPlot1 = _self.didGetPlotAt(argFillItem.plot1), xPlot2 = _self.didGetPlotAt(argFillItem.plot2);
                        if (void 0 !== xPlot1 && null != xPlot1 && void 0 !== xPlot2 && null != xPlot2 && !0 !== xPlot1.hasIgnore() && !0 !== xPlot1.hasHide() && !0 !== xPlot2.hasIgnore() && !0 !== xPlot2.hasHide()) {
                            var drawWrapper = _self.m_drawWrapper, xAxisX = _self.didGetAxisX(), xAxisY = _self.didGetAxisY(), context = _self.didGetContext(), nScrSize = (drawWrapper.m_xScrollInfo.pos, 
                            drawWrapper.m_xScrollInfo.screenSize), fillColorUp = argFillItem.colorUp, fillColorDn = argFillItem.colorDn, fillColorVal = fillColorUp;
                            if (!0 === isHitTest) !0, fillColorUp = xUtils.hitTest.config.color, fillColorDn = xUtils.hitTest.config.color, 
                            context = _self.didGetContext(!0); else {
                                var xEnv = _self.didGetEnvInfo();
                                void 0 === xEnv || null == xEnv || !0 !== _self.m_bSelect && !0 !== xPlot1.m_bSelect && !0 !== xPlot2.m_bSelect || (fillColorUp = xEnv.System.SelectedFill.lineColor, 
                                fillColorDn = xEnv.System.SelectedFill.lineColor);
                            }
                            fillColorVal = fillColorUp;
                            var drawPolygonParam = {
                                context: context,
                                pt1s: [],
                                pt2s: [],
                                fillColor: fillColorUp,
                                fillAlpha: argFillItem.alpha
                            }, bFirst = !0, bUp = !0, pt = {
                                x: 0,
                                y: 0
                            }, pt1Pre = {
                                x: 0,
                                y: 0
                            }, pt2Pre = {
                                x: 0,
                                y: 0
                            }, pt1Cur = {
                                x: 0,
                                y: 0
                            }, pt2Cur = {
                                x: 0,
                                y: 0
                            }, arrPt1 = [], arrPt2 = [], nDataIdx = -1, dataIndex = xAxisX.didConvertLocalIndexToDataIndex(nDataIdx), shiftedIndex1 = xPlot1.didGetShiftedDataIndex(dataIndex), shiftedIndex2 = xPlot2.didGetShiftedDataIndex(dataIndex), dataValue1 = xPlot1.didGetDataAt(shiftedIndex1), dataValue2 = xPlot2.didGetDataAt(shiftedIndex2);
                            if (!0 === xUtils.dataValidator.isValidData(dataValue1) && !0 === xUtils.dataValidator.isValidData(dataValue2)) {
                                var nLocalXPos = xAxisX.GetXPosAtDataIndex(dataIndex), nLocalYPos1 = xAxisY.GetYPos(dataValue1), nLocalYPos2 = xAxisY.GetYPos(dataValue2);
                                pt1Cur = xUtils.didClone(pt), pt1Cur.x = nLocalXPos, pt1Cur.y = nLocalYPos1, pt2Cur = xUtils.didClone(pt), 
                                pt2Cur.x = nLocalXPos, pt2Cur.y = nLocalYPos2, bFirst = !1, dataValue1 > dataValue2 ? (fillColorVal = fillColorUp, 
                                bUp = !0) : (fillColorVal = fillColorDn, bUp = !1), arrPt1.push(pt1Cur), arrPt2.push(pt2Cur), 
                                pt1Pre = xUtils.didClone(pt1Cur), pt2Pre = xUtils.didClone(pt2Cur);
                            }
                            for (nDataIdx = 0; nDataIdx < nScrSize; nDataIdx++) if (dataIndex = xAxisX.didConvertLocalIndexToDataIndex(nDataIdx), 
                            shiftedIndex1 = xPlot1.didGetShiftedDataIndex(dataIndex), shiftedIndex2 = xPlot2.didGetShiftedDataIndex(dataIndex), 
                            dataValue1 = xPlot1.didGetDataAt(shiftedIndex1), dataValue2 = xPlot2.didGetDataAt(shiftedIndex2), 
                            !0 === xUtils.dataValidator.isValidData(dataValue1) && !0 === xUtils.dataValidator.isValidData(dataValue2)) {
                                var nLocalXPos = xAxisX.GetXPosAtDataIndex(dataIndex), nLocalYPos1 = xAxisY.GetYPos(dataValue1), nLocalYPos2 = xAxisY.GetYPos(dataValue2);
                                if (pt1Cur = xUtils.didClone(pt), pt1Cur.x = nLocalXPos, pt1Cur.y = nLocalYPos1, 
                                pt2Cur = xUtils.didClone(pt), pt2Cur.x = nLocalXPos, pt2Cur.y = nLocalYPos2, !0 !== bFirst) if (!0 === bUp && dataValue1 <= dataValue2) {
                                    var ptCross = xUtils.didGetCrossPoint(pt1Pre, pt1Cur, pt2Pre, pt2Cur);
                                    arrPt1.push(xUtils.didClone(ptCross)), arrPt2.push(xUtils.didClone(ptCross)), drawPolygonParam.pt1s = arrPt1, 
                                    drawPolygonParam.pt2s = arrPt2, drawPolygonParam.fillColor = fillColorVal, gxDc.Polygon(drawPolygonParam), 
                                    arrPt1 = [], arrPt2 = [], arrPt1.push(xUtils.didClone(ptCross)), arrPt1.push(pt1Cur), 
                                    arrPt2.push(xUtils.didClone(ptCross)), arrPt2.push(pt2Cur), bUp = !1, fillColorVal = fillColorDn, 
                                    pt1Pre = xUtils.didClone(pt1Cur), pt2Pre = xUtils.didClone(pt2Cur);
                                } else if (!0 !== bUp && dataValue1 > dataValue2) {
                                    var ptCross = xUtils.didGetCrossPoint(pt1Pre, pt1Cur, pt2Pre, pt2Cur);
                                    arrPt1.push(xUtils.didClone(ptCross)), arrPt2.push(xUtils.didClone(ptCross)), drawPolygonParam.pt1s = arrPt1, 
                                    drawPolygonParam.pt2s = arrPt2, drawPolygonParam.fillColor = fillColorVal, gxDc.Polygon(drawPolygonParam), 
                                    arrPt1 = [], arrPt2 = [], arrPt1.push(xUtils.didClone(ptCross)), arrPt1.push(pt1Cur), 
                                    arrPt2.push(xUtils.didClone(ptCross)), arrPt2.push(pt2Cur), bUp = !0, fillColorVal = fillColorUp, 
                                    pt1Pre = xUtils.didClone(pt1Cur), pt2Pre = xUtils.didClone(pt2Cur);
                                } else arrPt1.push(pt1Cur), arrPt2.push(pt2Cur), pt1Pre = xUtils.didClone(pt1Cur), 
                                pt2Pre = xUtils.didClone(pt2Cur); else bFirst = !1, dataValue1 > dataValue2 ? (fillColorVal = fillColorUp, 
                                bUp = !0) : (fillColorVal = fillColorDn, bUp = !1), arrPt1.push(pt1Cur), arrPt2.push(pt2Cur), 
                                pt1Pre = xUtils.didClone(pt1Cur), pt2Pre = xUtils.didClone(pt2Cur);
                            } else arrPt1.length > 0 && arrPt2.length > 0 && (drawPolygonParam.pt1s = arrPt1, 
                            drawPolygonParam.pt2s = arrPt2, drawPolygonParam.fillColor = fillColorVal, gxDc.Polygon(drawPolygonParam), 
                            arrPt1 = [], arrPt2 = []);
                            if (dataIndex = xAxisX.didConvertLocalIndexToDataIndex(nDataIdx), shiftedIndex1 = xPlot1.didGetShiftedDataIndex(dataIndex), 
                            shiftedIndex2 = xPlot2.didGetShiftedDataIndex(dataIndex), dataValue1 = xPlot1.didGetDataAt(shiftedIndex1), 
                            dataValue2 = xPlot2.didGetDataAt(shiftedIndex2), !0 === xUtils.dataValidator.isValidData(dataValue1) && !0 === xUtils.dataValidator.isValidData(dataValue2)) {
                                var nLocalXPos = xAxisX.GetXPosAtDataIndex(dataIndex), nLocalYPos1 = xAxisY.GetYPos(dataValue1), nLocalYPos2 = xAxisY.GetYPos(dataValue2);
                                if (pt1Cur = xUtils.didClone(pt), pt1Cur.x = nLocalXPos, pt1Cur.y = nLocalYPos1, 
                                pt2Cur = xUtils.didClone(pt), pt2Cur.x = nLocalXPos, pt2Cur.y = nLocalYPos2, !0 !== bFirst) if (!0 === bUp && dataValue1 <= dataValue2) {
                                    var ptCross = xUtils.didGetCrossPoint(pt1Pre, pt1Cur, pt2Pre, pt2Cur);
                                    arrPt1.push(xUtils.didClone(ptCross)), arrPt2.push(xUtils.didClone(ptCross)), drawPolygonParam.pt1s = arrPt1, 
                                    drawPolygonParam.pt2s = arrPt2, drawPolygonParam.fillColor = fillColorVal, gxDc.Polygon(drawPolygonParam), 
                                    arrPt1 = [], arrPt2 = [], arrPt1.push(xUtils.didClone(ptCross)), arrPt1.push(pt1Cur), 
                                    arrPt2.push(xUtils.didClone(ptCross)), arrPt2.push(pt2Cur), bUp = !1, fillColorVal = fillColorDn, 
                                    pt1Pre = xUtils.didClone(pt1Cur), pt2Pre = xUtils.didClone(pt2Cur);
                                } else if (!0 !== bUp && dataValue1 > dataValue2) {
                                    var ptCross = xUtils.didGetCrossPoint(pt1Pre, pt1Cur, pt2Pre, pt2Cur);
                                    arrPt1.push(xUtils.didClone(ptCross)), arrPt2.push(xUtils.didClone(ptCross)), drawPolygonParam.pt1s = arrPt1, 
                                    drawPolygonParam.pt2s = arrPt2, drawPolygonParam.fillColor = fillColorVal, gxDc.Polygon(drawPolygonParam), 
                                    arrPt1 = [], arrPt2 = [], arrPt1.push(xUtils.didClone(ptCross)), arrPt1.push(pt1Cur), 
                                    arrPt2.push(xUtils.didClone(ptCross)), arrPt2.push(pt2Cur), bUp = !0, fillColorVal = fillColorUp, 
                                    pt1Pre = xUtils.didClone(pt1Cur), pt2Pre = xUtils.didClone(pt2Cur);
                                } else arrPt1.push(pt1Cur), arrPt2.push(pt2Cur), pt1Pre = xUtils.didClone(pt1Cur), 
                                pt2Pre = xUtils.didClone(pt2Cur); else bFirst = !1, fillColorVal = dataValue1 > dataValue2 ? fillColorUp : fillColorDn, 
                                arrPt1.push(pt1Cur), arrPt2.push(pt2Cur), pt1Pre = xUtils.didClone(pt1Cur), pt2Pre = xUtils.didClone(pt2Cur);
                            }
                            drawPolygonParam.pt1s = arrPt1, drawPolygonParam.pt2s = arrPt2, drawPolygonParam.fillColor = fillColorVal, 
                            gxDc.Polygon(drawPolygonParam);
                        }
                    }
                }, this.didDrawBaselines = function(isHitTest) {
                    if (void 0 !== _self.m_xSeriesInfo.lines && null != _self.m_xSeriesInfo.lines) {
                        var nCount = _self.m_xSeriesInfo.lines.length;
                        if (!(nCount < 1)) for (var xObject = _self.m_xSeriesInfo.lines, ii = 0; ii < nCount; ii++) {
                            var xBi = xObject[ii];
                            _self.didDrawBaselineItem(xBi, isHitTest);
                        }
                    }
                }, this.didDrawBaselineItem = function(argBaselineItem, isHitTest) {
                    if (void 0 !== argBaselineItem && null != argBaselineItem && !0 !== argBaselineItem.hide) {
                        var dLineValue = _self.didCalcBaselineValue(argBaselineItem);
                        if (void 0 !== dLineValue && null != dLineValue) {
                            var showLabel = (_self.didGetPointValue(), argBaselineItem.value, argBaselineItem.showLabel), xAxisY = (_self.m_drawWrapper, 
                            _self.didGetAxisX(), _self.didGetAxisY()), context = _self.didGetContext(), __xPanelRect = _self.didGetPanelRect(), nYPos = xAxisY.GetYValToPos(dLineValue), lineColor = xUtils.constants.indicatorColors.baseline, context = _self.m_context, xEnv = _self.didGetEnvInfo(), font = xEnv.Font;
                            if (!0 === isHitTest) context = _self.didGetContext(!0), lineColor = _self.m_clrHitTestColor; else {
                                var xEnv = _self.didGetEnvInfo();
                                void 0 !== xEnv && null != xEnv && !0 === _self.m_bSelect && (lineColor = xEnv.System.SelectedFill.lineColor);
                            }
                            var fontColor = lineColor, drawLineParam = {
                                context: context,
                                pt1: {
                                    x: 0,
                                    y: nYPos
                                },
                                pt2: {
                                    x: __xPanelRect.width,
                                    y: nYPos
                                },
                                lineWidth: 1,
                                lineColor: lineColor,
                                lineStyle: 1
                            };
                            if (gxDc.Line(drawLineParam), !0 === showLabel) {
                                var strAlias = argBaselineItem.alias;
                                if (void 0 !== strAlias && null != strAlias) {
                                    var strDisp = strAlias.trim();
                                    if ("" !== strDisp) {
                                        var drawTextParam = {
                                            context: context,
                                            pt: {
                                                x: 0,
                                                y: 0
                                            },
                                            text: "",
                                            font: font,
                                            fillStyle: fontColor
                                        }, drawRectParam = {
                                            context: context,
                                            rect: {
                                                x: 0,
                                                y: 0,
                                                width: 0,
                                                height: 0
                                            },
                                            lineWidth: 1,
                                            lineColor: lineColor,
                                            fillColor: "#ffffff"
                                        }, textRect = gxDc.CalcRect2(strDisp, font);
                                        drawRectParam.rect.width = textRect.width + 5, drawRectParam.rect.height = textRect.height, 
                                        drawRectParam.rect.x = 5, drawRectParam.rect.y = nYPos - parseInt(textRect.height / 2), 
                                        gxDc.Rectangle(drawRectParam), drawTextParam.text = strDisp, drawTextParam.pt.x = 7, 
                                        drawTextParam.pt.y = nYPos, gxDc.TextOut(drawTextParam);
                                    }
                                }
                            }
                        }
                    }
                }, this.DrawIndicatorChart = function(posval) {
                    _self.didDrawBaselines(), _self.didDrawFillPlots();
                    for (var nPlotCount = (_self.m_drawWrapper.m_xScrollInfo.pos, _self.m_drawWrapper.m_xScrollInfo.screenSize, 
                    _self.m_arrPlots.length), nPlotNo = 0; nPlotNo < nPlotCount; nPlotNo++) {
                        var xPlot = _self.m_arrPlots[nPlotNo];
                        void 0 !== xPlot && null != xPlot && !0 !== xPlot.hasIgnore() && !0 !== xPlot.hasHide() && xPlot.didDrawObj();
                    }
                }, this.DrawSelectChart = function(posval) {
                    for (var dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1), nPlotCount = _self.m_arrPlots.length, nPlotNo = 0; nPlotNo < nPlotCount; nPlotNo++) {
                        var xPlot = _self.m_arrPlots[nPlotNo];
                        if (!(xPlot.m_arrDatas.length < 1)) for (var ii = dataIndexAtPos - 3; ii <= dataIndexAtPos + 3; ii++) {
                            var dataIndex1 = ii, dataIndex2 = ii + 1, shiftedIndex1 = _self.didGetShiftedDataIndexOfPlotAt(dataIndex1, nPlotNo), shiftedIndex2 = shiftedIndex1 + 1, dataValue1 = xPlot.m_arrDatas[shiftedIndex1], dataValue2 = xPlot.m_arrDatas[shiftedIndex2];
                            if (!0 === xUtils.dataValidator.isValidData(dataValue1) && !0 === xUtils.dataValidator.isValidData(dataValue2)) {
                                var nLocalXPos1 = _self.m_drawWrapper.GetXPosAtDataIndex(dataIndex1), nLocalXPos2 = _self.m_drawWrapper.GetXPosAtDataIndex(dataIndex2), nLocalYPos1 = _self.GetYPos(dataValue1), nLocalYPos2 = _self.GetYPos(dataValue2);
                                _self.DrawLine({
                                    context: _self.m_memcontext,
                                    startX: nLocalXPos1,
                                    startY: nLocalYPos1,
                                    endX: nLocalXPos2,
                                    endY: nLocalYPos2,
                                    lineWidth: 1,
                                    lineColor: "#ff0000"
                                });
                            }
                        }
                    }
                }, this.DrawSelectObj = function(posval, hitTestTool) {
                    if (void 0 !== hitTestTool && null != hitTestTool) {
                        hitTestTool.willBeHitTest(), _self.DrawSelectChart(posval);
                        var result = hitTestTool.didHitTest();
                        if (hitTestTool.closeHitTest(), !0 === result) return _self.m_bSelect = !0, !0;
                    } else if (_self.DrawSelectChart(posval), !0 === _self.m_drawWrapper.didHitTest(_self.m_memcontext, posval)) return _self.m_bSelect = !0, 
                    !0;
                    return !1;
                };
                var _DeselectAllPlots = function() {
                    for (var nPlotCount = _self.m_arrPlots.length, nPlotNo = 0; nPlotNo < nPlotCount; nPlotNo++) {
                        var xPlot = _self.m_arrPlots[nPlotNo];
                        xPlot.DeselectAllObject && xPlot.DeselectAllObject();
                    }
                };
                this.DeslectAllRest = function() {
                    _DeselectAllPlots();
                }, this.didHitTest = function(posval, hitTestTool) {
                    for (var dataIndexAtPos = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(posval.XPos, !1), nPlotCount = _self.m_arrPlots.length, nPlotNo = 0; nPlotNo < nPlotCount; nPlotNo++) {
                        var xPlot = _self.m_arrPlots[nPlotNo];
                        if (void 0 !== xPlot && null != xPlot && void 0 !== xPlot.didHitTest && null != xPlot.didHitTest) {
                            if (!0 === xPlot.didHitTest(hitTestTool, dataIndexAtPos)) return !0 !== posval.__onmove__ && (xPlot.m_bSelect = !0, 
                            _self.m_bSelect = !0), !0;
                        }
                    }
                    return !0 === _self.didHitTestForFillPlots(posval, hitTestTool) ? (_self.m_bSelect = !0, 
                    !0) : !0 === _self.didHitTestForBaselines(posval, hitTestTool) && (_self.m_bSelect = !0, 
                    !0);
                }, this.didHitTestForFillPlots = function(posval, hitTestTool) {
                    if (void 0 === hitTestTool || null == hitTestTool) return !1;
                    hitTestTool.willBeHitTest(), _self.didDrawFillPlots(!0);
                    var result = hitTestTool.didHitTest();
                    return hitTestTool.closeHitTest(), result;
                }, this.didHitTestForBaselines = function(posval, hitTestTool) {
                    if (void 0 === hitTestTool || null == hitTestTool) return !1;
                    hitTestTool.willBeHitTest(), _self.didDrawBaselines(!0);
                    var result = hitTestTool.didHitTest();
                    return hitTestTool.closeHitTest(), result;
                }, this.didDrawDataView = function(argDtp, argDataIndex) {
                    var drawTextParam = argDtp, title = _self.didGetDisplayTitle(), textSpace = drawTextParam.textSpace;
                    drawTextParam.text = title;
                    var titleLen = gxDc.TextOut(drawTextParam, !0);
                    return drawTextParam.pt.x = drawTextParam.pt.x + 2 * textSpace + titleLen, drawTextParam;
                }, this.didDrawDataViewForSubItems = function(argDtp, argDataIndex) {
                    for (var nPlotCount = _self.m_arrPlots.length, ii = 0; ii < nPlotCount; ii++) {
                        var xPlot = _self.m_arrPlots[ii];
                        if (void 0 === xPlot || null == xPlot) break;
                        xPlot.didDrawDataView(argDtp, argDataIndex);
                    }
                    return argDtp;
                }, this.didGetDisplayTitle = function(isSimple) {
                    var strParamInfo = "";
                    if (!0 !== isSimple) {
                        var nParamCount = _self.m_xSeriesInfo.params.length;
                        if (nParamCount > 0) {
                            strParamInfo = "(";
                            for (var ii = 0; ii < nParamCount; ii++) {
                                var xParam = _self.m_xSeriesInfo.params[ii];
                                strParamInfo += xUtils.indicator.didGetParamValueForDisplay(xParam), ii < nParamCount - 1 && (strParamInfo += ",");
                            }
                            strParamInfo += ")";
                        }
                    }
                    return _self.m_strChartName + strParamInfo;
                }, this.didGetDataViewDataAtPos = function(argLocalXPos) {
                    for (var dataIndex = _self.GetXIndex(argLocalXPos), xViewData = {
                        isPrice: !1,
                        display: _self.didGetDisplayTitle(),
                        datas: []
                    }, nPlotCount = _self.m_arrPlots.length, ii = 0; ii < nPlotCount; ii++) {
                        var xPlot = _self.m_arrPlots[ii];
                        if (void 0 === xPlot || null == xPlot) break;
                        var xData = xPlot.didGetDataViewDataAt(dataIndex);
                        if (void 0 !== xData && null != xData) if (void 0 !== xData.length && null != xData.length) for (var ii = 0; ii < xData.length; ii++) xViewData.datas.push(xData[ii]); else xViewData.datas.push(xData);
                    }
                    return xViewData;
                }, this.didGetDataSize = function() {
                    return _self.m_arrPlots.length < 1 ? 0 : _self.m_arrPlots[0].didGetDataSize();
                }, this.ProcStart = function() {
                    var xDoBasePrice = _self.m_drawWrapper.didGetReferencedPriceObject(), nBaseDataCount = _self.m_drawWrapper.GetBaseDataCount();
                    _self.m_nLastIdx = nBaseDataCount - 1;
                    var result = xDoBasePrice.GetLastDataIndex(_self.m_nLastIdx);
                    void 0 !== result && null != result && (_self.m_nLastIdx = result, nBaseDataCount = _self.m_nLastIdx + 1), 
                    _self.InnerProc(-1, 0, nBaseDataCount, !0);
                }, this.InnerProc = function(nIdx, nStart, nDSize, bReset) {}, this.ParamSet = function() {}, 
                this.didDefaultParamSet = function() {
                    var strTemp = _self.didGetParamValueByKey(xUtils.constants.keywords.defaults.price);
                    if ("" !== strTemp) {
                        var strKey = strTemp.toLowerCase(), strCvtValue = xUtils.constants.keywords.price[strKey];
                        void 0 !== strCvtValue && (_self.m_nPrice = strCvtValue);
                    }
                    "" !== (strTemp = _self.didGetParamValueByKey(xUtils.constants.keywords.defaults.period)) && (_self.m_nPeriod = parseInt(strTemp));
                }, this.SetRefSkip = function(bReset) {}, this.GetPlotLimit = function() {
                    return _self.m_nPlotLimit;
                }, this.SetSize = function(argSize) {
                    for (var nPlotCount = _self.m_arrPlots.length, ii = 0; ii < nPlotCount; ii++) {
                        var xPlot = _self.m_arrPlots[ii];
                        void 0 !== xPlot && null != xPlot && xPlot.didSetSize(argSize);
                    }
                }, this.didClearIndicatorDatas = function() {
                    _self.Clean();
                }, this.didCleanRest = function() {}, this.Clean = function() {
                    _self.didClearDatas(), _self.didCleanRest();
                }, this.runProcRTEx = function(nStart, nDSize, nSSize) {
                    if (_self.m_arrPlots.length < _self.GetPlotLimit()) return !1;
                    var xDoBasePrice = (_self.m_arrPlots[0], _self.m_drawWrapper.didGetReferencedPriceObject()), nPLCnt = _self.didGetDataSize(), nDiff = nDSize - nPLCnt;
                    nDiff > 0 && _self.SetSize(nDSize);
                    var nNewLastIdx = nDSize - 1;
                    nNewLastIdx = xDoBasePrice.GetLastDataIndex(nNewLastIdx), nDiff = nNewLastIdx - _self.m_nLastIdx;
                    var nRTStart = 0;
                    if (0 == nDiff) _self.procRTSame(_self.m_nLastIdx + 1), nRTStart = _self.m_nLastIdx < 0 ? 0 : _self.m_nLastIdx; else {
                        if (!(nDiff > 0)) return !1;
                        nRTStart = _self.m_nLastIdx < 0 ? 1 : _self.m_nLastIdx + 1;
                    }
                    return _self.InnerProc(-1, nRTStart, nNewLastIdx + 1, !1), _self.m_nLastIdx = nNewLastIdx, 
                    !0;
                }, this.willBeRunProcHD = function(isNontime) {
                    if (_self.Clean(), _self.__GETPLOTSIZE() < _self.GetPlotLimit()) return !1;
                    if (!0 !== isNontime) {
                        var nBaseDataCount = _self.didGetReferencedBaseDataCount();
                        _self.SetSize(nBaseDataCount);
                    }
                    return !0;
                }, this.runProcHDEx = function(nStart, nDSize, nSSize) {
                    return _self.runProcHD();
                }, this.runProcHD = function() {
                    return !0 === _self.willBeRunProcHD() && (_self.didDefaultParamSet(), _self.ParamSet(), 
                    _self.ProcStart(), !0);
                }, this.procRTSame = function(nDSize) {}, this.didGetPlotAt = function(plotNo) {
                    var nPlotNo, nCount = _self.m_arrPlots.length;
                    if (nPlotNo = void 0 === plotNo || null == plotNo || "object" == typeof plotNo ? 0 : "string" == typeof plotNo ? parseInt(plotNo) : plotNo, 
                    !(nCount < 1 || nPlotNo < 0 || nPlotNo >= nCount)) return _self.m_arrPlots[plotNo];
                }, this.didPrintDebugData = function() {
                    var nPlotCount = _self.m_arrPlots.length;
                    if (nPlotCount < 1) return void xUtils.debug.log("Print debug data: there is no data.");
                    _self.didGetShifLeftCount(), _self.didGetShifRightCount();
                    var nLeftShift = _self.didGetShifLeftCount(), nRightShift = _self.didGetShifLeftCount(), nShiftAll = nLeftShift + nRightShift, pointValue = _self.didGetPointValue(), nPlotDataCount = (Math.pow(pointValue), 
                    _self.m_arrPlots[0].m_arrDatas.length + nShiftAll);
                    xUtils.debug.log("Print debug data: " + _self.m_strChartName);
                    for (var ii = 0; ii < nPlotDataCount; ii++) {
                        for (var localDataIndex = ii + -1 * nLeftShift, strPrint = xUtils.number.formatAsfillSize(localDataIndex, " ", 5) + ":\t", nPlotNo = 0; nPlotNo < nPlotCount; nPlotNo++) {
                            var xPlot = _self.didGetPlotAt(nPlotNo);
                            if (!0 !== xPlot.hasIgnore() && !0 !== xPlot.hasHide()) {
                                var shiftedIndex = xPlot.didGetShiftedDataIndex(localDataIndex);
                                if (!0 === xPlot.isValidAt(shiftedIndex)) {
                                    strPrint += xPlot.didGetDebugPointedDataAt(shiftedIndex, pointValue) + "\t";
                                } else strPrint += xUtils.constants.text.dataView.invalid + "\t";
                            }
                        }
                        xUtils.debug.log(strPrint);
                    }
                    xUtils.debug.log("Print debug data: LastIndex => " + _self.m_nLastIdx);
                }, this.didGetReferencedBaseDataCount = function() {
                    return _self.m_drawWrapper.GetBaseDataCount();
                }, this.didGetReferencedPriceObject = function() {
                    return _self.m_drawWrapper.didGetReferencedPriceObject();
                }, this.didGetReferencedBaseDataAt = function(dataIndex, bScreen) {
                    return _self.m_drawWrapper.GetBaseDataAt(dataIndex, bScreen);
                }, this.didGetReferencedBaseDatas = function(to, count) {
                    return _self.m_drawWrapper.GetBaseDatas(to, count);
                }, this.didGetPriceFactor = function() {
                    var xDoBasePrice = _self.m_drawWrapper.didGetReferencedPriceObject(), nBasePricePoint = xDoBasePrice.didGetPointValue(), nPointValue = _self.didGetPointValue();
                    return Math.pow(.1, nBasePricePoint - nPointValue);
                }, this.didGetPointFactor = function() {
                    var nPointValue = _self.didGetPointValue();
                    return Math.pow(10, nPointValue);
                }, this.didCalcBaselineValue = function(argLineInfo) {
                    if (void 0 !== argLineInfo && null != argLineInfo && void 0 !== argLineInfo.value && null != argLineInfo.value) {
                        var dPointFactor = 1;
                        !0 !== argLineInfo.raw && (dPointFactor = _self.didGetPointFactor());
                        return argLineInfo.value * dPointFactor;
                    }
                }, this.didGetPlotDatasAt = function(argPlotNo) {
                    (void 0 === argPlotNo || 0 == argPlotNo || argPlotNo < 0) && (argPlotNo = 0);
                    var xPlot = _self.didGetPlotAt(argPlotNo);
                    if (void 0 !== xPlot && null != xPlot) return xPlot.m_arrDatas;
                }, this.didDrawLastDataForBaselines = function(argDrawParam) {
                    if (void 0 !== _self.m_xSeriesInfo.lines && null != _self.m_xSeriesInfo.lines) {
                        var nCount = _self.m_xSeriesInfo.lines.length;
                        if (!(nCount < 1)) {
                            argDrawParam.price = {}, argDrawParam.price.verpos = _self.didGetPointValue(), argDrawParam.price.value = null, 
                            argDrawParam.price.color = null, argDrawParam.axis = _self.didGetAxisY();
                            for (var xObject = _self.m_xSeriesInfo.lines, ii = 0; ii < nCount; ii++) {
                                var xBi = xObject[ii];
                                _self.didDrawLastDataForBaselineItem(xBi, argDrawParam);
                            }
                        }
                    }
                }, this.didDrawLastDataForBaselineItem = function(argBaselineItem, argDrawParam) {
                    try {
                        if (void 0 === argBaselineItem || null == argBaselineItem) return;
                        if (void 0 === argDrawParam || null == argDrawParam) return;
                        if (!0 === argBaselineItem.hide) return;
                        var dLineValue = _self.didCalcBaselineValue(argBaselineItem);
                        if (void 0 === dLineValue || null == dLineValue) return;
                        argDrawParam.price.value = dLineValue, argDrawParam.price.color = xUtils.constants.indicatorColors.baseline, 
                        xUtils.axis.didDrawLastValueOnYAxis(argDrawParam);
                    } catch (e) {
                        console.error(e);
                    }
                }, this.DrawLastValue = function(argDrawParam, dataIndex) {
                    try {
                        if (void 0 === argDrawParam || null == argDrawParam) return;
                        _self.didDrawLastDataForBaselines(argDrawParam), argDrawParam.price = {}, argDrawParam.price.verpos = _self.didGetPointValue(), 
                        argDrawParam.price.value = null, argDrawParam.price.color = null, argDrawParam.axis = _self.didGetAxisY();
                        for (var nCount = _self.m_arrPlots.length, ii = 0; ii < nCount; ii++) {
                            var xPlot = _self.m_arrPlots[ii];
                            void 0 !== xPlot && null != xPlot && !0 !== xPlot.hasIgnore() && !0 !== xPlot.hasHide() && xPlot.DrawLastValue(argDrawParam, dataIndex);
                        }
                    } catch (e) {}
                }, this.NoDataScale = function(nSize, bFull) {
                    var bRet = !1;
                    return nSize < 1 && (bFull && xUtils.scale.didBackupScaleInfo(_self.m_xScaleInfo), 
                    bRet = !0), bRet;
                }, this.__GETPLOTSIZE = function() {
                    return _self.m_arrPlots.length;
                }, this.ProcPlotSimpleLine = function(argPlotNo, nStart, nDSize, nCheck) {
                    var dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(argPlotNo), nLimit = nCheck, nOffset = nStart;
                    if (void 0 === xPlot || null == xPlot) return nLimit;
                    for (;nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var reg_i = 0, dData = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPrice;
                        stPrice = _self.didGetReferencedBaseDataAt(reg_i, !1), dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), 
                        xPlot.didSetData(reg_i, !0, dData);
                    }
                    return nLimit;
                }, this.ProcPlotS = function(argPlotNo, nStart, nDSize, nPeriod) {
                    var dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(argPlotNo), nLimit = nPeriod - 1 + _self.m_nRefSkip, nOffset = nStart;
                    if (void 0 === xPlot || null == xPlot) return nLimit;
                    for (;nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var vInput, bFirst = !0, dSumL = 0, dPreL = 0, dData = 0, arrData = [], reg_j = 0, reg_i = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPrice;
                        if (bFirst) {
                            arrData = [];
                            var nGo = reg_i - (nPeriod - 1), nStop = nGo + nPeriod;
                            for (reg_j = nGo; reg_j < nStop; reg_j++) stPrice = _self.didGetReferencedBaseDataAt(reg_j, !1), 
                            dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), arrData.push(dData);
                            vInput = arrData;
                        } else stPrice = _self.didGetReferencedBaseDataAt(reg_i, !1), dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), 
                        dSumL += dData, stPrice = _self.didGetReferencedBaseDataAt(reg_i - (nPeriod - 1), !1), 
                        dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), dPreL = dData, 
                        vInput = dPreL;
                        var xMAEx = xUtils.math.CalcMAEx(vInput, dSumL, nPeriod, xUtils.math.constants.methods.simple, bFirst, !0);
                        dData = xMAEx.ma, dSumL = xMAEx.sum, xPlot.didSetData(reg_i, !0, dData), bFirst = !1;
                    }
                    return nLimit;
                }, this.ProcPlotE = function(argPlotNo, nStart, nDSize, nPeriod) {
                    var dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(argPlotNo), nLimit = nPeriod + _self.m_nRefSkip, nOffset = nStart;
                    if (void 0 === xPlot || null == xPlot) return nLimit;
                    for (;nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var dSumL = 0, dData = 0, arrData = [], dEMA_1 = 0, nIdx = 0, reg_j = 0, reg_i = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPrice;
                        if (nIdx = reg_i - 1, reg_i === nLimit) {
                            arrData = [];
                            var nGo = nIdx - (nPeriod - 1), nStop = nGo + nPeriod;
                            for (reg_j = nGo; reg_j < nStop; reg_j++) stPrice = _self.didGetReferencedBaseDataAt(reg_j, !1), 
                            dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), arrData.push(dData);
                            var xMAEx = xUtils.math.CalcMAEx(arrData, dSumL, nPeriod, xUtils.math.constants.methods.simple, !0, !0);
                            dEMA_1 = xMAEx.ma, dSumL = xMAEx.sum;
                        } else dEMA_1 = xPlot.didGetDataAt(nIdx);
                        arrData = [], arrData.push(dEMA_1), stPrice = _self.didGetReferencedBaseDataAt(reg_i, !1), 
                        dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), arrData.push(dData), 
                        dData = xUtils.math.CalcMA(arrData, nPeriod, xUtils.math.constants.methods.exponential), 
                        xPlot.didSetData(reg_i, !0, dData);
                    }
                    return nLimit;
                }, this.ProcPlotW = function(argPlotNo, nStart, nDSize, nPeriod) {
                    var dFactor = _self.didGetPriceFactor(), xPlot = _self.didGetPlotAt(argPlotNo), nLimit = nPeriod - 1 + _self.m_nRefSkip, nOffset = nStart;
                    if (void 0 === xPlot || null == xPlot) return nLimit;
                    for (;nOffset < nLimit && nOffset < nDSize; ) xPlot.didSetInvalidData(nOffset), 
                    nOffset++;
                    var dData = 0, arrData = [], reg_j = 0, reg_i = 0;
                    if (nOffset >= nLimit) for (reg_i = nOffset; reg_i < nDSize; reg_i++) {
                        var stPrice;
                        arrData = [];
                        var nGo = reg_i - (nPeriod - 1), nStop = nGo + nPeriod;
                        for (reg_j = nGo; reg_j < nStop; reg_j++) stPrice = _self.didGetReferencedBaseDataAt(reg_j, !1), 
                        dData = xUtils.didGetPriceValue(stPrice, _self.m_nPrice, dFactor), arrData.push(dData);
                        arrData, dData = xUtils.math.CalcMA(arrData, nPeriod, xUtils.math.constants.methods.weight), 
                        xPlot.didSetData(reg_i, !0, dData), !1;
                    }
                    return nLimit;
                };
            }, exports = {};
            return exports.didGetBaseSeriesClass = function() {
                return _DOSIndicator;
            }, exports.didGetBasePlotClass = function() {
                return _DOPlot;
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDOSeriesBase = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil, global.WGC_CHART.chartDOContainerBase) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1), __webpack_require__(8));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc) {
            return function(chartWrapper, drawWrapper) {
                var _self = this;
                this.OBJECT_NAME = "BASE_AXIS", this.m_drawWrapper = drawWrapper, this.m_xAxisPanel = {}, 
                this.m_objCrosslineX = {}, this.m_canvas = {}, this.m_context = {}, this.WIDTH = 0, 
                this.HEIGHT = 0, this.memcanvas = {}, this.mctx = {}, this.m_rectInfo = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    lw: 0,
                    rw: 0
                }, this.isNontime = !1, this.didDrawPanelBorder = function() {
                    var __lineColor = _self.m_drawWrapper.m_stEnv.XAxisBorderColor, __drawLineParam = {
                        context: _self.m_context,
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: 0
                        },
                        lineWidth: 1,
                        lineColor: __lineColor
                    }, __drawRectParam = {
                        context: _self.m_context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: 1,
                        lineColor: __lineColor
                    }, __panelWidth = _self.didGetDrawingWidth(), __panelHeight = _self.didGetDrawingHeight();
                    __drawRectParam.rect.width = __panelWidth - 2, __drawRectParam.rect.height = __panelHeight - 2, 
                    gxDc.Rectangle(__drawRectParam);
                    var __chartFrameAreaInfo = _self.m_drawWrapper.GetChartFrameAreaInfo();
                    __drawLineParam.pt1.x = __chartFrameAreaInfo.chart.left, __drawLineParam.pt1.y = 0, 
                    __drawLineParam.pt2.x = __chartFrameAreaInfo.chart.left, __drawLineParam.pt2.y = __panelHeight - 2, 
                    gxDc.Line(__drawLineParam), __drawLineParam.pt1.x = __chartFrameAreaInfo.chart.left + __chartFrameAreaInfo.chart.width - 1, 
                    __drawLineParam.pt1.y = 0, __drawLineParam.pt2.x = __chartFrameAreaInfo.chart.left + __chartFrameAreaInfo.chart.width - 1, 
                    __drawLineParam.pt2.y = __panelHeight - 2, gxDc.Line(__drawLineParam);
                }, this.didDrawXAxis = function() {
                    var xEnv = _self.didGetEnvInfo(), gridWidth = _self.m_drawWrapper.GetDrawPanelWidth(), __drawParam = {
                        scrollInfo: {
                            pos: _self.m_drawWrapper.m_xScrollInfo.pos,
                            screenSize: _self.m_drawWrapper.m_xScrollInfo.screenSize
                        },
                        timeType: _self.m_drawWrapper.didGetReferencedPriceObject().m_symbolInfo.nTType,
                        timeInterval: _self.m_drawWrapper.didGetReferencedPriceObject().m_symbolInfo.nTGap,
                        config: {
                            font: xEnv.ConfigAxis.Font,
                            fontColor: xEnv.ConfigAxis.FontColor,
                            gridStyle: xEnv.ConfigAxis.GridStyle,
                            gridColor: xEnv.ConfigAxis.GridVertColor,
                            show: xEnv.ConfigAxis.GridShow
                        },
                        height: _self.didGetDrawingHeight(),
                        axis: _self,
                        drawWrapper: _self.m_drawWrapper,
                        isGrid: !1,
                        target: {
                            context: _self.m_context,
                            leftWidth: xEnv.System.YAxisLeft,
                            rightWidth: xEnv.System.YAxisRight,
                            gridWidth: gridWidth
                        },
                        clip: {
                            x: xEnv.System.YAxisLeft,
                            y: 0,
                            width: _self.m_drawWrapper.GetChartFrameAreaWidth(),
                            height: _self.didGetDrawingHeight()
                        },
                        levelInfo: _self.m_drawWrapper.didGetScrollLevelInfo(),
                        isNontime: _self.isNontime
                    };
                    xUtils.axis.didDrawXAxisWithLevel(__drawParam);
                }, this.didResizePanel = function(resizeParam) {
                    if (void 0 !== resizeParam && null != resizeParam) {
                        _self.m_rectInfo.x = resizeParam.left, _self.m_rectInfo.y = resizeParam.top, _self.m_rectInfo.width = resizeParam.width, 
                        _self.m_rectInfo.height = resizeParam.height, _self.m_rectInfo.lw = resizeParam.leftY, 
                        _self.m_rectInfo.rw = resizeParam.rightY;
                        var devicePixelRatio = window.devicePixelRatio || 1, ratio = devicePixelRatio;
                        _self.m_canvas.width = ratio * resizeParam.width, _self.m_canvas.height = ratio * resizeParam.height, 
                        _self.m_canvas.style.width = resizeParam.width + "px", _self.m_canvas.style.height = resizeParam.height + "px", 
                        _self.m_xAxisPanel.style.left = resizeParam.left + "px", _self.m_xAxisPanel.style.top = resizeParam.top + "px", 
                        _self.m_xAxisPanel.style.width = resizeParam.width + "px", _self.m_xAxisPanel.style.height = resizeParam.height + "px";
                    }
                }, this.didDraw = function() {
                    var xEnv = _self.didGetEnvInfo();
                    _self.m_canvas.style.backgroundColor = xEnv.XAxisBackgroundColor, _self.m_context === _self.mctx ? _self.m_context.fillStyle = "black" : _self.m_context.fillStyle = _self.fill, 
                    _self.x > _self.WIDTH || _self.y > _self.HEIGHT || _self.x + _self.w < 0 || _self.y + _self.h < 0 || (_self.SetBaseSize(), 
                    _self.m_context.clearRect(0, 0, _self.m_canvas.width, 1), _self.m_context.clearRect(0, 0, _self.m_canvas.width, _self.m_canvas.height), 
                    _self.m_context.translate(.5, .5), _self.m_context.font = xEnv.ConfigAxis.Font, 
                    _self.m_context.fillStyle = xEnv.ConfigAxis.FontColor, _self.DrawCrossLineX(), _self.didDrawXAxis(), 
                    _self.didDrawPanelBorder(), _self.m_context.translate(-.5, -.5));
                }, this.didGetCrosslinePoint = function() {
                    return _self.m_drawWrapper.didGetCrosslinePoint();
                }, this.Init = function(initParam) {
                    var xEnv = _self.didGetEnvInfo(), xAxisPanelElemInfo = _self.m_drawWrapper.GetXAxisPanelElementInfo();
                    _self.m_xAxisPanel = xAxisPanelElemInfo.panel, _self.m_canvas = xAxisPanelElemInfo.canvas, 
                    _self.m_objCrosslineX = xAxisPanelElemInfo.label, _self.m_canvas.left = 0, _self.m_canvas.width = _self.m_xAxisPanel.offsetWidth, 
                    _self.m_canvas.height = xUtils.didGetXAxisHeight(xEnv), _self.HEIGHT = _self.m_canvas.height, 
                    _self.WIDTH = _self.m_canvas.width, _self.m_context = _self.m_canvas.getContext("2d"), 
                    _self.m_objCrosslineX.setAttributeNS(null, "id", "idCrosslineX"), _self.m_objCrosslineX.style.left = "0px", 
                    _self.m_objCrosslineX.style.top = "1px", _self.m_objCrosslineX.style.position = "absolute", 
                    _self.m_objCrosslineX.style.visibility = "hidden", _self.m_xAxisPanel.appendChild(_self.m_objCrosslineX), 
                    _self.memcanvas = document.createElement("canvas"), _self.memcanvas.height = _self.HEIGHT, 
                    _self.memcanvas.width = _self.WIDTH, _self.mctx = _self.memcanvas.getContext("2d");
                }, this.SetBaseSize = function() {
                    return !0;
                }, this.SetCrossLine = function(posval) {
                    var __nCrossLineXPos = posval.XPos, __nCrossLineYPos = posval.YPos;
                    _self.DrawCrossLineX(__nCrossLineXPos, __nCrossLineYPos);
                }, this.DrawCrossLineX = function(iXPos, iYPos) {
                    var xEnv = _self.didGetEnvInfo();
                    if (!0 === xEnv.CrossLine.hide) return void (_self.m_objCrosslineX.style.visibility = "hidden");
                    var nCrossLineXPos = -1, nCrossLineYPos = -1;
                    if (void 0 === iXPos || null == iXPos || void 0 === iYPos || null == iYPos) {
                        var ptCrossline = _self.didGetCrosslinePoint();
                        nCrossLineXPos = ptCrossline.x, nCrossLineYPos = ptCrossline.y;
                    } else nCrossLineXPos = iXPos, nCrossLineYPos = iYPos;
                    if (iXPos = nCrossLineXPos, (iYPos = nCrossLineYPos) > -1) {
                        var xTimeData = _self.GetXPosToVal(iXPos);
                        if (void 0 === xTimeData || null == xTimeData) return;
                        var strDateTime = xTimeData.dateTime;
                        if (void 0 === strDateTime || null == strDateTime) return;
                        if (strDateTime.length < 4) return;
                        var strDate = String(strDateTime).substring(0, 4) + "/" + String(strDateTime).substring(4, 6) + "/" + String(strDateTime).substring(6, 8), strTime = "", __nTType = _self.m_drawWrapper.didGetReferencedPriceObject().m_symbolInfo.nTType, nDispWidth = xEnv.System.CrosslineLabelXWidth;
                        __nTType <= xUtils.constants.timeType.hour ? (strDate = String(strDateTime).substring(0, 4) + "/" + String(strDateTime).substring(4, 6) + "/" + String(strDateTime).substring(6, 8), 
                        strTime = String(strDateTime).substring(8, 14), 5 == strTime.length ? strTime = "0" + strTime : 4 == strTime.length ? strTime = "00" + strTime : 3 == strTime.length ? strTime = "000" + strTime : 2 == strTime.length ? strTime = "0000" + strTime : 1 == strTime.length && (strTime = "00000" + strTime), 
                        __nTType < xUtils.constants.timeType.minute ? (strDate = "", strTime = strTime.substring(0, 2) + ":" + strTime.substring(2, 4) + ":" + strTime.substring(4, 6), 
                        strTime, iXPos = _self.SetXPosition(iXPos) - parseInt(nDispWidth / 2), _self.m_objCrosslineX.innerHTML = "&nbsp" + strTime + "&nbsp") : (strTime = strTime.substring(0, 2) + ":" + strTime.substring(2, 4), 
                        strDate + " " + strTime, iXPos = _self.SetXPosition(iXPos) - parseInt(nDispWidth / 2), 
                        _self.m_objCrosslineX.innerHTML = "&nbsp" + strDate.substring(5, strDate.length) + "&nbsp" + strTime + "&nbsp")) : (strDate = __nTType > xUtils.constants.timeType.week ? String(strDateTime).substring(0, 4) + "/" + String(strDateTime).substring(4, 6) : String(strDateTime).substring(0, 4) + "/" + String(strDateTime).substring(4, 6) + "/" + String(strDateTime).substring(6, 8), 
                        strDate, iXPos = _self.SetXPosition(iXPos) - parseInt(nDispWidth / 2), _self.m_objCrosslineX.innerHTML = "&nbsp" + strDate + "&nbsp"), 
                        _self.m_objCrosslineX.style.top = "1px", iXPos += xEnv.ExtraPanelWidth;
                        var __panelWidth = _self.didGetDrawingWidth();
                        _self.didGetDrawingHeight();
                        iXPos < _self.m_drawWrapper.m_stEnv.System.YAxisLeft ? iXPos = _self.m_drawWrapper.m_stEnv.System.YAxisLeft : iXPos + _self.m_objCrosslineX.offsetWidth > __panelWidth - _self.m_drawWrapper.m_stEnv.System.YAxisRight && (iXPos = __panelWidth - _self.m_drawWrapper.m_stEnv.System.YAxisRight - _self.m_objCrosslineX.offsetWidth), 
                        _self.m_objCrosslineX.style.left = iXPos + "px", _self.m_objCrosslineX.style.visibility = "visible";
                    } else _self.m_objCrosslineX.style.visibility = "hidden";
                }, this.SetXPosition = function(argPosX) {
                    var scrPosInfo = _self.m_drawWrapper.GetRelativePositionXInfo(argPosX), nScrIdx = (scrPosInfo.pos, 
                    scrPosInfo.idx);
                    return _self.GetXPos(nScrIdx);
                }, this.DrawLine = function(stStyle) {
                    _self.m_context.beginPath(), _self.m_context.moveTo(stStyle.startX, stStyle.startY), 
                    _self.m_context.lineTo(stStyle.endX, stStyle.endY), _self.m_context.lineWidth = stStyle.lineWidth, 
                    _self.m_context.strokeStyle = stStyle.lineColor, _self.m_context.stroke();
                }, this.DrawRectangle = function(stStyle) {
                    _self.m_context.beginPath(), _self.m_context.rect(stStyle.rectX, stStyle.rectY, stStyle.rectW, stStyle.rectH), 
                    _self.m_context.fillStyle = stStyle.fillColor, _self.m_context.fill(), _self.m_context.lineWidth = stStyle.lineWidth, 
                    _self.m_context.strokeStyle = stStyle.lineColor, _self.m_context.stroke();
                }, this.DrawText = function(stStyle) {
                    void 0 !== stStyle.context && null != stStyle.context && (stStyle.context.save(), 
                    void 0 !== stStyle.fillColor && null != stStyle.fillColor && (stStyle.context.fillStyle = stStyle.fillColor), 
                    stStyle.context.fillText(stStyle.text, stStyle.left, stStyle.top), stStyle.context.restore());
                }, this.OnDestroy = function() {
                    _self.didRemoveLinkElements();
                }, this.didRemoveLinkElements = function() {}, this.didGetAxisX = function() {
                    return _self.m_drawWrapper.didGetAxisX();
                }, this.GetXPos = function(argLocalIdx) {
                    return _self.didGetAxisX().GetXPos(argLocalIdx) + _self.m_drawWrapper.m_stEnv.System.YAxisLeft;
                }, this.GetXPosToVal = function(argPosX) {
                    var __nLocalXPos = argPosX - _self.m_drawWrapper.m_stEnv.System.YAxisLeft, __dataIdx = _self.m_drawWrapper.didConvertHorizontalPosToDataIndex(__nLocalXPos, !0);
                    return _self.m_drawWrapper.didGetTimedataAt(__dataIdx, !1, !0);
                }, this.didGetRatioHorizontal = function(baseIsPixel) {
                    return _self.m_drawWrapper.didGetRatioHorizontal(baseIsPiexel);
                }, this.didGetEnvInfo = function() {
                    return _self.m_drawWrapper.didGetEnvInfo();
                }, this.didGetDrawingWidth = function() {
                    return _self.m_rectInfo.width;
                }, this.didGetDrawingHeight = function() {
                    return _self.m_rectInfo.height;
                }, this.didChangeCrosslineLabelShowStatus = function() {
                    !0 === _self.didGetEnvInfo().CrossLine.hide ? _self.m_objCrosslineX.style.visibility = "hidden" : _self.m_objCrosslineX.style.visibility = "visible";
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartXAxisPanelBase = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc) {
            return function(chartWrapper, drawWrapper) {
                var _self = this, _chartWrapper = chartWrapper, _drawWrapper = drawWrapper;
                this.OBJECT_NAME = "EXTRA_LAYOUT", this.m_chartWrapper = _chartWrapper, this.m_drawWrapper = _drawWrapper, 
                this.m_domElemRoot = null, this.m_canvas = null, this.m_context = null, this.m_memcanvas = null, 
                this.m_rectInfo = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    lw: 0,
                    rw: 0
                }, _self.m_xDoExtraSelected = null, this.didInitElements = function(domElemRoot) {
                    if (domElemRoot) {
                        var xEnv = _self.didGetEnvInfo();
                        _self.m_domElemRoot = domElemRoot;
                        _self.m_domElemRoot;
                        _self.m_canvas = document.createElement("canvas"), _self.m_canvas.setAttributeNS(null, "id", "eidExtraPanelItem"), 
                        _self.m_canvas.className = "classExtraPanelItem", _self.m_canvas.style.backgroundColor = xEnv.ExtraPanelBackground, 
                        _self.m_canvas.style.visibility = xUtils.didGetAxisPanelVisibility(xEnv), _self.m_domElemRoot.appendChild(_self.m_canvas), 
                        _self.didInitContext();
                    }
                }, this.didInitContext = function() {
                    _self.m_context = _self.m_canvas.getContext("2d"), _self.m_memcanvas = document.createElement("canvas"), 
                    _self.m_memcanvas.width = _self.m_canvas.width, _self.m_memcanvas.height = _self.m_canvas.height, 
                    _self.m_memcontext = _self.m_memcanvas.getContext("2d");
                }, this.didInitPanel = function(domElemRoot) {
                    _self.didInitElements(domElemRoot);
                }, this.didDraw = function() {
                    var xEnv = _self.didGetEnvInfo();
                    _self.m_canvas.style.backgroundColor = xEnv.BackgroundColor, _self.m_context === _self.mctx ? _self.m_context.fillStyle = "black" : _self.m_context.fillStyle = _self.fill, 
                    _self.m_rectInfo.width < 0 || _self.m_rectInfo.height < 0 || (_self.m_context.clearRect(0, 0, _self.m_canvas.width, 1), 
                    _self.m_context.clearRect(0, 0, _self.m_canvas.width, _self.m_canvas.height), _self.m_context.translate(.5, .5), 
                    _self.m_context.font = xEnv.ConfigAxis.Font, _self.m_context.fillStyle = xEnv.ConfigAxis.FontColor, 
                    _self.didDrawPanelBorder(), _self.didDrawObjects(), _self.m_context.translate(-.5, -.5));
                }, this.didDrawPanelBorder = function() {
                    var __xEnv = _self.didGetEnvInfo(), __lineColor = __xEnv.BorderColor, __drawRectParam = (_self.m_context, 
                    {
                        context: _self.m_context,
                        rect: {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        },
                        lineWidth: 1,
                        lineColor: __lineColor
                    }), __panelWidth = _self.m_rectInfo.width, __panelHeight = _self.m_rectInfo.height;
                    __drawRectParam.rect.width = __panelWidth - 2, __drawRectParam.rect.height = __panelHeight - 2, 
                    gxDc.Rectangle(__drawRectParam);
                };
                var _didGetDoExecutions = function() {
                    try {
                        var xDoPrice = _self.m_drawWrapper.didGetReferencedPriceObject();
                        if (xDoPrice && xDoPrice.didGetDoExecutions) return xDoPrice.didGetDoExecutions(!0);
                    } catch (e) {
                        console.error(e);
                    }
                }, _didGetDoPositions = function() {
                    try {
                        var xDoPrice = _self.m_drawWrapper.didGetReferencedPriceObject();
                        if (xDoPrice && xDoPrice.didGetDoPositions) return xDoPrice.didGetDoPositions(!0);
                    } catch (e) {
                        console.error(e);
                    }
                }, _didDrawDoExtras = function(extraDatas, posval) {
                    if (void 0 !== extraDatas && null != extraDatas) for (var extraDrawParam = {
                        context: _self.m_context,
                        memcontext: _self.m_memcontext,
                        rect: xUtils.didClone(_self.m_rectInfo),
                        pt: {
                            x: parseInt(_self.m_rectInfo.width / 2)
                        },
                        offSelect: !0,
                        caller: _self
                    }, nObjectCount = extraDatas.length, ii = 0; ii < nObjectCount; ii++) {
                        var doExtra = extraDatas[ii];
                        doExtra && doExtra.DrawObjAtFixedPosX && doExtra.DrawObjAtFixedPosX(posval, extraDrawParam);
                    }
                }, _didDrawDoExecutions = function(posval) {
                    var doExecutions = _didGetDoExecutions();
                    _didDrawDoExtras(doExecutions);
                }, _didDrawDoPositions = function(posval) {
                    var doPositions = _didGetDoPositions();
                    _didDrawDoExtras(doPositions);
                };
                this.didDrawObjects = function() {
                    _didDrawDoExecutions(), _didDrawDoPositions();
                };
                var _didHitTestObject = function(extraDatas, posval) {
                    if (void 0 !== extraDatas && null != extraDatas) {
                        posval.YPos = posval.YPos - _self.m_domElemRoot.offsetTop, posval.YPosAdjusted = !0;
                        var hitPoint = {
                            XPos: _self.m_drawWrapper.GetPosXMargined(posval.XPos, !0),
                            YPos: _self.m_drawWrapper.GetPosYMargined(posval.YPos)
                        }, rect = {
                            x: 0,
                            y: 0,
                            width: _self.m_canvas.width,
                            height: _self.m_canvas.height
                        }, hitTestTool = xUtils.hitTest.prepareTools(rect, hitPoint, _self.m_memcanvas, _self.m_memcontext);
                        hitTestTool.willBeHitTest(!0);
                        var iSelectIndex = -1;
                        _self.m_xDoExtraSelected = null;
                        for (var extraDrawParam = (_self.didGetEnvInfo(), {
                            context: _self.m_context,
                            memcontext: _self.m_memcontext,
                            rect: xUtils.didClone(_self.m_rectInfo),
                            pt: {
                                x: parseInt(_self.m_rectInfo.width / 2)
                            },
                            offSelect: !0,
                            caller: _self
                        }), nObjectCount = extraDatas.length, ii = 0; ii < nObjectCount; ii++) {
                            var doExtra = extraDatas[ii];
                            if (doExtra && doExtra.didHitTest && (_self.m_xDoExtraSelected = doExtra.didHitTest(posval, hitTestTool, extraDrawParam), 
                            _self.m_xDoExtraSelected)) {
                                iSelectIndex = xUtils.constants.default.DEFAULT_WRONG_VALUE;
                                break;
                            }
                        }
                        return hitTestTool.closeHitTest(!0), hitTestTool = {}, iSelectIndex;
                    }
                };
                this.OnSelectChartObj = function(posval) {
                    var doPositions = _didGetDoPositions(), selectedIndex = _didHitTestObject(doPositions, posval);
                    if (selectedIndex >= 0 && _self.m_xDoExtraSelected) return selectedIndex;
                    var doExecutions = _didGetDoExecutions();
                    return _didHitTestObject(doExecutions, posval);
                }, this.didResizePanel = function(resizeParam) {
                    if (void 0 !== resizeParam && null != resizeParam) {
                        _self.m_rectInfo.x = resizeParam.left, _self.m_rectInfo.y = resizeParam.top, _self.m_rectInfo.width = resizeParam.width, 
                        _self.m_rectInfo.height = resizeParam.height, _self.m_rectInfo.lw = resizeParam.leftY, 
                        _self.m_rectInfo.rw = resizeParam.rightY;
                        var devicePixelRatio = window.devicePixelRatio || 1, ratio = devicePixelRatio;
                        _self.m_canvas.width = ratio * resizeParam.width, _self.m_canvas.height = ratio * resizeParam.height, 
                        _self.m_canvas.style.width = resizeParam.width + "px", _self.m_canvas.style.height = resizeParam.height + "px";
                    }
                }, this.didGetEnvInfo = function() {
                    return _self.m_drawWrapper.didGetEnvInfo();
                }, this.didDestroy = function() {
                    _self.m_domElemRoot && _self.m_domElemRoot.removeChild(_self.m_canvas), _self.m_domElemRoot = null, 
                    _self.m_canvas = null, _self.m_context = null, _self.m_memcanvas = null, _self.m_chartWraper = null, 
                    _self.m_ctrlLayout = null;
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDrawPanelExtra = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc) {
            return function(chartWrapper, drawWrapper) {
                var _self = this, _chartWrapper = chartWrapper, _drawWrapper = drawWrapper;
                this.OBJECT_NAME = "TOOLTIP_LAYOUT", this.m_chartWrapper = _chartWrapper, this.m_drawWrapper = _drawWrapper, 
                this.m_domElemRoot = null, this.m_domElemDisp = null, this.m_rectInfo = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    lw: 0,
                    rw: 0
                }, _self.m_xSelectedExecutionObject = null, this.m_tooltipData, this.m_toolTipPosval, 
                this.didInitElements = function(domElemRoot) {
                    if (domElemRoot) {
                        _self.didGetEnvInfo();
                        _self.m_domElemRoot = domElemRoot;
                        _self.m_domElemRoot;
                        _self.m_domElemDisp = document.createElement("div"), _self.m_domElemDisp.setAttributeNS(null, "id", "eidTooltipPanelItem"), 
                        _self.m_domElemDisp.className = "classTooltipPanelItem", _self.m_domElemDisp.style.position = "absolute", 
                        _self.m_domElemRoot.appendChild(_self.m_domElemDisp);
                    }
                }, this.didInitPanel = function(domElemRoot) {
                    _self.didInitElements(domElemRoot);
                }, this.didGetEnvInfo = function() {
                    return _self.m_drawWrapper.didGetEnvInfo();
                }, this.isShown = function() {
                    return !(!_self.m_domElemDisp || !_self.m_domElemDisp.style || "hidden" == _self.m_domElemDisp.style.visibility);
                }, this.didShowTooltip = function(isShow, posval, tooltipData, limitRect) {
                    try {
                        var xEnv = _self.didGetEnvInfo();
                        if (1 == isShow) {
                            var newPosval = {
                                XPos: posval.XPos,
                                YPos: posval.YPos + xEnv.TooltipOffset
                            }, checkPosval = {
                                XPos: newPosval.XPos + _self.m_domElemDisp.offsetWidth,
                                YPos: newPosval.YPos + _self.m_domElemDisp.offsetHeight
                            };
                            limitRect && (checkPosval.XPos > limitRect.x + limitRect.width && (newPosval.XPos = posval.XPos - _self.m_domElemDisp.offsetWidth), 
                            checkPosval.YPos > limitRect.y + limitRect.height && (newPosval.YPos = posval.YPos - (xEnv.TooltipOffset + _self.m_domElemDisp.offsetHeight))), 
                            _self.m_domElemDisp.innerHTML = tooltipData, console.log(_self.m_domElemDisp.offsetHeight), 
                            (!0 !== _self.isShown() || _self.m_tooltipData && _self.m_tooltipData != tooltipData) && newPosval && (_self.m_domElemDisp.style.left = newPosval.XPos + "px", 
                            _self.m_domElemDisp.style.top = newPosval.YPos + "px"), _self.m_tooltipData = tooltipData, 
                            _self.m_toolTipPosval = xUtils.didClone(newPosval), _self.m_domElemDisp.style.visibility = "visible";
                        } else _self.m_domElemDisp.style.visibility = "hidden";
                    } catch (e) {
                        console.error(e);
                    }
                }, this.didDestroy = function() {
                    _self.m_domElemRoot && _self.m_domElemRoot.removeChild(_self.m_domElemDisp), _self.m_domElemRoot = null, 
                    _self.m_domElemDisp = null, _self.m_chartWraper = null, _self.m_ctrlLayout = null;
                };
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDrawPanelTooltip = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.canvas2DUtil) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(1));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, dataHandlerFactory) {
            return function() {
                var _self = this;
                this.m_domElem = null, this.m_jqElem$ = null, this.m_chartWrap = null, this.m_xDataHanler = null, 
                this.m_xDataHanlers = [], this.didGetLastData = function(id) {
                    var xPriceDataInfo = _self.m_chartWrap.didGetBasePriceDataInfo(id);
                    if (void 0 !== xPriceDataInfo && null != xPriceDataInfo && void 0 !== xPriceDataInfo.datas && null != xPriceDataInfo.datas) {
                        var nDataCount = xPriceDataInfo.datas.length;
                        if (!(nDataCount < 1)) return xPriceDataInfo.datas[nDataCount - 1];
                    }
                }, this.didGetLastDatetimeUnit = function(id) {
                    var stLastData = _self.didGetLastData(id);
                    if (void 0 !== stLastData && null != stLastData) {
                        return xUtils.timeZone.convertDatetimeToTimeunit(stLastData.ymd, stLastData.hms);
                    }
                };
                var _didInitDefaultDataHandler = function() {
                    _self.m_xDataHanler = dataHandlerFactory.didGetDataHandlerEx(_self);
                };
                this.didInitialize = function(jqElem, argChartWrap) {
                    _self.m_jqElem$ = jqElem, _self.m_domElem = _self.m_jqElem$.get(0), _self.m_chartWrap = argChartWrap, 
                    _self.didInitForDemo(), _didInitDefaultDataHandler();
                }, this.didDestroy = function() {
                    delete _self.m_xDataHanler, _self.m_xDataHanler = null;
                }, this.OnReceiveData = function(receiveRawDatas, requestInfo, timeZoneInfo, multiTargetId) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveData(receiveRawDatas, requestInfo, timeZoneInfo, multiTargetId);
                }, this.OnReceiveNextData = function(receiveRawDatas) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveNextData(receiveRawDatas);
                }, this.OnReceiveAlertData = function(receiveDatas) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveAlertData(receiveDatas);
                }, this.OnReceiveExecutionData = function(receiveDatas) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveExecutionData(receiveDatas);
                }, this.OnReceiveOrderData = function(receiveDatas) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveOrderData(receiveDatas);
                }, this.OnReceivePositData = function(receiveDatas) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceivePositData(receiveDatas);
                }, this.OnReceiveRealData = function(receiveData, multiTargetId) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveRealData(receiveData, multiTargetId);
                }, this.OnReceiveRealDatas = function(receiveDatas, multiTargetId) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveRealDatas(receiveDatas, multiTargetId);
                }, this.OnReceiveRealDataAsCandleStick = function(receiveRawData) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveRealDataAsCandleStick(receiveRawData);
                }, this.OnReceiveRealDataAsTick = function(receiveRawData) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveRealDataAsTick(receiveRawData);
                }, this.OnReceiveBusinessDate = function(businessDate, bDraw, timeZoneInfo) {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.OnReceiveBusinessDate(businessDate, bDraw, timeZoneInfo);
                }, this.didClearDatas = function() {
                    if (void 0 !== _self.m_xDataHanler && null != _self.m_xDataHanler) return _self.m_xDataHanler.didClearDatas();
                }, this.didInitForDemo = function() {};
            };
        };
        global.WGC_CHART ? global.WGC_CHART.chartDataConverter = loadModule(global.WGC_CHART.chartUtil, global.WGC_CHART.chartDataHandler) : module.exports = loadModule(__webpack_require__(0), __webpack_require__(34));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils) {
            var CTimeManager = function() {
                var _self = this;
                this.m_xOwner = null, this.m_nTimeType = xUtils.constants.timeType.minute, this.m_nTimeGap = 1, 
                this.m_xTimezoneInfo = {};
                var _didCompareDatetimeUnitInTimezoneAsOneday = function(dateTimeUnit) {
                    return void 0 === _self.m_xTimezoneInfo.oneDayUnit || null == _self.m_xTimezoneInfo.oneDayUnit ? -1 : dateTimeUnit < _self.m_xTimezoneInfo.oneDayUnit.begin ? -1 : dateTimeUnit >= _self.m_xTimezoneInfo.oneDayUnit.limit ? 1 : 0;
                }, _didCompareDatetimeInTimezone = function(timeZone, dateTimeUnit) {
                    return timeZone.unit.begin > dateTimeUnit ? -1 : timeZone.unit.begin <= dateTimeUnit && dateTimeUnit < timeZone.unit.limit ? 0 : 1;
                }, _didFindTimezoneNoWithDatetimeUnit = function(dateTimeUnit) {
                    for (var ii in _self.m_xTimezoneInfo.timeZones) {
                        var timeZone = _self.m_xTimezoneInfo.timeZones[ii];
                        if (void 0 !== timeZone && null != timeZone && !0 === timeZone.use && 0 == _didCompareDatetimeInTimezone(timeZone, dateTimeUnit)) return parseInt(ii);
                    }
                };
                this.didInitTimeManager = function(owner) {
                    _self.m_xOwner = owner;
                }, this.didClearAndMakeTimeTable = function(timeType, timeGap, requestCode, businessDate, timeZoneInfo, useDefault) {
                    if (_self.m_nTimeType = timeType, _self.m_nTimeGap = timeGap, void 0 === timeZoneInfo || null == timeZoneInfo) {
                        if ((void 0 === _self.m_xTimezoneInfo || null == _self.m_xTimezoneInfo) && !0 === useDefault && (_self.m_xTimezoneInfo = xUtils.debug.getTimeZoneInfo(requestCode), 
                        void 0 === _self.m_xTimezoneInfo || null == _self.m_xTimezoneInfo)) return;
                    } else if (_self.m_xTimezoneInfo = xUtils.didClone(timeZoneInfo), void 0 === _self.m_xTimezoneInfo || null == _self.m_xTimezoneInfo) return;
                    if (void 0 !== businessDate && null != businessDate && (_self.m_xTimezoneInfo.businessDate = businessDate), 
                    !(void 0 === _self.m_xTimezoneInfo.businessDate || null == _self.m_xTimezoneInfo.businessDate || _self.m_xTimezoneInfo.businessDate < xUtils.constants.ngc.define.NGC_JUL_DATESTART)) {
                        for (var oneDayUnit = {
                            begin: null,
                            final: null,
                            limit: null
                        }, nTimezoneCount = _self.m_xTimezoneInfo.timeZones.length, ii = 0; ii < nTimezoneCount; ii++) {
                            var timeZone = _self.m_xTimezoneInfo.timeZones[ii];
                            void 0 !== timeZone && null != timeZone && !0 === timeZone.use && (xUtils.timeZone.calculateTimezoneUnit(_self.m_xTimezoneInfo.businessDate, timeZone), 
                            void 0 !== oneDayUnit.begin && null != oneDayUnit.begin || (oneDayUnit.begin = timeZone.unit.begin), 
                            void 0 !== timeZone.unit.final && null != timeZone.unit.final && (oneDayUnit.final = timeZone.unit.final), 
                            void 0 !== timeZone.unit.limit && null != timeZone.unit.limit && (oneDayUnit.limit = timeZone.unit.limit));
                        }
                        _self.m_xTimezoneInfo.oneDayUnit = oneDayUnit;
                    }
                }, this.didMarkingTimezoneWithDatetime = function(timeType, timeGap, stPrice, tickCount) {
                    var result = {
                        valid: !0,
                        priceDatas: [],
                        isAdd: !1,
                        stPrice: null,
                        compare: 0,
                        isTickUp: !1,
                        reason: ""
                    }, businessDate = _self.m_xTimezoneInfo.businessDate, businessTime = _self.m_xTimezoneInfo.businessTime, newDatetimeUnit = xUtils.timeZone.convertDatetimeToTimeunit(stPrice.ymd, stPrice.hms);
                    if (result.compare = _didCompareDatetimeUnitInTimezoneAsOneday(newDatetimeUnit), 
                    result.compare < 0) return result.valid = !1, result.reason = "received datetime is older than business date => Business(" + businessDate + "), Income(" + stPrice.ymd + ")", 
                    result;
                    if (result.compare > 0) return result.valid = !1, result.reason = "received datetime is over than business date => Business(" + businessDate + "), Income(" + stPrice.ymd + ")", 
                    result;
                    var stLastData = _self.m_xOwner.didGetLastData();
                    if (timeType === xUtils.constants.timeType.tick) {
                        if (void 0 === stLastData || null == stLastData) return result.isAdd = !0, result.stPrice = stPrice, 
                        result;
                        var lastDatetimeUnit = xUtils.timeZone.convertDatetimeToTimeunit(stLastData.ymd, stLastData.hms);
                        if (lastDatetimeUnit > newDatetimeUnit) return result.valid = !1, result;
                        var __tno = 0;
                        return timeGap < 2 ? result.isAdd = !0 : nTickCount >= timeGap ? result.isAdd = !0 : (result.isAdd = !1, 
                        result.isTickUp = !0), !0 === result.isAdd && lastDatetimeUnit === newDatetimeUnit && (__tno = stLastData.tno + 1), 
                        stPrice.tno = __tno, result.stPrice = stPrice, result;
                    }
                    if (timeType === xUtils.constants.timeType.week) {
                        var weekDay = xUtils.dateTime.defaultWeekday, xBusinessDate = xUtils.dateTime.convertNumberToDate(businessDate, businessTime), xNewDate = xUtils.dateTime.getDateOfTheWeekAtDate(xBusinessDate, weekDay);
                        if (stPrice.ymd = xUtils.dateTime.convertDateToNumber(xNewDate), stPrice.hms = businessTime, 
                        void 0 === stLastData || null == stLastData) return result.isAdd = !0, result.stPrice = stPrice, 
                        result;
                        var xLastDate = xUtils.dateTime.convertNumberToDate(stLastData.ymd, businessTime), xLastWeekDate = xUtils.dateTime.getDateOfTheWeekAtDate(xLastDate, weekDay), diff = xUtils.dateTime.dateDiff(xLastWeekDate, xNewDate, "week", !0);
                        return diff < 0 ? (result.valid = !1, result) : (result.stPrice = stPrice, diff > 0 && (result.isAdd = !0), 
                        result);
                    }
                    if (timeType === xUtils.constants.timeType.month) {
                        var xBusinessDate = xUtils.dateTime.convertNumberToDate(businessDate, businessTime), xNewDate = xUtils.dateTime.getDateOfTheMonthAtDate(xBusinessDate);
                        if (stPrice.ymd = xUtils.dateTime.convertDateToNumber(xNewDate), stPrice.hms = businessTime, 
                        void 0 === stLastData || null == stLastData) return result.isAdd = !0, result.stPrice = stPrice, 
                        result;
                        var xLastDate = xUtils.dateTime.convertNumberToDate(stLastData.ymd, businessTime), xLastMonthDate = xUtils.dateTime.getDateOfTheMonthAtDate(xLastDate), diff = xUtils.dateTime.dateDiff(xLastMonthDate, xNewDate, "month", !0);
                        return diff < 0 ? (result.valid = !1, result) : (result.stPrice = stPrice, diff > 0 && (result.isAdd = !0), 
                        result);
                    }
                    if (timeType === xUtils.constants.timeType.day) {
                        var xBusinessDate = xUtils.dateTime.convertNumberToDate(businessDate, businessTime), xNewDate = xBusinessDate;
                        if (stPrice.ymd = businessDate, stPrice.hms = businessTime, void 0 === stLastData || null == stLastData) return result.isAdd = !0, 
                        result.stPrice = stPrice, result;
                        var xLastDate = xUtils.dateTime.convertNumberToDate(stLastData.ymd), diff = xUtils.dateTime.dateDiff(xLastDate, xNewDate, "day", !0);
                        return diff < 0 ? (result.valid = !1, result) : (result.stPrice = stPrice, diff > 0 && (result.isAdd = !0), 
                        result);
                    }
                    if (result.compare > 0) return result.valid = !1, result.reason = "received data is over date.", 
                    result;
                    var newTimeZoneNo = _didFindTimezoneNoWithDatetimeUnit(newDatetimeUnit);
                    if (void 0 === newTimeZoneNo || null == newTimeZoneNo) return result.valid = !1, 
                    result;
                    var newTimeZone = _self.m_xTimezoneInfo.timeZones[newTimeZoneNo], adjustedDatetimeUnit = xUtils.timeZone.didAdjustDatetimeUnitAsTimezone(newDatetimeUnit, newTimeZone, timeType, timeGap), adjustedDatetime = xUtils.timeZone.convertTimeunitToDatetime(adjustedDatetimeUnit);
                    if (stPrice.ymd = adjustedDatetime.date, stPrice.hms = adjustedDatetime.time, void 0 === stLastData || null == stLastData) return result.isAdd = !0, 
                    result.stPrice = stPrice, result;
                    var lastTimeZone, lastDatetimeUnit = xUtils.timeZone.convertDatetimeToTimeunit(stLastData.ymd, stLastData.hms), lastTimeZoneNo = _didFindTimezoneNoWithDatetimeUnit(lastDatetimeUnit), isValidLastTimeZone = !1;
                    if (void 0 !== lastTimeZoneNo && null != lastTimeZoneNo && (isValidLastTimeZone = !0, 
                    lastTimeZone = _self.m_xTimezoneInfo.timeZones[lastTimeZoneNo], _didCheckSameTimeunit(lastDatetimeUnit, adjustedDatetimeUnit, lastTimeZone, timeType, timeGap))) return result.isAdd = !1, 
                    result.stPrice = stPrice, result;
                    result.isAdd = !0;
                    for (var fromDatetimeUnit, toDatetimeUnit, bAll = (_self.m_xTimezoneInfo.timeZones.length, 
                    !1), extraFlag = !1, lastClose = stLastData.close, ii = 0; ii < newTimeZoneNo; ii++) {
                        fromDatetimeUnit = null, toDatetimeUnit = null, extraFlag = !1;
                        var timeZone = _self.m_xTimezoneInfo.timeZones[ii];
                        if (void 0 !== timeZone && null != timeZone && !0 === timeZone.use && (!0 !== bAll ? (void 0 !== lastTimeZoneNo && null != lastTimeZoneNo || (lastTimeZoneNo = ii, 
                        lastTimeZone = _self.m_xTimezoneInfo.timeZones[lastTimeZoneNo], lastDatetimeUnit = lastTimeZone.unit.begin), 
                        ii === lastTimeZoneNo && (bAll = !0, fromDatetimeUnit = lastDatetimeUnit, toDatetimeUnit = timeZone.unit.final, 
                        !0 === isValidLastTimeZone && (extraFlag = !0))) : (fromDatetimeUnit = timeZone.unit.begin, 
                        toDatetimeUnit = timeZone.unit.final), null != fromDatetimeUnit && null != toDatetimeUnit)) {
                            var emptyDatas = _didMakeEmptyDatas(lastClose, fromDatetimeUnit, toDatetimeUnit, timeType, timeGap, extraFlag, !0);
                            xUtils.didAppendDatas(result.priceDatas, emptyDatas);
                        }
                    }
                    if (extraFlag = !1, newTimeZoneNo === lastTimeZoneNo ? (fromDatetimeUnit = lastDatetimeUnit, 
                    !0 === isValidLastTimeZone && (extraFlag = !0)) : fromDatetimeUnit = newTimeZone.unit.begin, 
                    toDatetimeUnit = adjustedDatetimeUnit, null != fromDatetimeUnit && null != toDatetimeUnit) {
                        var emptyDatas = _didMakeEmptyDatas(lastClose, fromDatetimeUnit, toDatetimeUnit, timeType, timeGap, extraFlag);
                        xUtils.didAppendDatas(result.priceDatas, emptyDatas);
                    }
                    return result.stPrice = stPrice, result;
                }, this.didMakeCloseDateData = function(timeType, timeGap) {
                    var result = {
                        valid: !0,
                        priceDatas: [],
                        isAdd: !1,
                        stPrice: null,
                        compare: 0,
                        isTickUp: !1,
                        reason: ""
                    }, stLastData = _self.m_xOwner.didGetLastData();
                    if (void 0 === stLastData || null == stLastData) return result.valid = !1, result.reason = "there is no price datas.", 
                    result;
                    if (timeType != xUtils.constants.timeType.minute && timeType != xUtils.constants.timeType.hour) return result.valid = !1, 
                    result.reason = "only for minute or hour!!!", result;
                    var lastDatetimeUnit = xUtils.timeZone.convertDatetimeToTimeunit(stLastData.ymd, stLastData.hms), lastTimeZoneNo = _didFindTimezoneNoWithDatetimeUnit(lastDatetimeUnit);
                    result.isAdd = !0;
                    for (var fromDatetimeUnit, toDatetimeUnit, nTimezoneCount = _self.m_xTimezoneInfo.timeZones.length, extraFlag = !1, lastClose = stLastData.close, ii = lastTimeZoneNo; ii < nTimezoneCount; ii++) {
                        fromDatetimeUnit = null, toDatetimeUnit = null, extraFlag = !1;
                        var timeZone = _self.m_xTimezoneInfo.timeZones[ii];
                        if (void 0 !== timeZone && null != timeZone && !0 === timeZone.use && (fromDatetimeUnit = timeZone.unit.begin, 
                        toDatetimeUnit = timeZone.unit.final, fromDatetimeUnit < lastDatetimeUnit && lastDatetimeUnit < toDatetimeUnit && (fromDatetimeUnit = lastDatetimeUnit, 
                        extraFlag = !0), null != fromDatetimeUnit && null != toDatetimeUnit)) {
                            var emptyDatas = _didMakeEmptyDatas(lastClose, fromDatetimeUnit, toDatetimeUnit, timeType, timeGap, extraFlag, !0);
                            xUtils.didAppendDatas(result.priceDatas, emptyDatas);
                        }
                    }
                    try {
                        var nPriceDataCount = result.priceDatas.length;
                        if (nPriceDataCount > 0) {
                            var lastDatas = result.priceDatas.splice(nPriceDataCount - 1, 1);
                            result.stPrice = lastDatas[0];
                        } else result.valid = !1, result.reason = "there is no data to add.";
                    } catch (e) {}
                    return result;
                };
                var _didCheckSameTimeunit = function(lastDatetimeUnit, newDatetimeUnit, timeZone, timeType, timeGap) {
                    if (timeType !== xUtils.constants.timeType.hour && timeType !== xUtils.constants.timeType.minute) return !0;
                    var timeGapForTimezoneUnit = xUtils.timeZone.didGetTimeGapForTimezoneUnitAs(timeType, timeGap), beginTimeunit = lastDatetimeUnit, limitTimeunit = lastDatetimeUnit + timeGapForTimezoneUnit;
                    return limitTimeunit > timeZone.unit.final && (limitTimeunit = timeZone.unit.limit), 
                    beginTimeunit <= newDatetimeUnit && newDatetimeUnit < limitTimeunit;
                }, _didMakeEmptyDatas = function(closePrice, fromDatetimeUnit, toDatetimeUnit, timeType, timeGap, extraFlag, useEqualAlso) {
                    if (timeType === xUtils.constants.timeType.hour || timeType === xUtils.constants.timeType.minute) {
                        var results = [], timeGapForTimezoneUnit = xUtils.timeZone.didGetTimeGapForTimezoneUnitAs(timeType, timeGap), fromTu = fromDatetimeUnit, toTu = toDatetimeUnit;
                        if (!0 === extraFlag && (fromTu += timeGapForTimezoneUnit), !0 === useEqualAlso) for (var curTu = fromTu; curTu <= toTu; curTu += timeGapForTimezoneUnit) {
                            var stPrice = xUtils.dataConverter.didMakeEmptyPriceData(curTu, closePrice);
                            results.push(stPrice);
                        } else for (var curTu = fromTu; curTu < toTu; curTu += timeGapForTimezoneUnit) {
                            var stPrice = xUtils.dataConverter.didMakeEmptyPriceData(curTu, closePrice);
                            results.push(stPrice);
                        }
                        return results;
                    }
                };
                this.isBusinessDateChanged = function(businessDate) {
                    return void 0 !== businessDate && null != businessDate && (void 0 === _self.m_xTimezoneInfo.businessDate || null == _self.m_xTimezoneInfo.businessDate || (_self.m_xTimezoneInfo.businessDate < businessDate || (_self.m_xTimezoneInfo.businessDate, 
                    !1)));
                }, this.didDestroy = function() {};
            }, CDataHandlerUnit = function(multiTargetId) {
                var _self = this;
                this.m_nMultiTargetId = multiTargetId, this.m_xOwner = null, this.m_xTimeManager = null, 
                this.m_requestInfo = xUtils.dataConverter.didGetDefaultRequestInfo(), this.didInitDataHandlerUnit = function(owner, timeManager) {
                    _self.m_xOwner = owner, _self.m_xTimeManager = new CTimeManager(), _self.m_xTimeManager.didInitTimeManager(_self);
                };
                var _didProcessRealData = function(stPrice) {
                    var newDate = stPrice.ymd, newTime = stPrice.hms, dateTimeUnit = xUtils.timeZone.convertDatetimeToTimeunit(newDate, newTime), lastDatetimeUnit = _self.m_xOwner.didGetLastDatetimeUnit();
                    if (!(void 0 !== lastDatetimeUnit && null != lastDatetimeUnit && dateTimeUnit < lastDatetimeUnit)) {
                        var timeType = _self.m_requestInfo.nTType, timeGap = _self.m_requestInfo.nTGap, tickCount = _self.m_requestInfo.nTickCount, result = _self.m_xTimeManager.didMarkingTimezoneWithDatetime(timeType, timeGap, stPrice, tickCount);
                        if (!0 === result.valid) return result.isAdd ? _self.m_requestInfo.nTickCount = 1 : !0 === result.isTickUp && _self.m_requestInfo.nTickCount++, 
                        result;
                    }
                }, _didConvertCandleStickDataToReadablePriceData = function(receiveRawData, tickNo) {
                    var stPrice = xUtils.dataConverter.didConvertCandleStickData(receiveRawData);
                    if (void 0 !== stPrice && null != stPrice) return stPrice.tno = "number" == typeof tickNo ? tickNo : 0, 
                    stPrice;
                }, _didConvertTickDataToReadablePriceData = function(receiveRawData) {
                    var stPrice = xUtils.dataConverter.didConvertTickData(receiveRawData);
                    if (void 0 !== stPrice && null != stPrice) return stPrice.ymd < xUtils.constants.ngc.define.NGC_JUL_DATESTART && (stPrice.ymd = 20100719), 
                    stPrice;
                }, _didConvertSerialPriceDataToReadablePriceData = function(receiveRawData, tickNo) {
                    var stPrice = xUtils.dataConverter.didConvertSerialData(receiveRawData);
                    if (void 0 !== stPrice && null != stPrice) return stPrice;
                }, _didGetBusinessTime = function() {
                    try {
                        return _self.m_xTimeManager.m_xTimezoneInfo.businessTime;
                    } catch (e) {
                        console.error(e);
                    }
                    return 9e4;
                }, _didConvertSerialPriceDatasToReadablePriceDatas = function(receiveRawDatas, isTick, isDwm) {
                    for (var arrRecvDatas = [], arrRecvTimes = [], arrRecvTnos = [], nRecvCount = receiveRawDatas.length, businessTime = _didGetBusinessTime(), __ii = 0; __ii < nRecvCount; __ii++) {
                        var __stRawPrice = receiveRawDatas[__ii], __stPrice = _didConvertSerialPriceDataToReadablePriceData(__stRawPrice);
                        if (void 0 !== __stPrice && null != __stPrice) {
                            var __time, __date = xUtils.dateTime.convertNumberToDateString(__stPrice.ymd);
                            __time = !0 === isDwm ? xUtils.dateTime.convertNumberToTimeString(businessTime) : xUtils.dateTime.convertNumberToTimeString(__stPrice.hms);
                            var __tno = 0, __strTimeVal = __date + __time;
                            if (arrRecvTimes.push(__strTimeVal), !0 === isTick && __ii > 0) {
                                var preIdx = __ii - 1, __strPreTimeVal = arrRecvTimes[preIdx], __pretno = arrRecvTnos[preIdx];
                                parseInt(__strPreTimeVal) === parseInt(__strTimeVal) && (__tno = __pretno + 1);
                            }
                            arrRecvTnos.push(__tno), __stPrice.tno = __tno, arrRecvDatas.push(__stPrice);
                        }
                    }
                    return {
                        datas: arrRecvDatas,
                        times: arrRecvTimes,
                        tnos: arrRecvTnos
                    };
                };
                this.OnReceiveData = function(receiveRawDatas, requestInfo, timeZoneInfo) {
                    var multiTargetId = _self.m_nMultiTargetId, requestInfo = _self.m_requestInfo = xUtils.didClone(requestInfo), timeType = requestInfo.nTType, timeGap = requestInfo.nTGap;
                    _self.m_xTimeManager.didClearAndMakeTimeTable(timeType, timeGap, _self.m_requestInfo.requestCode, null, timeZoneInfo);
                    var checkTimeType = xUtils.timeZone.didCheckTimeType(timeType), isTick = checkTimeType.isTick, isDwm = checkTimeType.isDwm, receiveDatas = _self.m_receiveDatas = _didConvertSerialPriceDatasToReadablePriceDatas(receiveRawDatas, isTick, isDwm);
                    _self.m_requestInfo.nTType = timeType, _self.m_requestInfo.nTGap = timeGap;
                    var chartWrap = _self.m_xOwner.didGetChartWrap();
                    return void 0 !== chartWrap && null != chartWrap && (chartWrap.willBeReceivedData(requestInfo, receiveDatas, void 0, multiTargetId), 
                    chartWrap.didReceiveData(requestInfo, receiveDatas, void 0, multiTargetId), chartWrap.DrawingChartDrawFrame(!1), 
                    !0);
                };
                var _didConcatForReceiveDatas = function(oldDatas, newDatas) {
                    if (oldDatas && newDatas) try {
                        return {
                            datas: oldDatas.datas.concat(newDatas.datas),
                            times: oldDatas.times.concat(newDatas.times),
                            tnos: oldDatas.tnos.concat(newDatas.tnos)
                        };
                    } catch (e) {
                        console.error(e);
                    }
                };
                this.OnReceiveNextData = function(receiveRawDatas) {
                    var requestInfo = _self.m_requestInfo, timeType = requestInfo.nTType, checkTimeType = (requestInfo.nTGap, 
                    xUtils.timeZone.didCheckTimeType(timeType)), isTick = checkTimeType.isTick, isDwm = checkTimeType.isDwm, newReceiveDatas = _didConvertSerialPriceDatasToReadablePriceDatas(receiveRawDatas, isTick, isDwm), oldReceiveDatas = _self.m_receiveDatas, nextCount = newReceiveDatas.datas.length, receiveDatas = _self.m_receiveDatas = _didConcatForReceiveDatas(newReceiveDatas, oldReceiveDatas), chartWrap = _self.m_xOwner.didGetChartWrap();
                    return void 0 !== chartWrap && null != chartWrap && (chartWrap.willBeReceivedData(requestInfo, receiveDatas, nextCount), 
                    chartWrap.didReceiveData(requestInfo, receiveDatas, nextCount), chartWrap.DrawingChartDrawFrame(!1), 
                    !0);
                }, this.OnReceiveOrderData = function(receiveDatas) {
                    for (var orderDatas = [], nRecvCount = receiveDatas.length, ii = 0; ii < nRecvCount; ii++) {
                        var orderData, recvData = receiveDatas[ii];
                        try {
                            orderData = !0 === recvData.isKv ? xUtils.didClone(recvData) : {
                                ask: recvData[0],
                                buysell: recvData[1],
                                price: recvData[2].replace(".", ""),
                                volume: recvData[3],
                                dateTime: recvData[4],
                                cancelableFlag: recvData[5],
                                correctableFlag: recvData[6],
                                id: recvData[7],
                                someFlag: recvData[8],
                                toolTipText: recvData[9],
                                extraPrice: recvData[10],
                                orderJointId: recvData[11]
                            }, orderDatas.push(orderData);
                        } catch (e) {
                            console.error(e);
                        }
                    }
                    var chartWrap = _self.m_xOwner.didGetChartWrap();
                    return void 0 !== chartWrap && null != chartWrap && (chartWrap.willBeReceivedOrderPositData(!0, orderDatas), 
                    chartWrap.didReceiveOrderPositData(!0, orderDatas), chartWrap.DrawingChartDrawFrame(!1), 
                    !0);
                }, this.OnReceivePositData = function(receiveDatas) {
                    for (var positDatas = [], nRecvCount = receiveDatas.length, ii = 0; ii < nRecvCount; ii++) {
                        var positData, recvData = receiveDatas[ii];
                        try {
                            positData = !0 === recvData.isKv ? xUtils.didClone(recvData) : {
                                ask: recvData[0],
                                buysell: recvData[1],
                                price: parseInt(recvData[2].replace(".", "")),
                                volume: recvData[3],
                                dateTime: recvData[4],
                                checkSettlementFlag: recvData[5],
                                id: recvData[6],
                                toolTipText: recvData[7]
                            }, positDatas.push(positData);
                        } catch (e) {
                            console.error(e);
                        }
                    }
                    var chartWrap = _self.m_xOwner.didGetChartWrap();
                    return void 0 !== chartWrap && null != chartWrap && (chartWrap.willBeReceivedOrderPositData(!1, positDatas), 
                    chartWrap.didReceiveOrderPositData(!1, positDatas), chartWrap.DrawingChartDrawFrame(!1), 
                    !0);
                }, this.OnReceiveAlertData = function(receiveDatas) {
                    for (var alertDatas = [], nRecvCount = receiveDatas.length, ii = 0; ii < nRecvCount; ii++) {
                        var alertData, recvData = receiveDatas[ii];
                        try {
                            alertData = !0 === recvData.isKv ? xUtils.didClone(recvData) : {
                                ask: recvData[0],
                                title: recvData[1],
                                price: recvData[2].replace(".", ""),
                                dateTime: recvData[3],
                                availableFlag: recvData[4],
                                id: recvData[5],
                                toolTipText: recvData[6]
                            }, alertDatas.push(alertData);
                        } catch (e) {
                            console.error(e);
                        }
                    }
                    var chartWrap = _self.m_xOwner.didGetChartWrap();
                    return void 0 !== chartWrap && null != chartWrap && (chartWrap.willBeReceivedAlertExecutionData(!0, alertDatas), 
                    chartWrap.didReceiveAlertExecutionData(!0, alertDatas), chartWrap.DrawingChartDrawFrame(!1), 
                    !0);
                }, this.OnReceiveExecutionData = function(receiveDatas) {
                    for (var executionDatas = [], nRecvCount = receiveDatas.length, ii = 0; ii < nRecvCount; ii++) {
                        var executionData, recvData = receiveDatas[ii];
                        try {
                            executionData = !0 === recvData.isKv ? xUtils.didClone(recvData) : {
                                ask: recvData[0],
                                buysell: recvData[1],
                                price: parseInt(recvData[2].replace(".", "")),
                                volume: recvData[3],
                                dateTime: recvData[4],
                                availableFlag: recvData[5],
                                id: recvData[6],
                                toolTipText: recvData[7]
                            }, executionDatas.push(executionData);
                        } catch (e) {
                            console.error(e);
                        }
                    }
                    var chartWrap = _self.m_xOwner.didGetChartWrap();
                    return void 0 !== chartWrap && null != chartWrap && (chartWrap.willBeReceivedAlertExecutionData(!1, executionDatas), 
                    chartWrap.didReceiveAlertExecutionData(!1, executionDatas), chartWrap.DrawingChartDrawFrame(!1), 
                    !0);
                }, this.OnReceiveRealData = function(receiveData, bDraw) {
                    var multiTargetId = _self.m_nMultiTargetId, chartWrap = _self.m_xOwner.didGetChartWrap();
                    return void 0 !== chartWrap && null != chartWrap && (chartWrap.willBeReceivedRealData(receiveData, multiTargetId), 
                    chartWrap.didReceiveRealData(receiveData, multiTargetId), !0 === bDraw && chartWrap.DrawingChartDrawFrame(!1), 
                    !0);
                }, this.OnReceiveRealDatas = function(receiveDatas) {
                    var chartWrap = _self.m_xOwner.didGetChartWrap();
                    if (void 0 === chartWrap || null == chartWrap || !chartWrap.DrawingChartDrawFrame) return !1;
                    if (void 0 === receiveDatas || null == receiveDatas) return !1;
                    var nCount = receiveDatas.length;
                    if (void 0 === nCount || null == nCount || nCount < 1) return !1;
                    for (var failCount = 0, ii = 0; ii < nCount; ii++) try {
                        var stPrice = receiveDatas[ii], receiveData = _didProcessRealData(stPrice);
                        if (void 0 === receiveData || null == receiveData) {
                            failCount++;
                            continue;
                        }
                        if (!0 !== receiveData.valid) {
                            failCount++;
                            continue;
                        }
                        _self.OnReceiveRealData(receiveData);
                    } catch (e) {
                        console.error(e), failCount++;
                    }
                    return chartWrap.DrawingChartDrawFrame(!1), !0;
                }, this.OnReceiveRealDataAsCandleStick = function(receiveRawData) {
                    var stPrice = _didConvertCandleStickDataToReadablePriceData(receiveRawData), receiveData = _didProcessRealData(stPrice);
                    if (void 0 !== receiveData && null != receiveData && !0 === receiveData.valid) {
                        var chartWrap = _self.m_xOwner.didGetChartWrap();
                        return void 0 !== chartWrap && null != chartWrap && (chartWrap.willBeReceivedRealData(receiveData), 
                        chartWrap.didReceiveRealData(receiveData), chartWrap.DrawingChartDrawFrame(!1), 
                        !0);
                    }
                }, this.OnReceiveRealDataAsTick = function(receiveRawData) {
                    var stPrice = _didConvertTickDataToReadablePriceData(receiveRawData), receiveData = _didProcessRealData(stPrice);
                    if (void 0 !== receiveData && null != receiveData) {
                        var chartWrap = _self.m_xOwner.didGetChartWrap();
                        return void 0 !== chartWrap && null != chartWrap && (chartWrap.willBeReceivedRealData(receiveData), 
                        chartWrap.didReceiveRealData(receiveData), chartWrap.DrawingChartDrawFrame(!1), 
                        !0);
                    }
                }, this.OnReceiveBusinessDate = function(businessDate, bDraw, timeZoneInfo) {
                    if (void 0 !== businessDate && null != businessDate && _self.m_xTimeManager) {
                        var xResult, requestInfo = _self.m_requestInfo, timeType = requestInfo.nTType, timeGap = requestInfo.nTGap;
                        if (timeType != xUtils.constants.timeType.minute && timeType != xUtils.constants.timeType.hour || (xResult = _self.m_xTimeManager.didMakeCloseDateData(timeType, timeGap)), 
                        _self.m_xTimeManager.didClearAndMakeTimeTable(timeType, timeGap, requestInfo.requestCode, businessDate, timeZoneInfo), 
                        (timeType == xUtils.constants.timeType.minute || timeType == xUtils.constants.timeType.hour) && xResult && 1 == xResult.valid) {
                            var receiveData = xResult;
                            _self.OnReceiveRealData(receiveData);
                        }
                        if (1 == bDraw) {
                            var chartWrap = _self.m_xOwner.didGetChartWrap();
                            chartWrap && chartWrap.DrawingChartDrawFrame && chartWrap.DrawingChartDrawFrame(!1);
                        }
                    }
                }, this.didGetLastData = function() {
                    if (void 0 !== _self.m_xOwner && null != _self.m_xOwner) return _self.m_xOwner.didGetLastData(_self.m_nMultiTargetId);
                }, this.didGetLastDatetimeUnit = function() {
                    if (void 0 !== _self.m_xOwner && null != _self.m_xOwner) return _self.m_xOwner.didGetLastDatetimeUnit(_self.m_nMultiTargetId);
                }, this.didDestroy = function() {
                    _self.m_xTimeManager && (_self.m_xTimeManager.didDestroy(), delete _self.m_xTimeManager, 
                    _self.m_xTimeManager = null);
                };
            }, CDataHandler = function() {
                var _self = this;
                this.m_xOwner = null, this.m_xHandlerUnit = null, this.m_xTimeManager = null, this.didInitDataHandler = function(owner) {
                    _self.m_xOwner = owner, _self.m_xHandlerUnit = new CDataHandlerUnit(), _self.m_xTimeManager = new CTimeManager(), 
                    _self.m_xHandlerUnit.didInitDataHandlerUnit(_self, _self.m_xTimeManager), _self.m_xTimeManager.didInitTimeManager(_self);
                }, this.didGetLastData = function(id) {
                    if (void 0 !== _self.m_xOwner && null != _self.m_xOwner) return _self.m_xOwner.didGetLastData(id);
                }, this.didGetLastDatetimeUnit = function(id) {
                    if (void 0 !== _self.m_xOwner && null != _self.m_xOwner) return _self.m_xOwner.didGetLastDatetimeUnit(id);
                }, this.didDestroy = function() {
                    delete _self.m_xHandlerUnit, delete _self.m_xTimeManager, _self.m_xHandlerUnit = null, 
                    _self.m_xTimeManager = null;
                }, this.OnReceiveData = function(receiveRawDatas, requestInfo, timeZoneInfo) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceiveData(receiveRawDatas, requestInfo, timeZoneInfo);
                }, this.OnReceiveNextData = function(receiveRawDatas) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceiveNextData(receiveRawDatas);
                }, this.OnReceiveOrderData = function(receiveDatas) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceiveOrderData(receiveDatas);
                }, this.OnReceivePositData = function(receiveDatas) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceivePositData(receiveDatas);
                }, this.OnReceiveAlertData = function(receiveDatas) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceiveAlertData(receiveDatas);
                }, this.OnReceiveExecutionData = function(receiveDatas) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceiveExecutionData(receiveDatas);
                }, this.OnReceiveRealData = function(receiveData) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceiveRealData(receiveData);
                }, this.OnReceiveRealDatas = function(receiveDatas) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceiveRealDatas(receiveDatas);
                }, this.OnReceiveRealDataAsCandleStick = function(receiveRawData) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceiveRealDataAsCandleStick(receiveRawData);
                }, this.OnReceiveRealDataAsTick = function(receiveRawData) {
                    if (void 0 !== _self.m_xHandlerUnit && null != _self.m_xHandlerUnit) return _self.m_xHandlerUnit.OnReceiveRealDataAsTick(receiveRawData);
                }, this.didGetChartWrap = function() {
                    if (void 0 !== _self.m_xOwner && null != _self.m_xOwner) return _self.m_xOwner.m_chartWrap;
                }, this.didClearDatas = function() {};
            }, CDataHandlerEx = function() {
                var _self = this;
                this.m_xOwner = null, this.m_nUnitId = 0, this.m_xHandlerUnits = {}, this.didCreateDataHandlerUnit = function(id) {
                    void 0 !== id && null != id || (id = 0);
                    var xHandlerUnit = new CDataHandlerUnit(id);
                    return xHandlerUnit.didInitDataHandlerUnit(_self), _self.m_xHandlerUnits[id] = xHandlerUnit, 
                    xHandlerUnit;
                }, this.didInitDataHandler = function(owner) {
                    _self.m_xOwner = owner;
                }, this.didGetLastData = function(id) {
                    if (void 0 !== _self.m_xOwner && null != _self.m_xOwner) return _self.m_xOwner.didGetLastData(id);
                }, this.didGetLastDatetimeUnit = function(id) {
                    if (void 0 !== _self.m_xOwner && null != _self.m_xOwner) return _self.m_xOwner.didGetLastDatetimeUnit(id);
                }, this.didDestroy = function() {
                    _self.didClearDatas();
                }, this.didGetDataHandlerUnit = function(id) {
                    id = id || 0;
                    var xHandlerUnit = _self.m_xHandlerUnits[id];
                    return void 0 !== xHandlerUnit && null != xHandlerUnit || (xHandlerUnit = _self.didCreateDataHandlerUnit(id)), 
                    xHandlerUnit;
                }, this.OnReceiveData = function(receiveRawDatas, requestInfo, timeZoneInfo, multiTargetId) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit(multiTargetId);
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveData(receiveRawDatas, requestInfo, timeZoneInfo);
                }, this.OnReceiveNextData = function(receiveRawDatas) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit();
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveNextData(receiveRawDatas);
                }, this.OnReceiveOrderData = function(receiveDatas) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit();
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveOrderData(receiveDatas);
                }, this.OnReceivePositData = function(receiveDatas) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit();
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceivePositData(receiveDatas);
                }, this.OnReceiveAlertData = function(receiveDatas) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit();
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveAlertData(receiveDatas);
                }, this.OnReceiveExecutionData = function(receiveDatas) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit();
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveExecutionData(receiveDatas);
                }, this.OnReceiveRealData = function(receiveData, multiTargetId) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit(multiTargetId);
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveRealData(receiveData);
                }, this.OnReceiveRealDatas = function(receiveDatas, multiTargetId) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit(multiTargetId);
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveRealDatas(receiveDatas);
                }, this.OnReceiveRealDataAsCandleStick = function(receiveRawData) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit();
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveRealDataAsCandleStick(receiveRawData);
                }, this.OnReceiveRealDataAsTick = function(receiveRawData) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit();
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveRealDataAsTick(receiveRawData);
                }, this.OnReceiveBusinessDate = function(businessDate, bDraw, timeZoneInfo) {
                    var xHandlerUnit = _self.didGetDataHandlerUnit();
                    if (void 0 !== xHandlerUnit && null != xHandlerUnit) return xHandlerUnit.OnReceiveBusinessDate(businessDate, bDraw, timeZoneInfo);
                }, this.didGetChartWrap = function() {
                    if (void 0 !== _self.m_xOwner && null != _self.m_xOwner) return _self.m_xOwner.m_chartWrap;
                }, this.didClearDatas = function() {
                    for (var keys = Object.keys(_self.m_xHandlerUnits), nCount = keys.length, ii = 0; ii < nCount; ii++) {
                        var key = keys[ii];
                        _self.m_xHandlerUnits[key].didDestroy(), delete _self.m_xHandlerUnits[ii];
                    }
                    _self.m_xHandlerUnits = {};
                };
            }, exports = {};
            return exports.didGetDataHandler = function(owner) {
                var xDataHandler = new CDataHandler();
                return xDataHandler.didInitDataHandler(owner), xDataHandler;
            }, exports.didGetDataHandlerEx = function(owner) {
                var xDataHandler = new CDataHandlerEx();
                return xDataHandler.didInitDataHandler(owner), xDataHandler;
            }, exports;
        };
        global.WGC_CHART ? global.WGC_CHART.chartDataHandler = loadModule(global.WGC_CHART.chartUtil) : module.exports = loadModule(__webpack_require__(0));
    }(this);
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, parentClass, mouseCapture, zsScrollWrap) {
            return function(id) {
                var _self = this, _classRef = this, _uniqueId = xUtils.createGuid();
                this.prototype = new parentClass(), parentClass.apply(this, arguments), this.method = this.prototype.method, 
                this.method.superior = {}, this.method.classObj = this, this.method.className = "ScreenPanel", 
                this.method.id = id, this.method.mouseCapture = new mouseCapture();
                for (var m in this.prototype.method) $.isFunction(this.prototype.method[m]) && (this.method.superior[m] = this.prototype.method[m]);
                this.m_eventTables = [], this.m_hammer, this.method.m_zsWrap = null, this.m_nWrapWidth = 0, 
                this.m_nWrapHeight = 0, this.m_initParam, this.m_xSettings = {
                    THUMB_SIZING_BUTTON_SIZE: 9,
                    THUMB_SIZING_BUTTON_RIGHT_MARGIN: 4,
                    THUMB_SIZING_BUTTON_LEFT_MARGIN: 4,
                    THUMB_SIZING_BUTTON_HEIGHT: 64,
                    STEP_BUTTON_SIZE: 24,
                    STEP_PRESSING_TIME: 300
                }, this.m_rectInfo = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }, this.m_pScroll = null, this.m_pDelegate = null, this.m_toIdRepeatDown = -1, this.m_tiIdRepeatDown = -1, 
                this.m_nRepeatTime = 50, this.m_bMouseDown = !1, this.m_bStepButtonLDown = !1, this.m_bStepButtonRDown = !1, 
                this.m_ptMouse = {
                    x: -1,
                    y: -1
                };
                var _getTagetChildDOMElementById = function(scrobj, id) {
                    var jqElem = scrobj._$object.find("#" + id);
                    return $(jqElem).get(0);
                }, _findDomElementById = function(scrobj, id) {
                    var jqElem = scrobj._$object.find("#" + id);
                    return $(jqElem).get(0);
                }, _didCreateDomElem = function(id, className) {
                    var domElem = document.createElement("div");
                    return domElem.setAttributeNS(null, "id", id), domElem.className = className, domElem;
                }, _didCreateDomElemWithImage = function(id, className, imgId, imgClassName) {
                    var domElem = document.createElement("div");
                    domElem.setAttributeNS(null, "id", id), domElem.className = className;
                    var domElemImage = document.createElement("image");
                    return domElemImage.setAttributeNS(null, "id", imgId), domElemImage.className = imgClassName, 
                    domElem.appendChild(domElemImage), domElem;
                }, _didCreateDomElemButtonWithImage = function(id, className, imgId, imgClassName) {
                    var domElem = document.createElement("button");
                    domElem.setAttributeNS(null, "id", id), domElem.className = className + " btn btn-default";
                    var domElemImage = document.createElement("image");
                    return domElemImage.setAttributeNS(null, "id", imgId), domElemImage.className = imgClassName, 
                    domElem.appendChild(domElemImage), domElem;
                }, _didCreateDomElemCanvas = function(id, className) {
                    var domElem = document.createElement("canvas");
                    return domElem.setAttributeNS(null, "id", id), domElem.className = className, domElem;
                }, _didCreateDomElemThumbBar = function(domElemPar, initParam) {
                    var domElemThumbBar = _didCreateDomElem("eidZsThumbArea", "classZsArea"), domElemThumbMid = _didCreateDomElem("eidZsThumbBarM", "classZsThumbMove"), domElemThumbLeft = _didCreateDomElemWithImage("eidZsThumbBarL", "classZsThumbSize", "eidZsThumbBarImgL", "classZsThmubSizeImage"), domElemThumbRight = _didCreateDomElemWithImage("eidZsThumbBarR", "classZsThumbSize", "eidZsThumbBarImgR", "classZsThmubSizeImage");
                    return domElemThumbBar.appendChild(domElemThumbMid), domElemThumbBar.appendChild(domElemThumbLeft), 
                    domElemThumbBar.appendChild(domElemThumbRight), domElemPar && domElemPar.appendChild(domElemThumbBar), 
                    initParam = initParam || _self.m_initParam, initParam.thumbBar = domElemThumbBar, 
                    initParam.thumbBarL = domElemThumbLeft, initParam.thumbBarM = domElemThumbMid, initParam.thumbBarR = domElemThumbRight, 
                    domElemThumbBar;
                }, _didCreateDomElemScrollArea = function(domElemPar, initParam) {
                    var domElemScrollArea = _didCreateDomElem("eidZsScrollArea", "classZsScrollArea"), domElemThumbBar = _didCreateDomElemThumbBar(domElemScrollArea, _self.m_initParam), domElemScrollBgArea = _didCreateDomElemCanvas("eidZsBackground", "classZsScrollBackground");
                    return domElemScrollArea.appendChild(domElemScrollBgArea), domElemScrollArea.appendChild(domElemThumbBar), 
                    domElemPar && domElemPar.appendChild(domElemScrollArea), initParam = initParam || _self.m_initParam, 
                    initParam.scrollArea = domElemScrollArea, initParam.scrollBgArea = domElemScrollBgArea, 
                    domElemScrollArea;
                }, _didCreateDomElemActionArea = function(domElemPar, initParam, isLeft) {
                    var mark = !0 === isLeft ? "L" : "R", elemId = "eidZsActionArea" + mark, buttonId = "eidZsActionButton" + mark, imgElemId = !0 === isLeft ? "eidZsActionButtonLeftImage" : "eidZsActionButtonRightImage", imgclassName = !0 === isLeft ? "classZsActionButtonLeftImage" : "classZsActionButtonRightImage", domElemActionArea = _didCreateDomElem(elemId, "classZsActionArea"), domElemActionButton = _didCreateDomElemButtonWithImage(buttonId, "classZsActionButton", imgElemId, imgclassName);
                    return domElemActionArea.appendChild(domElemActionButton), domElemPar && domElemPar.appendChild(domElemActionArea), 
                    initParam = initParam || _self.m_initParam, !0 === isLeft ? (initParam.actionAreaL = domElemActionArea, 
                    initParam.actionButtonL = domElemActionButton) : (initParam.actionAreaR = domElemActionArea, 
                    initParam.actionButtonR = domElemActionButton), domElemActionArea;
                }, _didInitChildElements = function(initParam) {
                    _self.m_initParam = initParam;
                    var __deParent = _self.m_initParam.parent;
                    _self.m_initParam.no;
                    _didCreateDomElemActionArea(__deParent, _self.m_initParam, !0), _didCreateDomElemActionArea(__deParent, _self.m_initParam, !1), 
                    _didCreateDomElemScrollArea(__deParent, _self.m_initParam);
                }, _didRemoveLinkElements = function() {
                    if (void 0 !== _self.m_initParam && null != _self.m_initParam) {
                        var __deParent = _self.m_initParam.parent, __actionAreaL = _self.m_initParam.actionAreaL, __actionAreaR = _self.m_initParam.actionAreaR, __scrollArea = _self.m_initParam.scrollArea;
                        __deParent.removeChild(__actionAreaL), __deParent.removeChild(__actionAreaR), __deParent.removeChild(__scrollArea), 
                        _self.m_initParam = {};
                    }
                }, _didGetAdjustedMouseEventPosition = function(event, capturedObj) {
                    var jidChartWrap;
                    jidChartWrap = void 0 !== capturedObj && null != capturedObj ? $(capturedObj).offset() : $(event.currentTarget).offset();
                    var scrollX = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft, scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop, posValueClient = {
                        XPos: event.clientX - jidChartWrap.left + scrollX,
                        YPos: event.clientY - jidChartWrap.top + scrollY
                    };
                    void 0 == event.offsetX ? event.layerX : event.offsetX, void 0 == event.offsetY ? event.layerY : event.offsetY;
                    return posValueClient;
                }, _didEventProcForDown = function(targetId, posval, argEvent, capturedObj, someObject) {
                    if (void 0 === targetId || null == targetId) return !0;
                    console.log("");
                    try {
                        return targetId.indexOf("eidZsActionButtonL") >= 0 ? (_self.m_bStepButtonLDown = !0, 
                        _didCheckRepeatTimeout(), !0) : targetId.indexOf("eidZsActionButtonR") >= 0 ? (_self.m_bStepButtonRDown = !0, 
                        _didCheckRepeatTimeout(), !0) : "eidZsThumbBarM" === targetId ? (_self.m_pScroll.ELBtnDn({
                            EVT_MOVING: !0
                        }, posval), !1) : "eidZsThumbBarL" === targetId || "eidZsThumbBarImgL" === targetId ? (_self.m_pScroll.ELBtnDn({
                            EVT_SIZING1: !0
                        }, posval), !1) : "eidZsThumbBarR" !== targetId && "eidZsThumbBarImgR" !== targetId || (_self.m_pScroll.ELBtnDn({
                            EVT_SIZING2: !0
                        }, posval), !1);
                    } catch (e) {
                        console.error(e);
                    }
                    return !0;
                }, _didEventProcForMove = function(targetId, posval, capturedObj, someObject) {
                    if (void 0 === targetId || null == targetId) return !0;
                    _self.m_bMouseDown && _self.m_pScroll.EMouseMove({}, posval) && _self.didUpdateScrollBar(!0);
                }, _didEventProcForUp = function(targetId, posval, argEvent, capturedObj, someObject) {
                    _self.m_pScroll.ELBtnUp({}, posval), _didEndMouseAction();
                }, _initDOMElements = function(jobjScreen) {
                    _self.m_jobjScreen = jobjScreen;
                    var domElemChartWrap = _findDomElementById(jobjScreen, "idZsWrap");
                    void 0 !== domElemChartWrap && null != domElemChartWrap && (domElemChartWrap.setAttributeNS(null, "tabindex", 1), 
                    _self.m_nWrapWidth = domElemChartWrap.offsetWidth, _self.m_nWrapHeight = domElemChartWrap.offsetHeight, 
                    _self.m_initParam = {
                        root: domElemChartWrap,
                        parent: domElemChartWrap
                    }, _didInitChildElements(_self.m_initParam));
                }, _didCreateZoomScroll = function(pDelegate) {
                    _self.m_pDelegate = pDelegate, _self.m_pScroll = new zsScrollWrap(_self, Math.ceil(2 * (_self.m_xSettings.THUMB_SIZING_BUTTON_SIZE + 1)));
                };
                this.didInitScreen = function(pDelegate, argSettings) {
                    argSettings && (_self.m_xSettings = xUtils.didClone(argSettings)), _didCreateZoomScroll(pDelegate), 
                    _initDOMElements(_self), _didInitEventTables(), _self.setEventHandler(), _self.DidCallAfterDoneWithOnLoad();
                }, this.didGetUniqueId = function() {
                    return _uniqueId;
                }, this.didStartCapture = function(eventElem) {
                    _self.method.mouseCapture.didStartCapture(eventElem, _self.OnMouseMove, _self.OnMouseUp);
                }, this.setEventHandler = function() {
                }, this.SetZSBInit = function(nShows, nContents, nShowsMin, nShowsMax, bDraw) {
                    var ret = _self.m_pScroll.SetContentsSize(nShows, nContents, nShowsMin, nShowsMax, bDraw);
                    return bDraw && _self.didUpdateScrollBar(!1), ret;
                }, this.SetZSBRange = function(nShows, nContents, bDraw) {
                    var ret = _self.m_pScroll.ChangeContentsSize(nShows, nContents);
                    return bDraw && _self.didUpdateScrollBar(!0), ret;
                }, this.SetZSBPos = function(nPos, bUpdate) {
                    return _self.m_pScroll.ChangeThumbPos(nPos);
                };
                var _Invalidate = function(onleDraw) {
                    _self.didUpdateScrollBar(onleDraw);
                }, _GetBackgroundContextInfo = function() {
                    var xZsnd = {};
                    return xZsnd.canvas = _self.m_initParam.scrollBgArea, xZsnd.context = _self.m_initParam.scrollBgArea.getContext("2d"), 
                    xZsnd.rcDraw = xUtils.didClone(_self.m_rectInfo.scrollBgDrawArea), xZsnd.margin = {
                        left: 1,
                        top: 1,
                        right: 1,
                        bottom: 1
                    }, xZsnd;
                }, _Draw = function() {
                    _didSetSizeToDomElem(_self.m_initParam.actionAreaL, _self.m_rectInfo.actionAreaLeft), 
                    _didSetSizeToDomElem(_self.m_initParam.actionButtonL, _self.m_rectInfo.actionAreaLeftButton), 
                    _didSetSizeToDomElem(_self.m_initParam.actionAreaR, _self.m_rectInfo.actionAreaRight), 
                    _didSetSizeToDomElem(_self.m_initParam.actionButtonR, _self.m_rectInfo.actionAreaRightButton), 
                    _didSetSizeToDomElem(_self.m_initParam.scrollArea, _self.m_rectInfo.scrollArea), 
                    _didSetSizeToDomElem(_self.m_initParam.scrollBgArea, _self.m_rectInfo.scrollBgArea), 
                    _didSetSizeToDomElem(_self.m_initParam.thumbBar, _self.m_rectInfo.thumbBar), _didSetSizeToDomElem(_self.m_initParam.thumbBarL, _self.m_rectInfo.thumbBarL), 
                    _didSetSizeToDomElem(_self.m_initParam.thumbBarR, _self.m_rectInfo.thumbBarR), _didSetSizeToDomElem(_self.m_initParam.thumbBarM, _self.m_rectInfo.thumbBarM), 
                    _didSetSizeToDomElemAsCanvas(_self.m_initParam.scrollBgArea, _self.m_rectInfo.scrollBgArea);
                    if (_self.m_pDelegate) {
                        var xZsnd = _GetBackgroundContextInfo();
                        _self.m_pDelegate.WillBeDrawnBackground(_self, xZsnd);
                    }
                }, _didSetSizeToDomElem = function(domElem, rectInfo) {
                    domElem.style.left = rectInfo.x + "px", domElem.style.top = rectInfo.y + "px", domElem.style.width = rectInfo.width + "px", 
                    domElem.style.height = rectInfo.height + "px";
                }, _didSetSizeToDomElemAsCanvas = function(domElem, rectInfo) {
                    var devicePixelRatio = window.devicePixelRatio || 1, ratio = devicePixelRatio, __width = rectInfo.width, __height = rectInfo.height;
                    domElem.width = ratio * __width, domElem.height = ratio * __height, domElem.style.left = rectInfo.x + "px", 
                    domElem.style.top = rectInfo.y + "px", domElem.style.width = rectInfo.width + "px", 
                    domElem.style.height = rectInfo.height + "px";
                };
                this.didUpdateScrollBar = function(onlyDraw, rectInfo) {
                    rectInfo ? _didCalcArea(onlyDraw, rectInfo) : _didCalcArea(onlyDraw, xUtils.didClone(_self.m_rcArea)), 
                    _self.m_pScroll.m_rectThumbB.width < 2 * _self.m_xSettings.THUMB_SIZING_BUTTON_SIZE ? (_self.m_rectInfo.thumbBarL.width = 0, 
                    _self.m_rectInfo.thumbBarR.width = 0, _self.m_initParam.thumbBarL.style.visibility = "hidden", 
                    _self.m_initParam.thumbBarR.style.visibility = "hidden") : (_self.m_initParam.thumbBarL.style.visibility = "visible", 
                    _self.m_initParam.thumbBarR.style.visibility = "visible"), _Draw();
                };
                var __calcMiddleWidth = function(width1, width2) {
                    return width1 - 2 * width2 + 2;
                }, _didCalcArea = function(onlyDraw, rectInfo) {
                    var __width = rectInfo.width, __height = rectInfo.height, __thumbSizeWidth = _self.m_xSettings.THUMB_SIZING_BUTTON_SIZE, __actionAreaWidth = _self.m_xSettings.STEP_BUTTON_SIZE, __thumbBarMarginLR = _self.m_xSettings.THUMB_SIZING_BUTTON_LEFT_MARGIN + _self.m_xSettings.THUMB_SIZING_BUTTON_RIGHT_MARGIN;
                    __width = Math.max(__actionAreaWidth, __width);
                    var __scrollAreaWidth = __calcMiddleWidth(__width, __actionAreaWidth), rectScroll = xUtils.didClone(rectInfo);
                    rectScroll.width = __scrollAreaWidth, !0 !== onlyDraw && _self.m_pScroll.SetArea(rectScroll);
                    var __thumbWidth = _self.m_pScroll.m_rectThumbB.width, __thumbPos = _self.m_pScroll.m_rectThumbB.x, __rect = xUtils.shapes.didGetDefaultRect();
                    __rect.height = __height, _self.m_rectInfo = {}, _self.m_rectInfo.actionAreaLeft = xUtils.didClone(__rect), 
                    _self.m_rectInfo.actionAreaLeft.width = __actionAreaWidth, _self.m_rectInfo.actionAreaLeftButton = xUtils.didClone(__rect), 
                    _self.m_rectInfo.actionAreaLeftButton.width = __actionAreaWidth, _self.m_rectInfo.actionAreaLeftButton.height = __actionAreaWidth, 
                    _self.m_rectInfo.actionAreaLeftButton.y = parseInt((__height - __actionAreaWidth) / 2), 
                    _self.m_rectInfo.actionAreaRight = xUtils.didClone(__rect), _self.m_rectInfo.actionAreaRight.x = __width - __actionAreaWidth, 
                    _self.m_rectInfo.actionAreaRight.width = __actionAreaWidth, _self.m_rectInfo.actionAreaRightButton = xUtils.didClone(__rect), 
                    _self.m_rectInfo.actionAreaRightButton.width = __actionAreaWidth, _self.m_rectInfo.actionAreaRightButton.height = __actionAreaWidth, 
                    _self.m_rectInfo.actionAreaRightButton.y = parseInt((__height - __actionAreaWidth) / 2), 
                    _self.m_rectInfo.scrollArea = xUtils.didClone(__rect), _self.m_rectInfo.scrollArea.x = __actionAreaWidth - 1, 
                    _self.m_rectInfo.scrollArea.width = __scrollAreaWidth, _self.m_rectInfo.scrollBgArea = xUtils.didClone(__rect), 
                    _self.m_rectInfo.scrollBgArea.x = _self.m_xSettings.THUMB_SIZING_BUTTON_LEFT_MARGIN + 1, 
                    _self.m_rectInfo.scrollBgArea.width = __scrollAreaWidth - 2 - (2 + _self.m_xSettings.THUMB_SIZING_BUTTON_LEFT_MARGIN + _self.m_xSettings.THUMB_SIZING_BUTTON_RIGHT_MARGIN) - 1, 
                    _self.m_rectInfo.scrollBgArea.height = __height - 2, _self.m_rectInfo.scrollBgDrawArea = xUtils.didClone(__rect), 
                    _self.m_rectInfo.scrollBgDrawArea.width = __scrollAreaWidth - 2, _self.m_rectInfo.scrollBgDrawArea.height = __height - 2, 
                    _self.m_rectInfo.thumbBar = xUtils.didClone(__rect), _self.m_rectInfo.thumbBar.x = 1 + __thumbPos, 
                    _self.m_rectInfo.thumbBar.y = 1, _self.m_rectInfo.thumbBar.width = __thumbWidth - 4, 
                    _self.m_rectInfo.thumbBar.height = __height - 4;
                    var __thumbBarWidth = _self.m_rectInfo.thumbBar.width, __thumbBarHeight = _self.m_rectInfo.thumbBar.height;
                    return __rect.height = __thumbBarHeight, _self.m_rectInfo.thumbBarM = xUtils.didClone(__rect), 
                    _self.m_rectInfo.thumbBarM.x = __thumbSizeWidth - _self.m_xSettings.THUMB_SIZING_BUTTON_LEFT_MARGIN, 
                    _self.m_rectInfo.thumbBarM.width = __calcMiddleWidth(__thumbBarWidth, __thumbSizeWidth) + __thumbBarMarginLR - 1, 
                    __rect.y = 0, __rect.height = _self.m_xSettings.THUMB_SIZING_BUTTON_HEIGHT, _self.m_rectInfo.thumbBarL = xUtils.didClone(__rect), 
                    _self.m_rectInfo.thumbBarL.width = __thumbSizeWidth, _self.m_rectInfo.thumbBarR = xUtils.didClone(__rect), 
                    _self.m_rectInfo.thumbBarR.x = __thumbBarWidth - __thumbSizeWidth, _self.m_rectInfo.thumbBarR.width = __thumbSizeWidth, 
                    __thumbWidth;
                };
                this.didResizeScreen = function(rectInfo) {
                    void 0 !== rectInfo && null != rectInfo && _self.didUpdateScrollBar(!1, rectInfo);
                };
                var _didStartRepeatDownAction = function() {
                    _didClearRepeatDownAction(), _self.m_tiIdRepeatDown = setInterval(function() {
                        _self.m_bStepButtonLDown ? _didScrollStep(-1, !0) : _self.m_bStepButtonRDown && _didScrollStep(1, !0);
                    }, _self.m_nRepeatTime);
                }, _didCheckRepeatTimeout = function() {
                    _didClearRepeatTimeout(), _self.m_toIdRepeatDown = setTimeout(function() {
                        _didStartRepeatDownAction();
                    }, _self.m_xSettings.STEP_PRESSING_TIME);
                }, _didClearRepeatTimeout = function() {
                    _self.m_toIdRepeatDown >= 0 && (clearTimeout(_self.m_toIdRepeatDown), _self.m_toIdRepeatDown = -1);
                }, _didClearRepeatDownAction = function() {
                    _self.m_tiIdRepeatDown >= 0 && (clearTimeout(_self.m_tiIdRepeatDown), _self.m_tiIdRepeatDown = -1);
                }, _didEndMouseAction = function() {
                    _self.m_bMouseDown = !1, _self.m_bStepButtonLDown = !1, _self.m_bStepButtonRDown = !1, 
                    _didClearRepeatDownAction(), _didClearRepeatTimeout();
                }, _zsWrap_OnMouseDown = function(event) {
                    var __event = event || window.event;
                    if (_self.m_bMouseDown = !0, !__event) return !0;
                    var posval = _didGetAdjustedMouseEventPosition(__event);
                    return !0 === _didEventProcForDown(__event.target.id, posval) || void 0;
                }, _zsWrap_OnMouseUp = function(event, capturedObj) {
                    var posval = (event || window.event, _didGetAdjustedMouseEventPosition(event, capturedObj));
                    if (!0 === _didEventProcForUp(event.target.id, posval)) return !0;
                }, _zsWrap_OnMouseMove = function(event, capturedObj) {
                    var __event = event || window.event;
                    if (_self.m_ptMouse.x === event.clientX && _self.m_ptMouse.y === event.clientY) return !0;
                    _self.m_ptMouse.x = event.clientX, _self.m_ptMouse.y = event.clientY;
                    var posval = _didGetAdjustedMouseEventPosition(__event, capturedObj);
                    return !0 === _didEventProcForMove(__event.target.id, posval) || void 0;
                }, _didScrollStep = function(nStep, bDraw) {
                    return 0 != nStep && (!!_self.m_pScroll.StepScroll(nStep) && (_self.didUpdateScrollBar(!1), 
                    !0));
                }, _zsWrap_OnClick = function(event) {
                    if (_didEndMouseAction(), !event) return !1;
                    try {
                        var targetId = event.target.id;
                        if (targetId.indexOf("eidZsActionButtonL") >= 0) _didScrollStep(-1, !0); else {
                            if (!(targetId.indexOf("eidZsActionButtonR") >= 0)) return !1;
                            _didScrollStep(1, !0);
                        }
                        return !0;
                    } catch (e) {}
                    return !1;
                }, _zsWrap_OnResize = function() {
                    var zsWrapObj = _self.didFindDomElementById("idZsWrap");
                    _self.m_nWrapWidth = zsWrapObj.offsetWidth, _self.m_nWrapHeight = zsWrapObj.offsetHeight, 
                    _self.m_rcArea = {
                        x: 0,
                        y: 0,
                        width: _self.m_nWrapWidth,
                        height: _self.m_nWrapHeight
                    }, _self.didResizeScreen(xUtils.didClone(_self.m_rcArea));
                };
                this.didGetEndScrollPos = function() {
                    return _self.m_pScroll.GetSBRange().length;
                }, this.didFindDomElementById = function(id) {
                    return _findDomElementById(_self, id);
                }, this.OnResize = function() {
                    _zsWrap_OnResize();
                }, this.OnMouseOver = function(strId) {
                    alert(_classRef.method.className + "(" + _classRef.method.id + "):" + strId);
                }, this.OnMouseDown = function(event) {
                    var __event = event || window.event;
                    0 == __event.button && !0 !== _zsWrap_OnMouseDown(__event) && _self.didStartCapture(__event.currentTarget);
                }, this.OnMouseUp = function(event, capturedObj) {
                    var __event = event || window.event;
                    _zsWrap_OnMouseUp(__event, capturedObj);
                }, this.OnMouseMove = function(event, capturedObj) {
                    var __event = event || window.event;
                    _zsWrap_OnMouseMove(__event, capturedObj);
                }, this.OnClick = function(event) {
                    var __event = event || window.event;
                    0 == __event.button && _zsWrap_OnClick(__event);
                }, this.OnMouseLeave = function(event) {
                    event || window.event;
                }, this.OnMouseEnter = function(event) {
                    event || window.event;
                }, this.OnDragOver = function(event) {
                    event || window.event;
                }, this.OnMouseWheel = function(event) {
                    event || window.event;
                }, this.OnKeyDown = function(event) {
                    event || window.event;
                }, this.OnDoubleClick = function(event) {
                    event || window.event;
                }, this.OnUnload = function() {
                    _didRemoveLinkElements(), delete _self.m_pScroll, _self.m_pScroll = null, delete _self.method.mouseCapture, 
                    _self.mouseCapture = null;
                }, this.OnContextMenu = function(event) {
                    event || window.event;
                    event.preventDefault();
                }, this.DidCallAfterDoneWithOnLoad = function() {
                    this.addEventOfZsDraw();
                }, this.clearEventOfZsDraw = function() {
                    var targetElement = _getTagetChildDOMElementById(_self, "idZsWrap");
                    if (targetElement.removeListener) for (var __ii in _eventTables) {
                        var __eventItem = _eventTables[__ii];
                        if (void 0 === __eventItem || null == __eventItem || void 0 === __eventItem.handler) break;
                        targetElement.removeListener(__eventItem.eventNane, __eventItem.handler, !1);
                    } else if (targetElement.detachEvent) for (var __ii in _self.m_eventTables) {
                        var __eventItem = _self.m_eventTables[__ii];
                        if (void 0 === __eventItem || null == __eventItem || void 0 === __eventItem.handler) break;
                        targetElement.detachEvent(__eventItem.eventNane, __eventItem.handler, !1);
                    }
                }, this.addEventOfZsDraw = function() {
                    var targetElement = _getTagetChildDOMElementById(_self, "idZsWrap");
                    if (targetElement.addEventListener) for (var __ii in _self.m_eventTables) {
                        var __eventItem = _self.m_eventTables[__ii];
                        if (void 0 === __eventItem || null == __eventItem || void 0 === __eventItem.handler) break;
                        targetElement.addEventListener(__eventItem.eventNane, __eventItem.handler, !1);
                    } else if (targetElement.attachEvent) for (var __ii in _self.m_eventTables) {
                        var __eventItem = _self.m_eventTables[__ii];
                        if (void 0 === __eventItem || null == __eventItem || void 0 === __eventItem.handler) break;
                        targetElement.attachEvent(__eventItem.eventNane, __eventItem.handler, !1);
                    }
                };
                var _didInitEventTables = function() {
                    _self.m_eventTables.push({
                        eventNane: "unload",
                        handler: _self.OnUnload
                    }), _self.m_eventTables.push({
                        eventNane: "resize",
                        handler: _self.OnResize
                    }), _self.m_eventTables.push({
                        eventNane: "mousedown",
                        handler: _self.OnMouseDown
                    }), _self.m_eventTables.push({
                        eventNane: "mouseup",
                        handler: _self.OnMouseUp
                    }), _self.m_eventTables.push({
                        eventNane: "mousemove",
                        handler: _self.OnMouseMove
                    }), _self.m_eventTables.push({
                        eventNane: "keydown",
                        handler: _self.OnKeyDown
                    }), _self.m_eventTables.push({
                        eventNane: "dblclick",
                        handler: _self.OnDoubleClick
                    }), _self.m_eventTables.push({
                        eventNane: "click",
                        handler: _self.OnClick
                    }), _self.m_eventTables.push({
                        eventNane: "mouseenter",
                        handler: _self.OnMouseEnter
                    }), _self.m_eventTables.push({
                        eventNane: "mouseleave",
                        handler: _self.OnMouseLeave
                    }), _self.m_eventTables.push({
                        eventNane: "mousewheel",
                        handler: _self.OnMouseWheel
                    }), _self.m_eventTables.push({
                        eventNane: "DOMMouseScroll",
                        handler: _self.OnMouseWheel
                    }), _self.m_eventTables.push({
                        eventNane: "contextmenu",
                        handler: _self.OnContextMenu
                    }), _self.m_eventTables.push({
                        eventNane: "__end__",
                        handler: void 0
                    }), _self.m_eventTables.push({
                        eventNane: "dragover",
                        handler: _self.OnDragOver
                    }), _self.m_eventTables.push({
                        eventNane: "keypress",
                        handler: _self.OnKeyDown
                    }), _self.m_eventTables.push({
                        eventNane: "storage",
                        handler: _self.OnStorageChange
                    });
                };
                this.didRegisterReflector = function(argType, argMethod) {}, this.didSetDelegate = function(pDelegate) {
                    _self.m_pDelegate = pDelegate;
                }, this.DidScrollToPos = function(caller, nPos, pShows) {
                    if (_Invalidate(!0), _self.m_pScroll) {
                        var pDelegate = _self.m_pDelegate;
                        pDelegate && pDelegate.DidScrollToPos && pDelegate.DidScrollToPos(_self, nPos, pShows);
                    }
                }, this.DidScrollUpdate = function(caller, notifyData) {
                    _Invalidate();
                }, this.WillBeDrawnBackground = function(caller, notifyData) {
                    if (m_pScroll) {
                        var pDelegate = _self.m_pDelegate;
                        if (pDelegate && pDelegate.WillBeDrawnBackground) return pDelegate.WillBeDrawnBackground(_self, pZsnd);
                    }
                    return !1;
                }, this.WillBeDrawnThumb = function(caller, notifyData) {
                    if (m_pScroll) {
                        var pDelegate = _self.m_pDelegate;
                        if (pDelegate && pDelegate.WillBeDrawnThumb) return pDelegate.WillBeDrawnThumb(_self, pZsnd);
                    }
                    return !1;
                };
            };
        };
        module.exports = loadModule(__webpack_require__(0), __webpack_require__(5), __webpack_require__(6), __webpack_require__(36));
    }();
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils) {
            return function(pDelegate, thumbSizeMin, useOneOver) {
                var _self = this;
                this.m_pDelegate = pDelegate, this.m_bUseOneOver = useOneOver || !1, this.m_bVert = !1, 
                this.m_rcArea = xUtils.shapes.didGetDefaultRect(), this.m_dThumbRate = 0, this.m_lThumbSize = 0, 
                this.m_nThumbPos = 0, this.m_bValid = !1, this.m_bStepButton = !1, this.m_nShowsMin = 0, 
                this.m_nShowsMax = 0, this.m_nPosPointed = 0, this.m_nShowsPointed = 0, this.m_rectPointed = xUtils.shapes.didGetDefaultRect(), 
                this.m_dDataPerSize = 0, this.m_dPosRatio = 0, this.m_sizExtra = xUtils.shapes.didGetDefaultSize(), 
                this.m_nScrollSize = 0, this.m_nShows = 0, this.m_nContents = 0, this.m_nFullSize = 0, 
                this.m_nStartPos = 0, this.m_nEndPos = 0, this.m_nShowFactor = 0, this.m_pStepState = null, 
                this.m_bStepStateLt = !1, this.m_bEventLock = !1, this.m_nThumbSizeMin = thumbSizeMin || 20, 
                this.m_rectThumbC1 = xUtils.shapes.didGetDefaultRect(), this.m_rectThumbCC = xUtils.shapes.didGetDefaultRect(), 
                this.m_rectThumbC2 = xUtils.shapes.didGetDefaultRect(), this.m_rectThumbS1 = xUtils.shapes.didGetDefaultRect(), 
                this.m_rectThumbS2 = xUtils.shapes.didGetDefaultRect(), this.m_rectThumbB = xUtils.shapes.didGetDefaultRect(), 
                this.m_rectThumbG = xUtils.shapes.didGetDefaultRect(), this.m_rectThumbT = xUtils.shapes.didGetDefaultRect(), 
                this.m_rectThumb = xUtils.shapes.didGetDefaultRect(), this.m_rectStepLt = xUtils.shapes.didGetDefaultRect(), 
                this.m_rectStepRb = xUtils.shapes.didGetDefaultRect();
                var _didInitVariables = function() {
                    _self.m_bVert = !1, _self.m_rcArea = xUtils.shapes.didGetDefaultRect(), _self.m_pptPointed = null, 
                    _self.m_dThumbRate = 0, _self.m_lThumbSize = 0, _self.m_nShows = 0, _self.m_nContents = 0, 
                    _self.m_nFullSize = 0, _self.m_nScrollSize = 0, _self.m_nStartPos = 0, _self.m_nEndPos = 0, 
                    _self.m_nThumbPos = 0, _self.m_dPosRatio = 0, _self.m_sizExtr = xUtils.shapes.didGetDefaultSize(), 
                    _self.m_bValid = !1, _self.m_pPtSizing1 = null, _self.m_pPtSizing2 = null, _self.m_nShowsPointed = 0, 
                    _self.m_dDataPerSize = 0, _self.m_nShowFactor = 3, _self.m_rectStepRb = xUtils.shapes.didGetDefaultRect(), 
                    _self.m_rectStepLt = xUtils.shapes.didGetDefaultRect(), _self.m_bStepButton = !1, 
                    _self.m_pStepState = null, _self.m_bStepStateLt = !1, _self.m_bEventLock = !1, _self.m_nShowsMin = 1;
                };
                this.GetSBInfo = function() {
                    return {
                        pos: _self.m_nThumbPos,
                        range: {
                            location: 0,
                            length: _self.m_nFullSize
                        },
                        screenSize: _self.m_nShows,
                        scrollRange: {
                            location: 0,
                            length: _self.m_nFullSize - _self.m_nShows
                        }
                    };
                }, this.GetSBRange = function() {
                    return _self.GetSBInfo().scrollRange;
                }, this.StepScroll = function(nStep) {
                    return 0 != nStep && (nStep < 0 ? _self.EStepButtonDown(!0) : _self.EStepButtonDown(!1), 
                    !0);
                }, this.didInitScroll = function(pDelegate) {
                    _didInitVariables();
                }, this.SetContentsSize = function(nShows, nContents, nShowsMin, nShowsMax) {
                    return _self.m_nShows = Math.max(0, nShows), _self.m_nContents = Math.max(0, nContents), 
                    void 0 !== nShowsMin && nShowsMin && (_self.m_nShowsMin = Math.max(1, nShowsMin)), 
                    void 0 !== nShowsMax && null != nShowsMax && nShowsMax < nShowsMin && (nShowsMax = null), 
                    _self.m_nShowsMax = nShowsMax, _self.Calculate(!0, !0);
                }, this.SetArea = function(rcArea) {
                    if (_self.m_rcArea = xUtils.didClone(rcArea), _self.m_bStepButton) {
                        var nSize = 0;
                        _self.m_bVert ? (nSize = _self.m_rcArea.width, _self.m_rectStepLt.x = _self.m_rcArea.x, 
                        _self.m_rectStepLt.y = _self.m_rcArea.y, m_rectStepRb.x = _self.m_rcArea.x, m_rectStepRb.y = _self.m_rcArea.y + _self.m_rcArea.height - nSize, 
                        m_rectStepLt.width = nSize, m_rectStepLt.Height = nSize, m_rectStepRb.width = nSize, 
                        m_rectStepRb.Height = nSize) : (nSize = m_rcArea.height, _self.m_rectStepLt.x = _self.m_rcArea.x, 
                        _self.m_rectStepLt.y = _self.m_rcArea.y, _self.m_rectStepRb.x = _self.m_rcArea.x + _self.m_rcArea.width - nSize, 
                        _self.m_rectStepRb.y = _self.m_rcArea.y, _self.m_rectStepLt.width = nSize, _self.m_rectStepLt.Height = nSize, 
                        _self.m_rectStepRb.width = nSize, _self.m_rectStepRb.Height = nSize);
                    } else _self.m_rectStepRb = xUtils.shapes.didGetDefaultRect(), _self.m_rectStepLt = xUtils.shapes.didGetDefaultRect();
                    _self.Calculate(!1, !0);
                }, this.ChangeContentsSize = function(nShows, nContents) {
                    var bCalc = !1, bContents = !1;
                    return nShows > 0 && nShows != _self.m_nShows && (_self.m_nShows = nShows, bCalc = !0), 
                    nContents > 1 && nContents != _self.m_nContents && (_self.m_nContents = nContents, 
                    bCalc = !0, bContents = !0), !0 === bCalc && _self.Calculate(bContents, !0);
                }, this.CalcThumbRatioAndSize = function(nSize) {
                    !0 === _self.m_bValid ? _self.m_dThumbRate = _self.m_nShows / _self.m_nFullSize : _self.m_dThumbRate = 1, 
                    _self.m_lThumbSize = parseInt(nSize * _self.m_dThumbRate);
                }, this.ResizeThumb = function(bLT, nMovedPixel) {
                    var rectThumb = (xUtils.didClone(_self.m_rcArea), xUtils.didClone(_self.GetAreaForThumb())), rect = xUtils.didClone(_self.m_rectPointed), nDiff = 0;
                    if (_self.m_bVert) {
                        var nMin = _self.GetMinThumbSize(), nMax = _self.GetMaxThumbSize();
                        if (bLT) nMax = Math.min(rectThumb.y + rectThumb.height - _self.m_rectPointed.y, nMax), 
                        rect.height = Math.max(nMin, Math.min(nMax, _self.m_rectPointed.height + nMovedPixel)); else {
                            nMax = Math.min(_self.m_rectPointed.y + _self.m_rectPointed.height - rectThumb.y, nMax);
                            var nTemp = rect.height;
                            rect.height = Math.min(nMax, Math.max(nMin, rect.height - nMovedPixel)), nDiff = rect.height - nTemp, 
                            rect.y = rect.y - nDiff;
                        }
                        _self.Calculate2(!1), _self.CalculateThumb2(rect);
                    } else {
                        var nMin = _self.GetMinThumbSize(), nMax = _self.GetMaxThumbSize();
                        if (bLT) {
                            nMax = Math.min(_self.m_rectPointed.x + _self.m_rectPointed.width - rectThumb.x, nMax);
                            var nTemp = rect.width;
                            rect.width = Math.min(nMax, Math.max(nMin, rect.width - nMovedPixel)), nDiff = rect.width - nTemp, 
                            rect.x = rect.x - nDiff;
                        } else nMax = Math.min(rectThumb.x + rectThumb.width - _self.m_rectPointed.x, nMax), 
                        rect.width = Math.max(nMin, Math.min(nMax, _self.m_rectPointed.width + nMovedPixel));
                        _self.Calculate2(!1), _self.CalculateThumb2(rect);
                    }
                    return !0;
                }, /*!
				get minimum thumb size ratio
				@param[in]	nSize	size
				@return		double
				*/
                this.GetMinThumbRatio = function(nSize) {
                    return nSize < 1 ? 0 : _self.GetMinThumbSize() / nSize;
                }, /*!
				get minimum thumb size
				@return		int
				*/
                this.GetMinThumbSize = function() {
                    var nTemp1 = 0, rectThumb = xUtils.didClone(_self.GetAreaForThumb()), nSize = _self.m_bVert ? rectThumb.height : rectThumb.width;
                    nTemp1 = _self.m_nFullSize < 1 ? nSize : nSize / _self.m_nFullSize;
                    var nShowsMin = Math.max(7, _self.m_nShowsMin);
                    return Math.max(nTemp1 * nShowsMin, 15);
                }, /*!
				get minimum thumb size
				@return		int
				*/
                this.GetMaxThumbSize = function() {
                    var nTemp1 = 0, rectThumb = xUtils.didClone(_self.GetAreaForThumb()), nSize = _self.m_bVert ? rectThumb.height : rectThumb.width;
                    nTemp1 = _self.m_nFullSize < 1 ? nSize : nSize / _self.m_nFullSize;
                    var nMaxThumb = xUtils.constants.default.DEFAULT_WRONG_VALUE, nShowsMax = _self.m_nShowsMax;
                    return nShowsMax && nShowsMax > _self.m_nShowsMin && (nMaxThumb = _self.m_bVert ? Math.min(nTemp1 * nShowsMax, rectThumb.height) : Math.min(nTemp1 * nShowsMax, rectThumb.width)), 
                    nMaxThumb;
                }, this.GetAreaForThumb = function() {
                    var rectRet = xUtils.didClone(_self.m_rcArea);
                    if (!0 === _self.m_bStepButton) {
                        !0 === _self.m_bVert ? (rectRet.y = _self.m_rectStepLt.y + _self.m_rectStepLt.height, 
                        rectRet.height = rectRet.height - (_self.m_rectStepLt.height + _self.m_rectStepRb.height)) : (rectRet.x = _self.m_rectStepLt.x + _self.m_rectStepLt.width, 
                        rectRet.width = rectRet.width - (_self.m_rectStepLt.width + _self.m_rectStepRb.width));
                    }
                    return rectRet;
                }, this.CalculateThumb = function(pOffset, bMove) {
                    var rectThumb = _self.GetAreaForThumb(), lSize = 0, rect = xUtils.shapes.didGetDefaultRect();
                    void 0 !== pOffset && null != pOffset ? !0 === _self.m_bVert ? lSize = rectThumb.height : (lSize = rectThumb.width, 
                    rect = _self.m_rectPointed, rect.x = Math.min(rectThumb.x + rectThumb.width - _self.m_rectPointed.width, Math.max(rectThumb.x, rect.x + pOffset)), 
                    bMove || (rect.width = _self.m_rectPointed.width - (rect.x - _self.m_rectPointed.x)), 
                    _self.m_rectThumbG = xUtils.didClone(rect), _self.m_rectThumbB = xUtils.didClone(rect), 
                    _self.m_rectThumbG.height = _self.m_rectThumbG.height / 2, _self.m_rectThumbS1.width = _self.m_rectThumbB.width, 
                    _self.m_rectThumbS1.height = 5, _self.m_rectThumbS1.x = _self.m_rectThumbB.x, _self.m_rectThumbS1.y = _self.m_rectThumbB.y + _self.m_rectThumbB.height - (2 + _self.m_rectThumbS1.height), 
                    _self.m_rectThumbS2 = xUtils.didClone(_self.m_rectThumbS1), _self.m_rectThumbS2.y = _self.m_rectThumbB.y + 2, 
                    _self.m_rectThumbCC.x = _self.m_rectThumbB.x + _self.m_rectThumbB.width / 2, _self.m_rectThumbCC.y = _self.m_rectThumbB.y + _self.m_rectThumbG.height / 2 - 1, 
                    _self.m_rectThumbCC.width = _self.m_rectThumbG.width, _self.m_rectThumbCC.height = 3, 
                    _self.m_rectThumbC1 = xUtils.didClone(_self.m_rectThumbCC), _self.m_rectThumbC1.y = _self.m_rectThumbCC.y + 2 * _self.m_rectThumbCC.height, 
                    _self.m_rectThumbC2 = xUtils.didClone(_self.m_rectThumbCC), _self.m_rectThumbC2.y = _self.m_rectThumbCC.x - 2 * _self.m_rectThumbCC.height) : _self.m_bVert ? (lSize = rectThumb.height, 
                    rect.x = rectThumb.x, rect.y = rectThumb.y + parseInt(_self.m_dPosRatio * _self.m_nThumbPos), 
                    rect.width = rectThumb.width, rect.height = parseInt(lSize * _self.m_dThumbRate), 
                    _self.m_rectThumbG = xUtils.didClone(rect), _self.m_rectThumbB = xUtils.didClone(rect), 
                    _self.m_rectThumbG.width = _self.m_rectThumbG.width / 2, _self.m_rectThumbS1.x = _self.m_rectThumbB.x + 2, 
                    _self.m_rectThumbS1.y = _self.m_rectThumbB.y + 2, _self.m_rectThumbS1.width = 3, 
                    _self.m_rectThumbS1.height = _self.m_rectThumbB.height - 4, _self.m_rectThumbS2 = xUtils.didClone(_self.m_rectThumbS1), 
                    _self.m_rectThumbS2.x = _self.m_rectThumbB.x + _self.m_rectThumbB.width - _self.m_rectThumbS1.width - 2, 
                    _self.m_rectThumbCC.x = _self.m_rectThumbB.x + _self.m_rectThumbB.width / 2 - 1, 
                    _self.m_rectThumbCC.y = _self.m_rectThumbB.y + _self.m_rectThumbG.height / 2, _self.m_rectThumbCC.width = 3, 
                    _self.m_rectThumbCC.height = _self.m_rectThumbG.height, _self.m_rectThumbC1 = xUtils.didClone(_self.m_rectThumbCC), 
                    _self.m_rectThumbC1.x = _self.m_rectThumbCC.x - 2 * _self.m_rectThumbCC.width, _self.m_rectThumbC2 = xUtils.didClone(_self.m_rectThumbCC), 
                    _self.m_rectThumbC2.x = _self.m_rectThumbCC.x + 2 * _self.m_rectThumbCC.width) : (lSize = rectThumb.width, 
                    rect.x = rectThumb.x + parseInt(_self.m_dPosRatio * _self.m_nThumbPos), rect.y = rectThumb.y, 
                    rect.width = parseInt(lSize * _self.m_dThumbRate), rect.height = rectThumb.height, 
                    _self.m_rectThumbG = xUtils.didClone(rect), _self.m_rectThumbB = xUtils.didClone(rect), 
                    _self.m_rectThumbG.height = _self.m_rectThumbG.height / 2, _self.m_rectThumbS1.x = _self.m_rectThumbB.x + 2, 
                    _self.m_rectThumbS1.y = _self.m_rectThumbB.y + 2, _self.m_rectThumbS1.width = 3, 
                    _self.m_rectThumbS1.height = _self.m_rectThumbB.height - 4, _self.m_rectThumbS2 = xUtils.didClone(_self.m_rectThumbS1), 
                    _self.m_rectThumbS2.x = _self.m_rectThumbB.x + _self.m_rectThumbB.width - _self.m_rectThumbS1.width - 2, 
                    _self.m_rectThumbCC.x = _self.m_rectThumbB.x + _self.m_rectThumbB.width / 2 - 1, 
                    _self.m_rectThumbCC.y = _self.m_rectThumbB.y + _self.m_rectThumbG.height / 2, _self.m_rectThumbCC.width = 3, 
                    _self.m_rectThumbCC.height = _self.m_rectThumbG.height, _self.m_rectThumbC1 = xUtils.didClone(_self.m_rectThumbCC), 
                    _self.m_rectThumbC1.x = _self.m_rectThumbCC.x - 2 * _self.m_rectThumbCC.width, _self.m_rectThumbC2 = xUtils.didClone(_self.m_rectThumbCC), 
                    _self.m_rectThumbC2.x = _self.m_rectThumbCC.x + 2 * _self.m_rectThumbCC.width);
                }, this.ChangeThumbPos = function(nPos) {
                    return 0 == _self.m_bEventLock && nPos >= 0 && nPos < _self.m_nFullSize && _self.m_nThumbPos != nPos && (_self.m_nThumbPos = nPos, 
                    _self.CalculateThumb(void 0, !1), _self.m_pDelegate && _self.m_pDelegate.DidScrollUpdate(_self, void 0), 
                    !0);
                }, this.Calculate = function(bContents, bCalcThumb) {
                    bContents && (_self.m_nFullSize = _self.m_nContents, _self.m_nFullSize += _self.m_sizExtra.cx + _self.m_sizExtra.cy, 
                    _self.m_nStartPos = _self.m_sizExtra.cx, _self.m_nEndPos = _self.m_nFullSize - _self.m_sizExtra.cy), 
                    _self.m_nFullSize < 1 && (_self.m_bValid = !1);
                    var nSize = 0, rectArea = _self.GetAreaForThumb();
                    if (nSize = !0 === _self.m_bVert ? rectArea.height : rectArea.width, _self.CalcThumbRatioAndSize(nSize), 
                    nSize > 0) {
                        _self.m_dDataPerSize = _self.m_nFullSize / nSize, void 0 === _self.m_nShowsMin || null == _self.m_nShowsMin || isNaN(_self.m_nShowsMin) || (_self.m_nShowsMin = Math.max(_self.m_nShowsMin, Math.ceil(_self.m_dDataPerSize * _self.m_nThumbSizeMin)));
                        var dTemp = nSize - _self.m_lThumbSize;
                        _self.m_nShows == _self.m_nFullSize ? _self.m_dPosRatio = 0 : _self.m_dPosRatio = dTemp / (_self.m_nFullSize - _self.m_nShows);
                    }
                    return _self.m_bValid = !0, bCalcThumb && _self.CalculateThumb(void 0, !1), _self.m_bValid;
                }, this.CalcShowsFromThumbRatio = function(nSize) {
                    _self.m_bValid && (_self.m_dThumbRate = _self.m_lThumbSize / nSize, _self.m_nShows = Math.round(_self.m_nFullSize * _self.m_dThumbRate));
                }, this.Calculate2 = function(bMove) {
                    var rectArea = xUtils.didClone(_self.GetAreaForThumb());
                    if (!bMove) {
                        var nSize = 0;
                        if (_self.m_bVert ? (nSize = rectArea.height, _self.m_lThumbSize = _self.m_rectThumbB.height) : (nSize = rectArea.width, 
                        _self.m_lThumbSize = _self.m_rectThumbB.width), nSize < 1) return _self.m_bValid = !1;
                        if (_self.CalcShowsFromThumbRatio(nSize), 0 != nSize) {
                            _self.m_dDataPerSize = _self.m_nFullSize / nSize;
                            var dTemp = nSize - _self.m_lThumbSize;
                            _self.m_nFullSize == _self.m_nShows ? _self.m_dPosRatio = 0 : _self.m_dPosRatio = dTemp / (_self.m_nFullSize - _self.m_nShows);
                        }
                        _self.m_bValid = !0;
                    }
                    return _self.m_bVert ? _self.m_nThumbPos = 0 != _self.m_dPosRatio ? _self.m_nFullSize - _self.m_nShows - Math.round((_self.m_rectThumbB.y - rectArea.y) / _self.m_dPosRatio) : 0 : _self.m_nThumbPos = 0 != _self.m_dPosRatio ? Math.round((_self.m_rectThumbB.x - rectArea.x) / _self.m_dPosRatio) : 0, 
                    _self.m_bValid;
                }, this.CalculateThumb2 = function(rect) {
                    if (_self.m_bValid) {
                        _self.m_bVert ? (_self.m_rectThumbG = xUtils.didClone(rect), _self.m_rectThumbB = xUtils.didClone(rect), 
                        _self.m_rectThumbG.width = _self.m_rectThumbG.width / 2, _self.m_rectThumbS1.width = _self.m_rectThumbB.width, 
                        _self.m_rectThumbS1.height = 5, _self.m_rectThumbS1.x = _self.m_rectThumbB.x, _self.m_rectThumbS1.y = _self.m_rectThumbB.y + _self.m_rectThumbB.height - (2 + _self.m_rectThumbS1.height), 
                        _self.m_rectThumbS2 = xUtils.didClone(_self.m_rectThumbS1), _self.m_rectThumbS2.y = _self.m_rectThumbB.y + 2, 
                        _self.m_rectThumbCC.x = _self.m_rectThumbB.x + _self.m_rectThumbB.width / 2, _self.m_rectThumbCC.y = _self.m_rectThumbB.y + _self.m_rectThumbG.height / 2 - 1, 
                        _self.m_rectThumbCC.width = _self.m_rectThumbG.width, _self.m_rectThumbCC.height = 3, 
                        _self.m_rectThumbC1 = xUtils.didClone(_self.m_rectThumbCC), _self.m_rectThumbC1.y = _self.m_rectThumbCC.y + 2 * _self.m_rectThumbCC.height, 
                        _self.m_rectThumbC2 = xUtils.didClone(_self.m_rectThumbCC), _self.m_rectThumbC2.y = _self.m_rectThumbCC.x - 2 * _self.m_rectThumbCC.height) : (_self.m_rectThumbG = xUtils.didClone(rect), 
                        _self.m_rectThumbB = xUtils.didClone(rect), _self.m_rectThumbG.height = _self.m_rectThumbG.height / 2, 
                        _self.m_rectThumbS1.x = _self.m_rectThumbB.x + 2, _self.m_rectThumbS1.y = _self.m_rectThumbB.y, 
                        _self.m_rectThumbS1.width = 5, _self.m_rectThumbS1.height = _self.m_rectThumbB.height, 
                        _self.m_rectThumbS2 = xUtils.didClone(_self.m_rectThumbS1), _self.m_rectThumbS2.x = _self.m_rectThumbB.x + _self.m_rectThumbB.width - (_self.m_rectThumbS1.width + 2), 
                        _self.m_rectThumbCC.x = _self.m_rectThumbB.x + _self.m_rectThumbB.width / 2 - 1, 
                        _self.m_rectThumbCC.y = _self.m_rectThumbB.y + _self.m_rectThumbG.height / 2, _self.m_rectThumbCC.width = 3, 
                        _self.m_rectThumbCC.height = _self.m_rectThumbG.height, _self.m_rectThumbC1 = xUtils.didClone(_self.m_rectThumbCC), 
                        _self.m_rectThumbC1.x = _self.m_rectThumbCC.x - 2 * _self.m_rectThumbCC.width, _self.m_rectThumbC2 = xUtils.didClone(_self.m_rectThumbCC), 
                        _self.m_rectThumbC2.x = _self.m_rectThumbCC.x + 2 * _self.m_rectThumbCC.width);
                    } else _self.m_rectThumbC1 = xUtils.shapes.didGetDefaultRect(), _self.m_rectThumbCC = xUtils.shapes.didGetDefaultRect(), 
                    _self.m_rectThumbC2 = xUtils.shapes.didGetDefaultRect(), _self.m_rectThumbS1 = xUtils.shapes.didGetDefaultRect(), 
                    _self.m_rectThumbS2 = xUtils.shapes.didGetDefaultRect(), _self.m_rectThumbB = xUtils.shapes.didGetDefaultRect(), 
                    _self.m_rectThumbG = xUtils.shapes.didGetDefaultRect();
                }, this.MoveThumbWithPixel = function(nMovedPixel) {
                    var rectThumb = xUtils.didClone(_self.GetAreaForThumb()), rect = xUtils.didClone(_self.m_rectPointed);
                    return _self.m_bVert ? (rect.y = Math.min(rectThumb.y + rectThumb.height - _self.m_rectPointed.height, Math.max(rectThumb.y, rect.y + nMovedPixel)), 
                    rect.y - _self.m_rectPointed.y, _self.Calculate2(!0), _self.CalculateThumb2(rect)) : (rect.x = Math.min(rectThumb.x + rectThumb.width - _self.m_rectPointed.width, Math.max(rectThumb.x, rect.x + nMovedPixel)), 
                    rect.x - _self.m_rectPointed.x, _self.Calculate2(!0), _self.CalculateThumb2(rect)), 
                    !0;
                }, this.ELBtnDn = function(wp, lp) {
                    var bRet = !1, nFlags = wp, point = xUtils.shapes.didGetDefaultPoint();
                    point.x = lp.XPos, point.y = lp.YPos;
                    var rectTs1 = xUtils.didClone(_self.m_rectThumbS1), rectTs2 = xUtils.didClone(_self.m_rectThumbS2);
                    xUtils.didClone(_self.m_rectThumbB);
                    xUtils.shapes.InflateRect(rectTs1, 1, 1), xUtils.shapes.InflateRect(rectTs2, 1, 1);
                    return nFlags.EVT_SIZING1 ? (!0, _self.m_pPtSizing1 || (_self.m_pPtSizing1 = xUtils.shapes.didGetDefaultPoint()), 
                    _self.m_pPtSizing1.x = point.x, _self.m_pPtSizing1.y = point.y, _self.m_nPosPointed = _self.m_nThumbPos, 
                    _self.m_nShowsPointed = _self.m_nShows, _self.m_rectPointed = xUtils.didClone(_self.m_rectThumbB), 
                    _self.m_aclrThumb = _self.m_aclrThumbPointed, _self.m_pDelegate && _self.m_pDelegate.DidScrollUpdate(_self, null), 
                    bRet = !0) : nFlags.EVT_SIZING2 ? (!0, _self.m_pPtSizing2 || (_self.m_pPtSizing2 = xUtils.shapes.didGetDefaultPoint()), 
                    _self.m_pPtSizing2.x = point.x, _self.m_pPtSizing2.y = point.y, _self.m_nPosPointed = _self.m_nThumbPos, 
                    _self.m_nShowsPointed = _self.m_nShows, _self.m_rectPointed = xUtils.didClone(_self.m_rectThumbB), 
                    _self.m_aclrThumb = _self.m_aclrThumbPointed, _self.m_pDelegate && _self.m_pDelegate.DidScrollUpdate(_self, null), 
                    bRet = !0) : nFlags.EVT_MOVING ? (_self.m_pptPointed || (_self.m_pptPointed = xUtils.shapes.didGetDefaultPoint()), 
                    _self.m_pptPointed.x = point.x, _self.m_pptPointed.y = point.y, _self.m_nPosPointed = _self.m_nThumbPos, 
                    _self.m_nShowsPointed = _self.m_nShows, _self.m_rectPointed = xUtils.didClone(_self.m_rectThumbB), 
                    _self.m_aclrThumb = _self.m_aclrThumbPointed, _self.m_pDelegate && _self.m_pDelegate.DidScrollUpdate(_self, null), 
                    bRet = !0) : nFlags.EVT_STEP_DOWN ? (_self.m_bStepStateLt = !0, _self.EStepButtonDown(_self.m_bStepStateLt), 
                    bRet = !0) : nFlags.EVT_STEP_UP && (_self.m_bStepStateLt = !1, _self.EStepButtonDown(_self.m_bStepStateLt), 
                    bRet = !0), bRet;
                }, this.EStepButtonDown = function(bScrollDown) {
                    return bScrollDown ? _self.m_nThumbPos-- : _self.m_nThumbPos++, _self.m_nThumbPos = Math.min(_self.m_nFullSize - _self.m_nShows, Math.max(0, _self.m_nThumbPos)), 
                    _self.CalculateThumb(null, !1), _self.m_pDelegate && (_self.m_bEventLock = !0, _self.m_pDelegate.DidScrollToPos(_self, _self.m_nThumbPos, null), 
                    _self.m_bEventLock = !1), !0;
                }, /*!
				event for left button up
				see WM_LEFTBUTTONUP
				@param[in]	wp	flags
				@param[in]	lp	point
				*/
                this.ELBtnUp = function(wp, lp) {
                    var bRet = !1, point = xUtils.shapes.didGetDefaultPoint();
                    return point.x = lp.XPos, point.y = lp.YPos, _self.m_pptPointed ? (_self.m_pptPointed = void 0, 
                    _self.m_aclrThumb = _self.m_aclrThumbNormal, bRet = !0) : _self.m_pPtSizing1 ? (_self.m_pPtSizing1 = void 0, 
                    _self.m_aclrThumb = _self.m_aclrThumbNormal, bRet = !0) : _self.m_pPtSizing2 ? (_self.m_pPtSizing2 = void 0, 
                    _self.m_aclrThumb = _self.m_aclrThumbNormal, bRet = !0) : 60002 == _self.m_uiTeStepTrigger ? (_self.m_uiTeStepTrigger = 0, 
                    _self.m_aclrStepLt = _self.m_aclrStepNormal, _self.m_aclrStepRb = _self.m_aclrStepNormal, 
                    bRet = !0) : _self.m_pStepState && (_self.m_pStepState = null, 60001 == _self.m_uiTeStep && (_self.m_uiTeStep = 0), 
                    _self.m_aclrStepLt = _self.m_aclrStepNormal, _self.m_aclrStepRb = _self.m_aclrStepNormal, 
                    bRet = !0), bRet && _self.m_pDelegate && _self.m_pDelegate.DidScrollUpdate(_self, null), 
                    bRet;
                }, this.EMouseMove = function(wp, lp) {
                    var bRet = !1, point = xUtils.shapes.didGetDefaultPoint();
                    point.x = lp.XPos, point.y = lp.YPos;
                    var pt = point, bUpdate = !1;
                    if (_self.m_pptPointed) {
                        var lDiff = 0;
                        lDiff = _self.m_bVert ? pt.y - _self.m_pptPointed.y : pt.x - _self.m_pptPointed.x, 
                        bUpdate = _self.MoveThumbWithPixel(lDiff), bUpdate && _self.m_pDelegate && (_self.m_bEventLock = !0, 
                        _self.m_pDelegate.DidScrollToPos(_self, _self.m_nThumbPos, null), _self.m_bEventLock = !1), 
                        bRet = !0;
                    } else if (_self.m_pPtSizing1) {
                        !0;
                        var lDiff = 0;
                        lDiff = _self.m_bVert ? pt.y - _self.m_pPtSizing1.y : pt.x - _self.m_pPtSizing1.x, 
                        bUpdate = _self.ResizeThumb(!0, lDiff), bUpdate && _self.m_pDelegate && (_self.m_bEventLock = !0, 
                        _self.m_pDelegate.DidScrollToPos(_self, _self.m_nThumbPos, _self.m_nShows), _self.m_bEventLock = !1), 
                        bRet = !0;
                    } else if (_self.m_pPtSizing2) {
                        !0;
                        var lDiff = 0;
                        lDiff = _self.m_bVert ? pt.y - _self.m_pPtSizing2.y : pt.x - _self.m_pPtSizing2.x, 
                        bUpdate = _self.ResizeThumb(!1, lDiff), bUpdate && _self.m_pDelegate && (_self.m_bEventLock = !0, 
                        _self.m_pDelegate.DidScrollToPos(_self, _self.m_nThumbPos, _self.m_nShows), _self.m_bEventLock = !1), 
                        bRet = !0;
                    }
                    return bRet;
                };
            };
        };
        module.exports = loadModule(__webpack_require__(0));
    }();
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils) {
            return function() {
                var _didGetCursorUrl = function(name) {
                    try {
                        var url = "-webkit-image-set(";
                        return url += "url('assets/images/cursors/" + name + ".png') 1x,", url += "url('assets/images/cursors/" + name + "@2x.png') 2x", 
                        url += ")";
                    } catch (e) {
                        console.error(e);
                    }
                }, _didInitCursors = function() {
                    try {
                        xUtils.constants.chartConfig.System.CursorConfig = {
                            move: "-webkit-grabbing",
                            "row-resize": "row-resize",
                            "hover-object": "pointer"
                        };
                        var trendLineCursors = (xUtils.constants.trendLineCodes, {});
                        trendLineCursors[xUtils.constants.trendLineCodes.trendLine] = trendLineCursors[xUtils.constants.trendLineCodes.horzLine] = trendLineCursors[xUtils.constants.trendLineCodes.vertLine] = trendLineCursors[xUtils.constants.trendLineCodes.doubleTrendline] = trendLineCursors[xUtils.constants.trendLineCodes.fiboFan] = trendLineCursors[xUtils.constants.trendLineCodes.fiboRetracement] = _didGetCursorUrl("cursor-draw") + ", default", 
                        trendLineCursors[xUtils.constants.trendLineCodes.deleteOneRepeat] = _didGetCursorUrl("cursor-select") + ", pointer", 
                        trendLineCursors[xUtils.constants.trendLineCodes.crossHair] = _didGetCursorUrl("cursor-chart-crosshair") + " 8 8, crosshair";
                        for (var trendLineInfo, trendLineTools = xUtils.trendLine, tlcKeys = Object.keys(trendLineCursors), ii = 0; ii < tlcKeys.length; ii++) try {
                            var tlcKey = tlcKeys[ii], cursor = trendLineCursors[tlcKey];
                            trendLineInfo = trendLineTools.didGetDefaultTrendlineInfoAt(tlcKey, !0), trendLineInfo && (trendLineInfo.cursor = cursor, 
                            tlcKey != xUtils.constants.trendLineCodes.deleteOneRepeat && (trendLineInfo.isHoverObject = !0));
                        } catch (e) {
                            console.error(e);
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }, _didInitStyles = function() {
                    try {
                        var chartConfig = xUtils.constants.chartConfig;
                        chartConfig.System.UseFlexMarginTopBottomInMain = !0, chartConfig.System.ExtraMarginForTopBottomInMain = 30, 
                        chartConfig.MarginRight = "10", chartConfig.TitleLeft = 60, chartConfig.TitleTop = 20, 
                        chartConfig.LabelMarkGap = 5, chartConfig.LabelMarkBoxSize = 12, chartConfig.ActionButtonTop = 16, 
                        chartConfig.ActionButtonLeft = 5, chartConfig.ActionButtonGap = 5, chartConfig.ActionButtonSize = 16, 
                        chartConfig.BorderColor = chartConfig.BackgroundColor = "transparent", chartConfig.SubBackgroundColor = "#3f3f55", 
                        chartConfig.XAxisBorderColor = chartConfig.XAxisBackgroundColor = "transparent", 
                        chartConfig.ShowTitleLabel = !0, chartConfig.ShowDataView = !1, chartConfig.Font = "13px Roboto", 
                        chartConfig.System.DefaultPriceBar = "cfd", chartConfig.System.UseContextMenu = !0, 
                        chartConfig.System.AllowSmoothScroll = !1, chartConfig.System.DontMoveOnTrendlineSelectMode = !0, 
                        chartConfig.System.DontUseAutoShowOepChange = !0, chartConfig.ExtraPanelWidth = 24, 
                        chartConfig.LabelFormat = {
                            timeFormat0: "hh:mm:ss",
                            dateFormat1: "MM/DD",
                            timeFormat1: "hh:mm",
                            dateFormat2: "YYYY/MM/DD",
                            dateFormat3: "YYYY/MM"
                        }, chartConfig.TooltipLabelStyle = {
                            background: "#aab8d8",
                            lineColor: "#aab8d8",
                            fontColor: "#4f5080"
                        }, chartConfig.MinMaxTooltipShow = !0, chartConfig.MarginTopBottom = "10", chartConfig.ZSBConfig = {
                            LineColor: "#00e6e6",
                            BgColor1: "#0088cc",
                            BgColor2: "rgba(0, 77, 153, 0.6)"
                        }, chartConfig.PriceStyleConfig.Candle.fillUpColor = chartConfig.PriceStyleConfig.Candle.strokeUpColor = "#e02424", 
                        chartConfig.PriceStyleConfig.Candle.fillDnColor = chartConfig.PriceStyleConfig.Candle.strokeDnColor = "#13a5c2", 
                        chartConfig.PriceStyleConfig.Line.strokeColor = "#dde1f0", chartConfig.Font = "13px Roboto", 
                        chartConfig.FontColor = "#aab8d8", chartConfig.ConfigAxis.Font = "13px Roboto", 
                        chartConfig.ConfigAxis.FontColor = "#aab8d8", chartConfig.System.YAxisWidth = 84, 
                        chartConfig.System.YAxisRight = 84, chartConfig.System.CrosslineLabelXWidth = 88, 
                        chartConfig.CrossLine.lineStyle.strokeStyle = 0, chartConfig.CrossLine.lineStyle.strokeWeight = 1, 
                        chartConfig.CrossLine.lineStyle.strokeColor = "#ffffff", chartConfig.OrderStyleConfig.ask.strokeColor = "#13a5c2", 
                        chartConfig.OrderStyleConfig.bid.strokeColor = "#f54242", chartConfig.PositStyleConfig.ask.strokeColor2 = "#4295f5", 
                        chartConfig.PositStyleConfig.bid.strokeColor2 = "#f54242", chartConfig.PositStyleConfig.ask.strokeWeight = chartConfig.PositStyleConfig.bid.strokeWeight = 2, 
                        chartConfig.PositStyleConfig.ask.strokeColor = chartConfig.PositStyleConfig.bid.strokeColor = "#2D2D42", 
                        chartConfig.AlertStyleConfig.default.strokeColor = "#84ccc9", chartConfig.AlertStyleConfig.ask.strokeColor = "#84ccc9", 
                        chartConfig.AlertStyleConfig.bid.strokeColor = "#84ccc9", chartConfig.AlertStyleConfig.dummy.strokeColor = "#84ccc9", 
                        chartConfig.ExecutionStyleConfig.noFill = !0, chartConfig.ExecutionStyleConfig.ask.strokeColor2 = "#4295f5", 
                        chartConfig.ExecutionStyleConfig.bid.strokeColor2 = "#f54242", chartConfig.ExecutionStyleConfig.ask.strokeWeight = chartConfig.ExecutionStyleConfig.bid.strokeWeight = 2, 
                        chartConfig.ExecutionStyleConfig.ask.strokeColor = chartConfig.ExecutionStyleConfig.bid.strokeColor = "#2D2D42", 
                        chartConfig.System.UseGlobalTrendlineColor = !0, chartConfig.TrendlineColor = "rgba(221, 225, 240, 0.6)", 
                        chartConfig.OrderStyleConfig.ask.cloneColor = "#4295f5", chartConfig.OrderStyleConfig.bid.cloneColor = "#f54242", 
                        chartConfig.OrderStyleConfig.ask.strokeColor = "rgba(66, 149, 245, 0.6)", chartConfig.OrderStyleConfig.bid.strokeColor = "rgba(254, 66, 66, 0.6)", 
                        chartConfig.ConfigAxis.GridStyle = 0, chartConfig.ConfigAxis.GridHorzColor = "#525366", 
                        chartConfig.ConfigAxis.GridVertColor = "#525366", chartConfig.TooltipDelay = 300, 
                        chartConfig.TooltipOffset = 15, chartConfig.PriceStyleConfig.AskBid = {}, chartConfig.PriceStyleConfig.AskBid.bidStrokeColor = chartConfig.PriceStyleConfig.AskBid.askStrokeColor = "#2D2D42", 
                        chartConfig.PriceStyleConfig.AskBid.askColor = "#F24040", chartConfig.PriceStyleConfig.AskBid.bidColor = "#378BDF", 
                        chartConfig.PriceStyleConfig.AskBid.invalidColor = "#505050", chartConfig.PriceStyleConfig.AskBid.rightMargin = 10, 
                        chartConfig.PriceStyleConfig.AskBid.shapeHorzSize = 12, chartConfig.PriceStyleConfig.AskBid.shapeVertSize = 14, 
                        chartConfig.PriceStyleConfig.AskBid.shapeGap = 5, chartConfig.PriceStyleConfig.AskBid.textGap = 3, 
                        chartConfig.System.Scroll.zoom = 100, chartConfig.System.Scroll.screenSize.max = null, 
                        chartConfig.System.UseMouseWheel = !1, chartConfig.System.TickJustLine = !0, chartConfig.System.NoDisplayAtOutOfArea = !0, 
                        chartConfig.System.DisplayEmptyInDetailViewWhenInvalid = !0, chartConfig.System.DefaultTrendline = "TL0001", 
                        chartConfig.System.ContainerSelect = !1, chartConfig.System.IndicatorSelect = !1, 
                        chartConfig.System.TrendlineLimits = 100, chartConfig.System.BackgroundLogo = {
                            LeftMargin: 8,
                            BottomMargin: 6,
                            Width: 164,
                            Height: 12
                        }, chartConfig.System.SubBackgroundMargin = 2;
                        var constants = xUtils.constants;
                        constants.text.dataView.invalid = "", constants.default.RULER_MARGIN = 12;
                        var number = xUtils.number;
                        number && (number.config || (number.config = {}), number.config.invalidComma = !0);
                        var hitTest = xUtils.hitTest;
                        hitTest && (hitTest.config ? hitTest.config.size = 3 : hitTest.config = {
                            size: 3,
                            color: "#aaaaaa"
                        }), _didInitCursors();
                        var dateTime = xUtils.dateTime;
                        dateTime && (dateTime.defaultWeekday = dateTime.weekDays.monday);
                    } catch (e) {}
                }, _didInitIndicatorCodes = function() {
                    try {
                        xUtils.constants.indicatorCodes = {
                            SMA_TRIPLE: "0600",
                            BOLLINGER_BANDS_TRIPLE_SUPER: "0601",
                            SPANMODEL: "0602",
                            HEIKINASHI: "0603",
                            RSI_TRIPLE: "0604",
                            ICHIMOKU_CFD: "0605",
                            STOCHASTIC_CFD: "0606",
                            MACD: "0607",
                            RCI: "0608",
                            EMA_TRIPLE: "0609",
                            BOLLINGER_BANDS_TRIPLE: "0610"
                        };
                    } catch (e) {
                        console.error(e);
                    }
                }, _didInitIndicators = function() {
                    try {
                        xUtils.constants.indicators = [ {
                            code: xUtils.constants.indicatorCodes.SMA_TRIPLE,
                            name: "Simple Moving Average",
                            display: "",
                            display_s: "SMA",
                            splitFlag: !1,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            extraDiff: 0,
                            editableExtraDiff: !0,
                            priceType: !0,
                            params: [ {
                                name: "Period1",
                                alias: "1",
                                value: 5,
                                default: 5,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            }, {
                                name: "Period2",
                                alias: "2",
                                value: 25,
                                default: 25,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            }, {
                                name: "Period3",
                                alias: "3",
                                value: 75,
                                default: 75,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            } ],
                            plots: [ {
                                name: "MA1",
                                alias: "MA1",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period1",
                                showHideOption: !0
                            }, {
                                name: "MA2",
                                alias: "MA2",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period2",
                                showHideOption: !0
                            }, {
                                name: "MA3",
                                alias: "MA3",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period3",
                                showHideOption: !0
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.EMA_TRIPLE,
                            name: "Exponential Moving Average",
                            display: "",
                            display_s: "EMA",
                            splitFlag: !1,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            extraDiff: 0,
                            editableExtraDiff: !0,
                            priceType: !0,
                            params: [ {
                                name: "Period1",
                                alias: "1",
                                value: 5,
                                default: 5,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            }, {
                                name: "Period2",
                                alias: "2",
                                value: 10,
                                default: 10,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            }, {
                                name: "Period3",
                                alias: "3",
                                value: 20,
                                default: 20,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            } ],
                            plots: [ {
                                name: "EMA1",
                                alias: "EMA1",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period1",
                                showHideOption: !0
                            }, {
                                name: "EMA2",
                                alias: "EMA2",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period2",
                                showHideOption: !0
                            }, {
                                name: "EMA3",
                                alias: "EMA3",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period3",
                                showHideOption: !0
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.BOLLINGER_BANDS_TRIPLE,
                            name: "Bollinger's Band",
                            display: "",
                            display_s: "BBand",
                            splitFlag: !1,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            extraDiff: 0,
                            editableExtraDiff: !0,
                            priceType: !0,
                            params: [ {
                                name: "Period",
                                alias: "",
                                value: 20,
                                default: 20,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            } ],
                            plots: [ {
                                name: "Middle",
                                alias: "",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "Up1",
                                alias: "1",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "Dn1",
                                alias: "1",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "Up2",
                                alias: "2",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "Dn2",
                                alias: "2",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "Up3",
                                alias: "3",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[3],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "Dn3",
                                alias: "3",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[3],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            } ],
                            titles: [ {
                                plotNo: 0,
                                params: [ 0 ]
                            }, {
                                plotNo: 1,
                                display: "1"
                            }, {
                                plotNo: 3,
                                display: "2"
                            }, {
                                plotNo: 5,
                                display: "3"
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.BOLLINGER_BANDS_TRIPLE_SUPER,
                            name: "Bollinger's Band",
                            display: "",
                            display_s: "SuperBBand",
                            splitFlag: !1,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            extraDiff: 0,
                            editableExtraDiff: !0,
                            priceType: !0,
                            params: [ {
                                name: "Period",
                                alias: "",
                                value: 21,
                                default: 20,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "BGSpan",
                                alias: "",
                                value: 21,
                                default: 20,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Band1",
                                alias: "1",
                                value: 1,
                                default: 1,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Band2",
                                alias: "2",
                                value: 2,
                                default: 2,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Band3",
                                alias: "3",
                                value: 3,
                                default: 3,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            } ],
                            plots: [ {
                                name: "Middle",
                                alias: "",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "Period"
                            }, {
                                name: "BGSpan",
                                alias: "",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "BGSpan",
                                moveShiftParamLink: 1
                            }, {
                                name: "Up1",
                                alias: "1",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "Band1"
                            }, {
                                name: "Dn1",
                                alias: "1",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "Band1"
                            }, {
                                name: "Up2",
                                alias: "2",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[3],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "Band2"
                            }, {
                                name: "Dn2",
                                alias: "2",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[3],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "Band2"
                            }, {
                                name: "Up3",
                                alias: "3",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[4],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "Band3"
                            }, {
                                name: "Dn3",
                                alias: "3",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[4],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "Band3"
                            } ],
                            titles: [ {
                                plotNo: 0,
                                params: [ 0 ]
                            }, {
                                plotNo: 1,
                                params: [ 1 ]
                            }, {
                                plotNo: 2,
                                params: [ 2 ],
                                display: "1"
                            }, {
                                plotNo: 4,
                                params: [ 3 ],
                                display: "2"
                            }, {
                                plotNo: 6,
                                params: [ 4 ],
                                display: "3"
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.SPANMODEL,
                            name: "Ichmoku Kinkohyo",
                            display: "",
                            display_s: "",
                            splitFlag: !1,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            priceType: !0,
                            params: [ {
                                name: "Period1",
                                alias: "",
                                value: 9,
                                default: 9,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Period2",
                                alias: "",
                                value: 26,
                                default: 26,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Period3",
                                alias: "",
                                value: 26,
                                default: 26,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            } ],
                            plots: [ {
                                name: "TenkanSen",
                                alias: "",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "KizyunSen",
                                alias: "",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "ChikouSen",
                                alias: "",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                moveShiftParamLink: 2
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.ICHIMOKU_CFD,
                            name: "Ichmoku Kinkohyo",
                            display: "",
                            display_s: "",
                            splitFlag: !1,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            priceType: !0,
                            params: [ {
                                name: "Period1",
                                alias: "",
                                value: 9,
                                default: 9,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Period2",
                                alias: "",
                                value: 26,
                                default: 26,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Period3",
                                alias: "1",
                                value: 26,
                                default: 26,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Period4",
                                alias: "2",
                                value: 52,
                                default: 52,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Period5",
                                alias: "",
                                value: 26,
                                default: 26,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            } ],
                            plots: [ {
                                name: "TenkanSen",
                                alias: "",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "KizyunSen",
                                alias: "",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "SenkouSpan1",
                                alias: "1",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                moveShiftParamLink: 2
                            }, {
                                name: "SenkouSpan2",
                                alias: "2",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[3],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                moveShiftParamLink: 3
                            }, {
                                name: "ChikouSen",
                                alias: "",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[4],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                moveShiftParamLink: 4
                            }, {
                                name: "SenkouSpan2Calc",
                                alias: "2",
                                ignore: !0
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.HEIKINASHI,
                            name: "Heikinashi",
                            display: "",
                            display_s: "",
                            splitFlag: !1,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            extraDiff: 0,
                            editableExtraDiff: !0,
                            priceType: !1,
                            params: [ {
                                name: "Period",
                                alias: "",
                                value: 5,
                                default: 5,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            } ],
                            plots: [ {
                                name: "Heikinashi",
                                alias: "",
                                plotStyle: 0,
                                type: 2,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period"
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.MACD,
                            name: "MACD",
                            display: "MACD",
                            display_s: "MACD",
                            splitFlag: !0,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            params: [ {
                                name: "ShortPeriod",
                                alias: "MACD ",
                                value: 12,
                                default: 12,
                                range: {
                                    min: 1,
                                    max: 255,
                                    step: 1
                                }
                            }, {
                                name: "LongPeriod",
                                alias: "MACD ",
                                value: 26,
                                default: 26,
                                range: {
                                    min: 1,
                                    max: 255,
                                    step: 1
                                }
                            }, {
                                name: "Period",
                                alias: "",
                                value: 9,
                                default: 9,
                                range: {
                                    min: 1,
                                    max: 255,
                                    step: 1
                                }
                            } ],
                            plots: [ {
                                name: "Short",
                                alias: "MACD ",
                                ignore: !0
                            }, {
                                name: "Long",
                                alias: "MACD ",
                                ignore: !0
                            }, {
                                name: "MACD",
                                alias: "MACD",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "Signal",
                                alias: "SIGNAL",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0
                            }, {
                                name: "Ocillator",
                                alias: "",
                                ignore: !0
                            } ],
                            titles: [ {
                                plotNo: 2,
                                params: [ 0, 1 ],
                                display: "MACD"
                            }, {
                                plotNo: 3,
                                params: [ 2 ],
                                display: "SIGNAL"
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.STOCHASTIC_CFD,
                            name: "Stochastics(Fast/Slow)",
                            display: "",
                            display_s: "SC_FS",
                            splitFlag: !0,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            params: [ {
                                name: "KPeriod",
                                alias: "%K",
                                value: 9,
                                default: 9,
                                range: {
                                    min: 1,
                                    max: 255,
                                    step: 1
                                }
                            }, {
                                name: "DPeriod",
                                alias: "%D",
                                value: 3,
                                default: 3,
                                range: {
                                    min: 1,
                                    max: 255,
                                    step: 1
                                }
                            }, {
                                name: "SPeriod",
                                alias: "Slow%D",
                                value: 3,
                                default: 3,
                                range: {
                                    min: 1,
                                    max: 255,
                                    step: 1
                                }
                            } ],
                            plots: [ {
                                name: "FastK",
                                alias: "%K",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "KPeriod"
                            }, {
                                name: "FastD",
                                alias: "%D",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "DPeriod"
                            }, {
                                name: "SlowD",
                                alias: "Slow%D",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                showHideOption: !0,
                                paramLink: "SPeriod"
                            }, {
                                name: "Calc1",
                                alias: "Calc1",
                                ignore: !0
                            }, {
                                name: "Calc2",
                                alias: "Calc2",
                                ignore: !0
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.RSI_TRIPLE,
                            name: "Relative Strength Index",
                            display: "RSI",
                            display_s: "RSI",
                            splitFlag: !0,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            params: [ {
                                name: "Period1",
                                alias: "RSI",
                                value: 7,
                                default: 5,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            }, {
                                name: "Period2",
                                alias: "RSI",
                                value: 14,
                                default: 25,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            }, {
                                name: "Period3",
                                alias: "RSI",
                                value: 42,
                                default: 75,
                                range: {
                                    min: 1,
                                    max: 200,
                                    step: 1
                                },
                                linked: !0
                            } ],
                            plots: [ {
                                name: "RSI_S",
                                alias: "RSI",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period1",
                                showHideOption: !0
                            }, {
                                name: "RSI_M",
                                alias: "RSI",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period2",
                                showHideOption: !0
                            }, {
                                name: "RSI_L",
                                alias: "RSI",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0,
                                paramLink: "Period3",
                                showHideOption: !0
                            }, {
                                name: "Gain",
                                alias: "Gain",
                                ignore: !0
                            }, {
                                name: "Loss",
                                alias: "Loss",
                                ignore: !0
                            } ]
                        }, {
                            code: xUtils.constants.indicatorCodes.RCI,
                            name: "Rank Correlation Index(RCI)",
                            display: "RCI",
                            display_s: "RCI",
                            splitFlag: !0,
                            usedFlag: !1,
                            enable: !0,
                            valid: !0,
                            params: [ {
                                name: "Period1",
                                alias: "",
                                value: 5,
                                default: 5,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Period2",
                                alias: "",
                                value: 20,
                                default: 20,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            }, {
                                name: "Period3",
                                alias: "",
                                value: 60,
                                default: 60,
                                range: {
                                    min: 1,
                                    max: 120,
                                    step: 1
                                }
                            } ],
                            plots: [ {
                                name: "RCI1",
                                alias: "RCI",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[0],
                                lineWeight: 1,
                                lineStyle: 0
                            }, {
                                name: "RCI2",
                                alias: "RCI",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[1],
                                lineWeight: 1,
                                lineStyle: 0
                            }, {
                                name: "RCI3",
                                alias: "RCI",
                                plotStyle: 0,
                                color: xUtils.color.tables.lists[2],
                                lineWeight: 1,
                                lineStyle: 0
                            } ]
                        } ];
                    } catch (e) {
                        console.error(e);
                    }
                }, _didInitIndicatorGroups = function() {
                    try {
                        xUtils.constants.indicatorGroups = {
                            trend: {
                                name: "Trend",
                                display: "",
                                indicators: [ xUtils.constants.indicatorCodes.SMA_TRIPLE, xUtils.constants.indicatorCodes.EMA_TRIPLE, xUtils.constants.indicatorCodes.BOLLINGER_BANDS_TRIPLE, xUtils.constants.indicatorCodes.BOLLINGER_BANDS_TRIPLE_SUPER, xUtils.constants.indicatorCodes.SPANMODEL, xUtils.constants.indicatorCodes.ICHIMOKU_CFD, xUtils.constants.indicatorCodes.HEIKINASHI ]
                            },
                            oscillator: {
                                name: "Oscillator",
                                display: "",
                                indicators: [ xUtils.constants.indicatorCodes.MACD, xUtils.constants.indicatorCodes.STOCHASTIC_CFD, xUtils.constants.indicatorCodes.RSI_TRIPLE, xUtils.constants.indicatorCodes.RCI ]
                            }
                        };
                    } catch (e) {
                        console.error(e);
                    }
                };
                this.didInitSite = function() {
                    _didInitStyles(), _didInitIndicatorCodes(), _didInitIndicators(), _didInitIndicatorGroups();
                };
            };
        };
        module.exports = loadModule(__webpack_require__(0));
    }();
}, function(module, exports, __webpack_require__) {
    !function(global) {
        "use strict";
        var loadModule = function(xUtils, gxDc) {
            var exports = {};
            return exports.didDrawMiniLineChartIn = function(pstDp) {
                if (pstDp) try {
                    var __nLocalXPos1, __nLocalYPos1, __stPrice1, arrData = pstDp.datas, ncCnt = 0;
                    if (!arrData || void 0 === arrData.length || null == (ncCnt = arrData.length) || ncCnt < 2) return;
                    var xEnv = pstDp.stEnv, rcDraw = pstDp.rcDraw;
                    pstDp.margin;
                    xUtils.shapes.InflateRect(rcDraw, 0, -3);
                    for (var nWidth = rcDraw.width, nHeight = rcDraw.height, dMin = 1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, dMax = -1 * xUtils.constants.default.DEFAULT_WRONG_VALUE, ii = 0; ii < ncCnt; ii++) {
                        var __stPrice = arrData[ii];
                        dMin = Math.min(dMin, __stPrice.close), dMax = Math.max(dMax, __stPrice.close);
                    }
                    var dDiff = dMax - dMin, pY = null;
                    if (dDiff < 0) return;
                    0 == dDiff && (pY = Math.round(rcDraw.y + rcDraw.height / 2));
                    var nTotalSize = pstDp.totalSize, dRatioX = nWidth / (nTotalSize - 1), dRatioY = nHeight / dDiff, lineColor = xEnv.MiniChartConfig.LineColor, fillColor = lineColor, __context = pstDp.context;
                    __context.translate(.5, .5);
                    var __drawLinesParam = {
                        context: __context,
                        pts: [],
                        lineWidth: 1,
                        lineColor: lineColor
                    }, __drawPolygonParam = {
                        context: __context,
                        pt1s: [],
                        pt2s: [],
                        lineWidth: 1,
                        lineColor: lineColor,
                        fillColor: fillColor
                    }, __tempHeight = rcDraw.height + 10;
                    __drawPolygonParam.grad = {
                        colors: [ xEnv.MiniChartConfig.BgColor2, xEnv.MiniChartConfig.BgColor1 ],
                        pt1: {
                            x: 0,
                            y: 0
                        },
                        pt2: {
                            x: 0,
                            y: __tempHeight
                        }
                    }, __drawLinesParam.lineColor = xEnv.MiniChartConfig.LineColor;
                    for (var ptStart, ptEnd, bFirst = !0, __dataIndex = 0; __dataIndex < nTotalSize; __dataIndex++) {
                        var __stPrice1 = arrData[__dataIndex];
                        if (!0 === xUtils.validator.isValidPrice(__stPrice1)) {
                            __nLocalXPos1 = Math.round(rcDraw.x + dRatioX * __dataIndex), __nLocalYPos1 = void 0 !== pY && null != pY ? pY : Math.round(rcDraw.y + rcDraw.height - dRatioY * (__stPrice1.close - dMin));
                            var pt = {
                                x: __nLocalXPos1,
                                y: __nLocalYPos1
                            };
                            bFirst && (ptStart = xUtils.didClone(pt), bFirst = !1), ptEnd = xUtils.didClone(pt), 
                            __drawPolygonParam.pt1s.push(pt), __drawLinesParam.pts.push(pt);
                        }
                    }
                    ptStart && ptEnd && (ptEnd.y = ptStart.y = rcDraw.y + __tempHeight, __drawPolygonParam.pt2s.push(ptStart), 
                    __drawPolygonParam.pt2s.push(ptEnd), gxDc.PolygonGradient(__drawPolygonParam)), 
                    gxDc.Lines(__drawLinesParam), __context.translate(-.5, -.5);
                } catch (e) {
                    console.error(e);
                }
            }, exports;
        };
        module.exports = loadModule(__webpack_require__(0), __webpack_require__(1));
    }();
} ]);